
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Aiyane/golinq/api.go (89.7%)</option>
				
				<option value="file1">github.com/Aiyane/golinq/conn.go (54.2%)</option>
				
				<option value="file2">github.com/Aiyane/golinq/driver.go (71.4%)</option>
				
				<option value="file3">github.com/Aiyane/golinq/functions/base.go (10.0%)</option>
				
				<option value="file4">github.com/Aiyane/golinq/functions/custom-func.go (38.1%)</option>
				
				<option value="file5">github.com/Aiyane/golinq/functions/logic-func.go (23.5%)</option>
				
				<option value="file6">github.com/Aiyane/golinq/functions/math-func.go (39.5%)</option>
				
				<option value="file7">github.com/Aiyane/golinq/functions/proxy.go (71.4%)</option>
				
				<option value="file8">github.com/Aiyane/golinq/functions/str-func.go (0.0%)</option>
				
				<option value="file9">github.com/Aiyane/golinq/functions/type-func.go (12.5%)</option>
				
				<option value="file10">github.com/Aiyane/golinq/gen/mysql_lexer.go (100.0%)</option>
				
				<option value="file11">github.com/Aiyane/golinq/gen/mysql_parser.go (47.9%)</option>
				
				<option value="file12">github.com/Aiyane/golinq/gen/mysqlparser_base_listener.go (0.0%)</option>
				
				<option value="file13">github.com/Aiyane/golinq/gen/mysqlparser_base_visitor.go (0.0%)</option>
				
				<option value="file14">github.com/Aiyane/golinq/interpreters/delete-interp.go (92.1%)</option>
				
				<option value="file15">github.com/Aiyane/golinq/interpreters/delete-order-interp.go (100.0%)</option>
				
				<option value="file16">github.com/Aiyane/golinq/interpreters/env.go (100.0%)</option>
				
				<option value="file17">github.com/Aiyane/golinq/interpreters/insert-interp.go (68.5%)</option>
				
				<option value="file18">github.com/Aiyane/golinq/interpreters/record.go (95.9%)</option>
				
				<option value="file19">github.com/Aiyane/golinq/interpreters/select-common-interp.go (94.8%)</option>
				
				<option value="file20">github.com/Aiyane/golinq/interpreters/select-group-base-interp.go (85.8%)</option>
				
				<option value="file21">github.com/Aiyane/golinq/interpreters/select-group-interp.go (100.0%)</option>
				
				<option value="file22">github.com/Aiyane/golinq/interpreters/select-group-order-interp.go (94.0%)</option>
				
				<option value="file23">github.com/Aiyane/golinq/interpreters/select-interp.go (100.0%)</option>
				
				<option value="file24">github.com/Aiyane/golinq/interpreters/select-order-interp.go (98.0%)</option>
				
				<option value="file25">github.com/Aiyane/golinq/interpreters/select-simple-interp.go (100.0%)</option>
				
				<option value="file26">github.com/Aiyane/golinq/interpreters/update-interp.go (82.2%)</option>
				
				<option value="file27">github.com/Aiyane/golinq/interpreters/update-order-interp.go (87.1%)</option>
				
				<option value="file28">github.com/Aiyane/golinq/interpreters/utils.go (24.4%)</option>
				
				<option value="file29">github.com/Aiyane/golinq/response.go (44.4%)</option>
				
				<option value="file30">github.com/Aiyane/golinq/result.go (100.0%)</option>
				
				<option value="file31">github.com/Aiyane/golinq/rows.go (34.1%)</option>
				
				<option value="file32">github.com/Aiyane/golinq/sql-parser/nodes.go (11.8%)</option>
				
				<option value="file33">github.com/Aiyane/golinq/sql-parser/visitor.go (66.2%)</option>
				
				<option value="file34">github.com/Aiyane/golinq/stmt.go (74.7%)</option>
				
				<option value="file35">github.com/Aiyane/golinq/test/test_util.go (76.3%)</option>
				
				<option value="file36">github.com/Aiyane/golinq/test_util.go (82.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package golinq

import (
        "github.com/Aiyane/golinq/functions"
        "github.com/Aiyane/golinq/gen"
        "github.com/Aiyane/golinq/interpreters"
        "github.com/Aiyane/golinq/sql-parser"
        "github.com/Aiyane/golinq/types"
        "github.com/antlr/antlr4/runtime/Go/antlr"
        "github.com/golang-collections/collections/queue"

        "github.com/sirupsen/logrus"
        "reflect"
        "runtime"
        "sync"
)

var (
        sqlCache     map[string]*sql_parser.Tree // 缓存
        once         sync.Once
        lock         sync.Mutex
        SelectInterp types.SelectInterp
        InsertInterp types.InsertInterp
        UpdateInterp types.UpdateInterp
        DeleteInterp types.DeleteInterp
        DB2DataBase  map[string]types.DataSources
)

func init() <span class="cov8" title="1">{
        sqlCache = make(map[string]*sql_parser.Tree)

        SelectInterp = &amp;selectInterp{}
        InsertInterp = &amp;insertInterp{}
        UpdateInterp = &amp;updateInterp{}
        DeleteInterp = &amp;deleteInterp{}

        interpreters.SimpleInterp = &amp;interpreters.Simple{}
        interpreters.OrderInterp = &amp;interpreters.Order{}
        interpreters.GroupInterp = &amp;interpreters.Group{}
        interpreters.GroupOrderInterp = &amp;interpreters.GroupOrder{}

        interpreters.SimpleDeleteInterp = &amp;interpreters.SimpleDelete{}
        interpreters.OrderDeleteInterp = &amp;interpreters.OrderDelete{}

        interpreters.SimpleUpdateInterp = &amp;interpreters.SimpleUpdate{}
        interpreters.OrderUpdateInterp = &amp;interpreters.OrderUpdate{}

        interpreters.TagString = "json"
}</span>

func getSqlTree(sqlExpr string) *sql_parser.Tree <span class="cov8" title="1">{
        inputStream := antlr.NewInputStream(sqlExpr)
        lexer := parser.NewMySqlLexer(inputStream)
        stream := antlr.NewCommonTokenStream(lexer, 0)
        parserRes := parser.NewMySqlParser(stream)
        visitor := sql_parser.NewVisitor()
        tree := parserRes.DmlStatement()
        visitor.Visit(tree.(*parser.DmlStatementContext))
        return visitor.GetTree()
}</span>

func getStack() []byte <span class="cov0" title="0">{
        const size = 4096
        buf := make([]byte, size)
        stackSize := runtime.Stack(buf, false)
        buf = buf[:stackSize]
        return buf
}</span>

// sqlString: select 语句
// dataSources: DataSources 类型对象
// recordStructName: 结果集元素类型名称
// 返回 interface{} 可通过断言获取相应切片类型, 若 recordStructName 传入 "", 则返回值可断言为[]interface{}
func SqlRun(sqlString string, dataSources types.DataSources, recordStructName string) interface{} <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                lock.Unlock()
                if e := recover(); e != nil </span><span class="cov0" title="0">{
                        //panic(e)
                        logrus.Errorf("error=%+v, stack=%s", e, string(getStack()))
                }</span>
        }()
        <span class="cov8" title="1">once.Do(func() </span><span class="cov8" title="1">{
                lock = sync.Mutex{}
        }</span>)
        <span class="cov8" title="1">lock.Lock()
        var sqlTree *sql_parser.Tree
        if tree, exist := sqlCache[sqlString]; exist </span><span class="cov8" title="1">{
                sqlTree = tree
        }</span> else<span class="cov8" title="1"> {
                sqlTree = getSqlTree(sqlString)
                sqlCache[sqlString] = sqlTree
        }</span>
        <span class="cov8" title="1">if sqlTree.InsertStatement != nil </span><span class="cov8" title="1">{
                return InsertInterp.Interp(sqlString, sqlTree, dataSources, recordStructName)
        }</span> else<span class="cov8" title="1"> if sqlTree.UpdateStatement != nil </span><span class="cov8" title="1">{
                return UpdateInterp.Interp(sqlString, sqlTree, dataSources, recordStructName)
        }</span> else<span class="cov8" title="1"> if sqlTree.DeleteStatement != nil </span><span class="cov8" title="1">{
                return DeleteInterp.Interp(sqlString, sqlTree, dataSources, recordStructName)
        }</span> else<span class="cov8" title="1"> if sqlTree.SelectStatementsQueue.Len() &gt; 0 </span><span class="cov8" title="1">{
                return SelectInterp.Interp(sqlString, sqlTree, dataSources, recordStructName)
        }</span>
        <span class="cov0" title="0">logrus.Infof("warning: no valid sql statement")
        return nil</span>
}

type selectInterp struct{}

func (*selectInterp) Interp(sqlString string, sqlTree *sql_parser.Tree, dataSources types.DataSources,
        recordStructName string) interface{} <span class="cov8" title="1">{
        sqlQueue := sqlTree.SelectStatementsQueue
        sqlCacheQueue := queue.New()
        env := interpreters.NewEnv()
        types.RecordStructName = recordStructName
        for </span><span class="cov8" title="1">{
                sqlExpr := sqlQueue.Dequeue().(*sql_parser.SelectStatement)
                sqlCacheQueue.Enqueue(sqlExpr)
                tree := sqlExpr.Tree
                result := interpreters.SqlInterpreter(tree, dataSources, env)
                if sqlQueue.Len() == 0 </span><span class="cov8" title="1">{
                        sqlCache[sqlString].SelectStatementsQueue = sqlCacheQueue
                        if recordStructName != "" </span><span class="cov8" title="1">{
                                // 获取指针类型
                                ptrType := interpreters.TypeRegistry[recordStructName]
                                // 结果切片
                                resSlice := reflect.MakeSlice(reflect.SliceOf(ptrType), 0, len(result))
                                for _, v := range result </span><span class="cov8" title="1">{
                                        resSlice = reflect.Append(resSlice, reflect.ValueOf(v))
                                }</span>
                                <span class="cov8" title="1">return resSlice.Interface()</span>
                        }
                        <span class="cov8" title="1">return result</span>
                }
                <span class="cov8" title="1">env.Link[sqlExpr.Id] = result</span>
        }
}

type insertInterp struct{}

func (*insertInterp) Interp(sqlString string, sqlTree *sql_parser.Tree, dataSources types.DataSources,
        recordStructName string) interface{} <span class="cov8" title="1">{
        tree := sqlTree.InsertStatement
        if sqlTree.InsertStatement.Link != nil </span><span class="cov8" title="1">{
                res := SelectInterp.Interp(sqlString, sqlTree, dataSources, "").([]interface{})
                return interpreters.InsertInterp(tree, dataSources, res)
        }</span>
        <span class="cov8" title="1">return interpreters.InsertInterp(tree, dataSources, nil)</span>
}

type updateInterp struct{}

func (*updateInterp) Interp(sqlString string, sqlTree *sql_parser.Tree, dataSources types.DataSources,
        recordStructName string) interface{} <span class="cov8" title="1">{
        return interpreters.UpdateInterp(sqlTree.UpdateStatement, dataSources)
}</span>

type deleteInterp struct{}

func (*deleteInterp) Interp(sqlString string, sqlTree *sql_parser.Tree, dataSources types.DataSources,
        recordStructName string) interface{} <span class="cov8" title="1">{
        return interpreters.DeleteInterp(sqlTree.DeleteStatement, dataSources)
}</span>

type Entitier interface {
        TableName() string
}

// 通过结构体列表构建 DataSources 类型
func NewDataSources(_dataSources ...interface{}) types.DataSources <span class="cov8" title="1">{
        dataSources := make(types.DataSources, len(_dataSources))
        for _, records := range _dataSources </span><span class="cov8" title="1">{
                v := reflect.ValueOf(records)
                l := v.Len()
                data := make(types.Records, 0, l)
                for i := 0; i &lt; l; i++ </span><span class="cov8" title="1">{
                        data = append(data, v.Index(i).Interface())
                }</span>
                <span class="cov8" title="1">dataSources[v.Index(0).Interface().(Entitier).TableName()] = data</span>
        }
        <span class="cov8" title="1">return dataSources</span>
}

// 注册结果集/原数据集元素类型
// elem = (*T)(nil)
func RegisterType(elem interface{}) <span class="cov8" title="1">{
        interpreters.RegisterType(elem)
}</span>

// 注册内建函数
func RegisterFunc(key string, f functions.SqlClosureFunc) <span class="cov0" title="0">{
        functions.AddFunc(key, f)
}</span>

// 注册 db 对象与数据库映射
func RegisterDB2DataBase(dB2DataBase map[string]types.DataSources) <span class="cov8" title="1">{
        DB2DataBase = dB2DataBase
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package golinq

import (
        "context"
        "database/sql/driver"
        "errors"
        "log"
        "regexp"
        "strings"
        "sync"
)

// FakeConn implements connection
type FakeConn struct {
        db     *FakeDB
        currTx *FakeTx // Transaction pointer
        mu     sync.Mutex
        bad    bool
}

func (c *FakeConn) isBad() bool <span class="cov8" title="1">{
        return false
}</span>

// 开启事务，返回一个事务对象
func (c *FakeConn) Begin() (driver.Tx, error) <span class="cov8" title="1">{
        if c.isBad() </span><span class="cov0" title="0">{
                return nil, driver.ErrBadConn
        }</span>
        <span class="cov8" title="1">if c.currTx != nil </span><span class="cov0" title="0">{
                return nil, errors.New("already in a transaction")
        }</span>
        <span class="cov8" title="1">c.currTx = &amp;FakeTx{c: c}
        return c.currTx, nil</span>
}

// 关闭数据库对象
func (c *FakeConn) Close() (err error) <span class="cov0" title="0">{
        c.db = nil
        return nil
}</span>

// 弃用了，用ExecContext
func (c *FakeConn) Exec(query string, args []driver.Value) (driver.Result, error) <span class="cov0" title="0">{
        panic("ExecContext was not called.")</span>
}

// ExecContext is optional to implement and it returns skip
func (c *FakeConn) ExecContext(ctx context.Context, query string, args []driver.NamedValue) (driver.Result, error) <span class="cov8" title="1">{
        return nil, driver.ErrSkip
}</span>

// 弃用了，用QueryContext
func (c *FakeConn) Query(query string, args []driver.Value) (driver.Rows, error) <span class="cov0" title="0">{
        panic("QueryContext was not called.")</span>
}

// QueryContext is optional
func (c *FakeConn) QueryContext(ctx context.Context, query string, args []driver.NamedValue) (driver.Rows, error) <span class="cov8" title="1">{
        return nil, driver.ErrSkip
}</span>

// 弃用了，用PrepareContext
func (c *FakeConn) Prepare(query string) (driver.Stmt, error) <span class="cov0" title="0">{
        panic("use Prepare")</span>
}

// PrepareContext returns a prepared statement, bound to this connection.
// context is for the preparation of the statement,
// it must not store the context within the statement itself.
func (c *FakeConn) PrepareContext(ctx context.Context, query string) (driver.Stmt, error) <span class="cov8" title="1">{
        var firstStmt = &amp;FakeStmt{q: query, connection: c}
        // Checking how many placeholders do we have
        if strings.Contains(query, "$1") </span><span class="cov0" title="0">{
                r, err := regexp.Compile(`[$]\d+`)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf(`Cant't compile regexp with err [%v]`, err)
                }</span>
                <span class="cov0" title="0">firstStmt.placeholders = len(strings.Split(r.ReplaceAllString(query, `$$$`), "$$")) - 1</span> // Postgres notation
        } else<span class="cov8" title="1"> {
                firstStmt.placeholders = len(strings.Split(query, "?")) - 1 // Postgres notation
        }</span>

        <span class="cov8" title="1">queryParts := strings.Split(query, " ") // By First statement define the query type
        firstStmt.command = strings.ToUpper(queryParts[0])
        return firstStmt, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package golinq

import (
        "database/sql/driver"
        "github.com/Aiyane/golinq/types"
        "log"
        "sync"
)

var _ = log.Printf
var DataBase types.DataSources

// FakeDriver implements driver interface in sql package
type FakeDriver struct {
        mu         sync.Mutex // guards 3 following fields
        openCount  int        // conn opens
        closeCount int        // conn closes
        waitCh     chan struct{}
        waitingCh  chan struct{}
        dbs        map[string]*FakeDB
}

// FakeDB represents the database
type FakeDB struct {
        name    string
        mu      sync.Mutex
        tables  map[string]*table
        badConn bool
}

// table represents the table
type table struct {
        mu      sync.Mutex
        colname []string
        coltype []string
        rows    []*row
}

func (t *table) columnIndex(name string) int <span class="cov0" title="0">{
        for n, name := range t.colname </span><span class="cov0" title="0">{
                if name == name </span><span class="cov0" title="0">{
                        return n
                }</span>
        }
        <span class="cov0" title="0">return -1</span>
}

// Open returns a new connection to the database.
func (d *FakeDriver) Open(database string) (driver.Conn, error) <span class="cov8" title="1">{
        return &amp;FakeConn{db: d.getDB(database)}, nil
}</span>

func (d *FakeDriver) getDB(name string) *FakeDB <span class="cov8" title="1">{
        d.mu.Lock()
        defer d.mu.Unlock()
        if d.dbs == nil </span><span class="cov8" title="1">{
                d.dbs = make(map[string]*FakeDB)
        }</span>
        <span class="cov8" title="1">db, ok := d.dbs[name]
        if !ok </span><span class="cov8" title="1">{
                db = &amp;FakeDB{name: name}
                d.dbs[name] = db
        }</span>
        <span class="cov8" title="1">return db</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package functions

import (
        "fmt"
        "github.com/sirupsen/logrus"
        "strconv"
        "time"
)

type NumType int

const (
        NoNum   NumType = -1
        Uint    NumType = 0
        Uint8   NumType = 1
        Uint16  NumType = 2
        Uint32  NumType = 3
        Uint64  NumType = 4
        Int     NumType = 5
        Int8    NumType = 6
        Int16   NumType = 7
        Int32   NumType = 8
        Int64   NumType = 9
        Float32 NumType = 10
        Float64 NumType = 11
        String  NumType = 12
        Time    NumType = 13
)

var (
        Type2Func = map[NumType]func(interface{}) interface{}{
                Uint:    toUint,
                Uint8:   toUint8,
                Uint16:  toUint16,
                Uint32:  toUint32,
                Uint64:  toUint64,
                Int:     ToInt,
                Int8:    toInt8,
                Int16:   toInt16,
                Int32:   toInt32,
                Int64:   toInt64,
                Float32: toFloat32,
                Float64: toFloat64,
                String:  toString,
                Time:    toTime,
                NoNum:   toSelf,
        }
        Name2Type = map[string]NumType{
                "uint":    Uint,
                "uint8":   Uint8,
                "uint16":  Uint16,
                "uint32":  Uint32,
                "uint64":  Uint64,
                "int":     Int,
                "int8":    Int8,
                "int16":   Int16,
                "int32":   Int32,
                "int64":   Int64,
                "float32": Float32,
                "float64": Float64,
                "string":  String,
                "time":    Time,
        }
)

func Add(i interface{}, i2 interface{}) interface{} <span class="cov8" title="1">{
        t := GNumType(i, i2)
        switch t </span>{
        case Uint:<span class="cov0" title="0">
                return Type2Func[t](i).(uint) + Type2Func[t](i2).(uint)</span>
        case Uint8:<span class="cov0" title="0">
                return Type2Func[t](i).(uint8) + Type2Func[t](i2).(uint8)</span>
        case Uint16:<span class="cov0" title="0">
                return Type2Func[t](i).(uint16) + Type2Func[t](i2).(uint16)</span>
        case Uint32:<span class="cov0" title="0">
                return Type2Func[t](i).(uint32) + Type2Func[t](i2).(uint32)</span>
        case Uint64:<span class="cov0" title="0">
                return Type2Func[t](i).(uint64) + Type2Func[t](i2).(uint64)</span>
        case Int:<span class="cov8" title="1">
                return Type2Func[t](i).(int) + Type2Func[t](i2).(int)</span>
        case Int8:<span class="cov0" title="0">
                return Type2Func[t](i).(int8) + Type2Func[t](i2).(int8)</span>
        case Int16:<span class="cov0" title="0">
                return Type2Func[t](i).(int16) + Type2Func[t](i2).(int16)</span>
        case Int32:<span class="cov0" title="0">
                return Type2Func[t](i).(int32) + Type2Func[t](i2).(int32)</span>
        case Int64:<span class="cov0" title="0">
                return Type2Func[t](i).(int64) + Type2Func[t](i2).(int64)</span>
        case Float32:<span class="cov8" title="1">
                return Type2Func[t](i).(float32) + Type2Func[t](i2).(float32)</span>
        case Float64:<span class="cov8" title="1">
                return Type2Func[t](i).(float64) + Type2Func[t](i2).(float64)</span>
        default:<span class="cov0" title="0">
                logrus.Errorf("[GreaterEqual] type error: v1[%T], v2[%T]", i, i2)
                panic("type error")</span>
        }
}

func Mul(i interface{}, i2 interface{}) interface{} <span class="cov8" title="1">{
        t := GNumType(i, i2)
        switch t </span>{
        case Uint:<span class="cov0" title="0">
                return Type2Func[t](i).(uint) * Type2Func[t](i2).(uint)</span>
        case Uint8:<span class="cov0" title="0">
                return Type2Func[t](i).(uint8) * Type2Func[t](i2).(uint8)</span>
        case Uint16:<span class="cov0" title="0">
                return Type2Func[t](i).(uint16) * Type2Func[t](i2).(uint16)</span>
        case Uint32:<span class="cov0" title="0">
                return Type2Func[t](i).(uint32) * Type2Func[t](i2).(uint32)</span>
        case Uint64:<span class="cov0" title="0">
                return Type2Func[t](i).(uint64) * Type2Func[t](i2).(uint64)</span>
        case Int:<span class="cov8" title="1">
                return Type2Func[t](i).(int) * Type2Func[t](i2).(int)</span>
        case Int8:<span class="cov0" title="0">
                return Type2Func[t](i).(int8) * Type2Func[t](i2).(int8)</span>
        case Int16:<span class="cov0" title="0">
                return Type2Func[t](i).(int16) * Type2Func[t](i2).(int16)</span>
        case Int32:<span class="cov0" title="0">
                return Type2Func[t](i).(int32) * Type2Func[t](i2).(int32)</span>
        case Int64:<span class="cov0" title="0">
                return Type2Func[t](i).(int64) * Type2Func[t](i2).(int64)</span>
        case Float32:<span class="cov0" title="0">
                return Type2Func[t](i).(float32) * Type2Func[t](i2).(float32)</span>
        case Float64:<span class="cov0" title="0">
                return Type2Func[t](i).(float64) * Type2Func[t](i2).(float64)</span>
        default:<span class="cov0" title="0">
                logrus.Errorf("[GreaterEqual] type error: v1[%T], v2[%T]", i, i2)
                panic("type error")</span>
        }
}

func Res(i interface{}, i2 interface{}) interface{} <span class="cov0" title="0">{
        t := GNumType(i, i2)
        switch t </span>{
        case Uint:<span class="cov0" title="0">
                return Type2Func[t](i).(uint) % Type2Func[t](i2).(uint)</span>
        case Uint8:<span class="cov0" title="0">
                return Type2Func[t](i).(uint8) % Type2Func[t](i2).(uint8)</span>
        case Uint16:<span class="cov0" title="0">
                return Type2Func[t](i).(uint16) % Type2Func[t](i2).(uint16)</span>
        case Uint32:<span class="cov0" title="0">
                return Type2Func[t](i).(uint32) % Type2Func[t](i2).(uint32)</span>
        case Uint64:<span class="cov0" title="0">
                return Type2Func[t](i).(uint64) % Type2Func[t](i2).(uint64)</span>
        case Int:<span class="cov0" title="0">
                return Type2Func[t](i).(int) % Type2Func[t](i2).(int)</span>
        case Int8:<span class="cov0" title="0">
                return Type2Func[t](i).(int8) % Type2Func[t](i2).(int8)</span>
        case Int16:<span class="cov0" title="0">
                return Type2Func[t](i).(int16) % Type2Func[t](i2).(int16)</span>
        case Int32:<span class="cov0" title="0">
                return Type2Func[t](i).(int32) % Type2Func[t](i2).(int32)</span>
        case Int64:<span class="cov0" title="0">
                return Type2Func[t](i).(int64) % Type2Func[t](i2).(int64)</span>
        default:<span class="cov0" title="0">
                logrus.Errorf("[Res] type error: v1[%T], v2[%T]", i, i2)
                panic("type error")</span>
        }
}

func Div(i interface{}, i2 interface{}) interface{} <span class="cov0" title="0">{
        return Mul(i, Countdown(i2))
}</span>

func Sub(i interface{}, i2 interface{}) interface{} <span class="cov8" title="1">{
        return Add(i, Negate(i2))
}</span>

func Countdown(i interface{}) interface{} <span class="cov0" title="0">{
        switch v := i.(type) </span>{
        case float32:<span class="cov0" title="0">
                return 1 / v</span>
        case float64:<span class="cov0" title="0">
                return 1 / v</span>
        case int:<span class="cov0" title="0">
                return 1 / float32(v)</span>
        case int8:<span class="cov0" title="0">
                return 1 / float32(v)</span>
        case int16:<span class="cov0" title="0">
                return 1 / float32(v)</span>
        case int32:<span class="cov0" title="0">
                return 1 / float32(v)</span>
        case int64:<span class="cov0" title="0">
                return 1 / float32(v)</span>
        case uint:<span class="cov0" title="0">
                return 1 / float32(v)</span>
        case uint8:<span class="cov0" title="0">
                return 1 / float32(v)</span>
        case uint16:<span class="cov0" title="0">
                return 1 / float32(v)</span>
        case uint32:<span class="cov0" title="0">
                return 1 / float32(v)</span>
        case uint64:<span class="cov0" title="0">
                return 1 / float32(v)</span>
        default:<span class="cov0" title="0">
                logrus.Errorf("[Negate] type error: v1[%T]", v)
                panic("type error")</span>
        }
}

func Negate(i interface{}) interface{} <span class="cov8" title="1">{
        switch v := i.(type) </span>{
        case float32:<span class="cov0" title="0">
                return v * -1</span>
        case float64:<span class="cov8" title="1">
                return v * -1</span>
        case int:<span class="cov8" title="1">
                return v * -1</span>
        case int8:<span class="cov0" title="0">
                return v * -1</span>
        case int16:<span class="cov0" title="0">
                return v * -1</span>
        case int32:<span class="cov0" title="0">
                return v * -1</span>
        case int64:<span class="cov0" title="0">
                return v * -1</span>
        case uint:<span class="cov0" title="0">
                return int(v) * -1</span>
        case uint8:<span class="cov0" title="0">
                return int8(v) * -1</span>
        case uint16:<span class="cov0" title="0">
                return int16(v) * -1</span>
        case uint32:<span class="cov0" title="0">
                return int32(v) * -1</span>
        case uint64:<span class="cov0" title="0">
                return int64(v) * -1</span>
        default:<span class="cov0" title="0">
                logrus.Errorf("[Negate] type error: v1[%T]", v)
                panic("type error")</span>
        }
}

func Equal(i interface{}, i2 interface{}) bool <span class="cov8" title="1">{
        t := GNumType(i, i2)
        if t == Time </span><span class="cov0" title="0">{
                return Type2Func[t](i).(time.Time).Equal(Type2Func[t](i2).(time.Time))
        }</span>
        <span class="cov8" title="1">return Type2Func[t](i) == Type2Func[t](i2)</span>
}

func GreaterEqual(i interface{}, i2 interface{}) bool <span class="cov8" title="1">{
        return Greater(i, i2) || Equal(i, i2)
}</span>

func Greater(i interface{}, i2 interface{}) bool <span class="cov8" title="1">{
        t := GNumType(i, i2)
        switch t </span>{
        case Uint:<span class="cov0" title="0">
                return Type2Func[t](i).(uint) &gt; Type2Func[t](i2).(uint)</span>
        case Uint8:<span class="cov0" title="0">
                return Type2Func[t](i).(uint8) &gt; Type2Func[t](i2).(uint8)</span>
        case Uint16:<span class="cov0" title="0">
                return Type2Func[t](i).(uint16) &gt; Type2Func[t](i2).(uint16)</span>
        case Uint32:<span class="cov0" title="0">
                return Type2Func[t](i).(uint32) &gt; Type2Func[t](i2).(uint32)</span>
        case Uint64:<span class="cov0" title="0">
                return Type2Func[t](i).(uint64) &gt; Type2Func[t](i2).(uint64)</span>
        case Int:<span class="cov8" title="1">
                return Type2Func[t](i).(int) &gt; Type2Func[t](i2).(int)</span>
        case Int8:<span class="cov0" title="0">
                return Type2Func[t](i).(int8) &gt; Type2Func[t](i2).(int8)</span>
        case Int16:<span class="cov0" title="0">
                return Type2Func[t](i).(int16) &gt; Type2Func[t](i2).(int16)</span>
        case Int32:<span class="cov0" title="0">
                return Type2Func[t](i).(int32) &gt; Type2Func[t](i2).(int32)</span>
        case Int64:<span class="cov0" title="0">
                return Type2Func[t](i).(int64) &gt; Type2Func[t](i2).(int64)</span>
        case Float32:<span class="cov8" title="1">
                return Type2Func[t](i).(float32) &gt; Type2Func[t](i2).(float32)</span>
        case Float64:<span class="cov8" title="1">
                return Type2Func[t](i).(float64) &gt; Type2Func[t](i2).(float64)</span>
        case Time, String:<span class="cov0" title="0">
                t1 := toTime(i).(time.Time)
                t2 := toTime(i2).(time.Time)
                return t1.After(t2)</span>
        default:<span class="cov0" title="0">
                logrus.Errorf("[GreaterEqual] type error: v1[%T], v2[%T]", i, i2)
                panic("type error")</span>
        }
}

func LessEqual(i interface{}, i2 interface{}) bool <span class="cov0" title="0">{
        return !Greater(i, i2)
}</span>

func Less(i interface{}, i2 interface{}) bool <span class="cov8" title="1">{
        return !Greater(i, i2) &amp;&amp; !Equal(i, i2)
}</span>

func GNumType(i interface{}, i2 interface{}) NumType <span class="cov8" title="1">{
        t1 := numType(i)
        t2 := numType(i2)
        if t1 &gt; t2 </span><span class="cov8" title="1">{
                return t1
        }</span>
        <span class="cov8" title="1">return t2</span>
}

func numType(i interface{}) NumType <span class="cov8" title="1">{
        switch i.(type) </span>{
        case float32:<span class="cov8" title="1">
                return Float32</span>
        case float64:<span class="cov8" title="1">
                return Float64</span>
        case int:<span class="cov8" title="1">
                return Int</span>
        case int8:<span class="cov0" title="0">
                return Int8</span>
        case int16:<span class="cov0" title="0">
                return Int16</span>
        case int32:<span class="cov0" title="0">
                return Int32</span>
        case int64:<span class="cov0" title="0">
                return Int64</span>
        case uint:<span class="cov0" title="0">
                return Uint</span>
        case uint8:<span class="cov0" title="0">
                return Uint8</span>
        case uint16:<span class="cov0" title="0">
                return Uint16</span>
        case uint32:<span class="cov0" title="0">
                return Uint32</span>
        case uint64:<span class="cov0" title="0">
                return Uint64</span>
        case string:<span class="cov8" title="1">
                return String</span>
        case time.Time:<span class="cov0" title="0">
                return Time</span>
        default:<span class="cov0" title="0">
                return NoNum</span>
        }
}

func toSelf(i interface{}) interface{} <span class="cov0" title="0">{
        return i
}</span>

func toString(i interface{}) interface{} <span class="cov8" title="1">{
        return fmt.Sprintf("%v", i)
}</span>

func ToInt(i interface{}) interface{} <span class="cov8" title="1">{
        switch v := i.(type) </span>{
        case float32:<span class="cov0" title="0">
                return int(v)</span>
        case float64:<span class="cov8" title="1">
                return int(v)</span>
        case int:<span class="cov8" title="1">
                return v</span>
        case int8:<span class="cov0" title="0">
                return int(v)</span>
        case int16:<span class="cov0" title="0">
                return int(v)</span>
        case int32:<span class="cov0" title="0">
                return int(v)</span>
        case int64:<span class="cov0" title="0">
                return int(v)</span>
        case uint:<span class="cov0" title="0">
                return int(v)</span>
        case uint8:<span class="cov0" title="0">
                return int(v)</span>
        case uint16:<span class="cov0" title="0">
                return int(v)</span>
        case uint32:<span class="cov0" title="0">
                return int(v)</span>
        case uint64:<span class="cov0" title="0">
                return int(v)</span>
        case string:<span class="cov0" title="0">
                ret, err := strconv.Atoi(v)
                if err != nil </span><span class="cov0" title="0">{
                        logrus.Errorf("[ToInt] type error: v1[%T]", v)
                        panic(err)</span>
                }
                <span class="cov0" title="0">return ret</span>
        case bool:<span class="cov0" title="0">
                if v </span><span class="cov0" title="0">{
                        return 1
                }</span> else<span class="cov0" title="0"> {
                        return 0
                }</span>
        default:<span class="cov0" title="0">
                logrus.Errorf("[ToInt] type error: v1[%T]", v)
                panic("type err")</span>
        }
}

func toInt8(i interface{}) interface{} <span class="cov0" title="0">{
        switch v := i.(type) </span>{
        case float32:<span class="cov0" title="0">
                return int8(v)</span>
        case float64:<span class="cov0" title="0">
                return int8(v)</span>
        case int:<span class="cov0" title="0">
                return int8(v)</span>
        case int8:<span class="cov0" title="0">
                return v</span>
        case int16:<span class="cov0" title="0">
                return int8(v)</span>
        case int32:<span class="cov0" title="0">
                return int8(v)</span>
        case int64:<span class="cov0" title="0">
                return int8(v)</span>
        case uint:<span class="cov0" title="0">
                return int8(v)</span>
        case uint8:<span class="cov0" title="0">
                return int8(v)</span>
        case uint16:<span class="cov0" title="0">
                return int8(v)</span>
        case uint32:<span class="cov0" title="0">
                return int8(v)</span>
        case uint64:<span class="cov0" title="0">
                return int8(v)</span>
        case string:<span class="cov0" title="0">
                ret, err := strconv.Atoi(v)
                if err != nil </span><span class="cov0" title="0">{
                        logrus.Errorf("[toInt8] type error: v1[%T]", v)
                        panic(err)</span>
                }
                <span class="cov0" title="0">return int8(ret)</span>
        case bool:<span class="cov0" title="0">
                if v </span><span class="cov0" title="0">{
                        return int8(1)
                }</span> else<span class="cov0" title="0"> {
                        return int8(0)
                }</span>
        default:<span class="cov0" title="0">
                logrus.Errorf("[toInt8] type error: v1[%T]", v)
                panic("type err")</span>
        }
}

func toInt16(i interface{}) interface{} <span class="cov0" title="0">{
        switch v := i.(type) </span>{
        case float32:<span class="cov0" title="0">
                return int16(v)</span>
        case float64:<span class="cov0" title="0">
                return int16(v)</span>
        case int:<span class="cov0" title="0">
                return int16(v)</span>
        case int8:<span class="cov0" title="0">
                return int16(v)</span>
        case int16:<span class="cov0" title="0">
                return v</span>
        case int32:<span class="cov0" title="0">
                return int16(v)</span>
        case int64:<span class="cov0" title="0">
                return int16(v)</span>
        case uint:<span class="cov0" title="0">
                return int16(v)</span>
        case uint8:<span class="cov0" title="0">
                return int16(v)</span>
        case uint16:<span class="cov0" title="0">
                return int16(v)</span>
        case uint32:<span class="cov0" title="0">
                return int16(v)</span>
        case uint64:<span class="cov0" title="0">
                return int16(v)</span>
        case string:<span class="cov0" title="0">
                ret, err := strconv.Atoi(v)
                if err != nil </span><span class="cov0" title="0">{
                        logrus.Errorf("[toInt16] type error: v1[%T]", v)
                        panic(err)</span>
                }
                <span class="cov0" title="0">return int16(ret)</span>
        case bool:<span class="cov0" title="0">
                if v </span><span class="cov0" title="0">{
                        return int16(1)
                }</span> else<span class="cov0" title="0"> {
                        return int16(0)
                }</span>
        default:<span class="cov0" title="0">
                logrus.Errorf("[toInt16] type error: v1[%T]", v)
                panic("type err")</span>
        }
}

func toInt32(i interface{}) interface{} <span class="cov0" title="0">{
        switch v := i.(type) </span>{
        case float32:<span class="cov0" title="0">
                return int32(v)</span>
        case float64:<span class="cov0" title="0">
                return int32(v)</span>
        case int:<span class="cov0" title="0">
                return int32(v)</span>
        case int8:<span class="cov0" title="0">
                return int32(v)</span>
        case int16:<span class="cov0" title="0">
                return int32(v)</span>
        case int32:<span class="cov0" title="0">
                return v</span>
        case int64:<span class="cov0" title="0">
                return int32(v)</span>
        case uint:<span class="cov0" title="0">
                return int32(v)</span>
        case uint8:<span class="cov0" title="0">
                return int32(v)</span>
        case uint16:<span class="cov0" title="0">
                return int32(v)</span>
        case uint32:<span class="cov0" title="0">
                return int32(v)</span>
        case uint64:<span class="cov0" title="0">
                return int32(v)</span>
        case string:<span class="cov0" title="0">
                ret, err := strconv.Atoi(v)
                if err != nil </span><span class="cov0" title="0">{
                        logrus.Errorf("[toInt32] type error: v1[%T]", v)
                        panic(err)</span>
                }
                <span class="cov0" title="0">return int32(ret)</span>
        case bool:<span class="cov0" title="0">
                if v </span><span class="cov0" title="0">{
                        return int32(1)
                }</span> else<span class="cov0" title="0"> {
                        return int32(0)
                }</span>
        default:<span class="cov0" title="0">
                logrus.Errorf("[toInt32] type error: v1[%T]", v)
                panic("type err")</span>
        }
}

func toInt64(i interface{}) interface{} <span class="cov0" title="0">{
        switch v := i.(type) </span>{
        case float32:<span class="cov0" title="0">
                return int64(v)</span>
        case float64:<span class="cov0" title="0">
                return int64(v)</span>
        case int:<span class="cov0" title="0">
                return int64(v)</span>
        case int8:<span class="cov0" title="0">
                return int64(v)</span>
        case int16:<span class="cov0" title="0">
                return int64(v)</span>
        case int32:<span class="cov0" title="0">
                return int64(v)</span>
        case int64:<span class="cov0" title="0">
                return v</span>
        case uint:<span class="cov0" title="0">
                return int64(v)</span>
        case uint8:<span class="cov0" title="0">
                return int64(v)</span>
        case uint16:<span class="cov0" title="0">
                return int64(v)</span>
        case uint32:<span class="cov0" title="0">
                return int64(v)</span>
        case uint64:<span class="cov0" title="0">
                return int64(v)</span>
        case string:<span class="cov0" title="0">
                ret, err := strconv.Atoi(v)
                if err != nil </span><span class="cov0" title="0">{
                        logrus.Errorf("[toInt64] type error: v1[%T]", v)
                        panic(err)</span>
                }
                <span class="cov0" title="0">return int64(ret)</span>
        case bool:<span class="cov0" title="0">
                if v </span><span class="cov0" title="0">{
                        return int64(1)
                }</span> else<span class="cov0" title="0"> {
                        return int64(0)
                }</span>
        default:<span class="cov0" title="0">
                logrus.Errorf("[toInt64] type error: v1[%T]", v)
                panic("type err")</span>
        }
}

func toFloat32(i interface{}) interface{} <span class="cov8" title="1">{
        switch v := i.(type) </span>{
        case float32:<span class="cov8" title="1">
                return v</span>
        case float64:<span class="cov0" title="0">
                return float32(v)</span>
        case int:<span class="cov8" title="1">
                return float32(v)</span>
        case int8:<span class="cov0" title="0">
                return float32(v)</span>
        case int16:<span class="cov0" title="0">
                return float32(v)</span>
        case int32:<span class="cov0" title="0">
                return float32(v)</span>
        case int64:<span class="cov0" title="0">
                return float32(v)</span>
        case uint:<span class="cov0" title="0">
                return float32(v)</span>
        case uint8:<span class="cov0" title="0">
                return float32(v)</span>
        case uint16:<span class="cov0" title="0">
                return float32(v)</span>
        case uint32:<span class="cov0" title="0">
                return float32(v)</span>
        case uint64:<span class="cov0" title="0">
                return float32(v)</span>
        case string:<span class="cov0" title="0">
                ret, err := strconv.ParseFloat(v, 32)
                if err != nil </span><span class="cov0" title="0">{
                        logrus.Errorf("[toFloat32] type error: v1[%T]", v)
                        panic(err)</span>
                }
                <span class="cov0" title="0">return ret</span>
        case bool:<span class="cov0" title="0">
                if v </span><span class="cov0" title="0">{
                        return float32(1)
                }</span> else<span class="cov0" title="0"> {
                        return float32(0)
                }</span>
        default:<span class="cov0" title="0">
                logrus.Errorf("[toFloat32] type error: v1[%T]", v)
                panic("type err")</span>
        }
}

func toFloat64(i interface{}) interface{} <span class="cov8" title="1">{
        switch v := i.(type) </span>{
        case float32:<span class="cov0" title="0">
                return float64(v)</span>
        case float64:<span class="cov8" title="1">
                return v</span>
        case int:<span class="cov8" title="1">
                return float64(v)</span>
        case int8:<span class="cov0" title="0">
                return float64(v)</span>
        case int16:<span class="cov0" title="0">
                return float64(v)</span>
        case int32:<span class="cov0" title="0">
                return float64(v)</span>
        case int64:<span class="cov0" title="0">
                return float64(v)</span>
        case uint:<span class="cov0" title="0">
                return float64(v)</span>
        case uint8:<span class="cov0" title="0">
                return float64(v)</span>
        case uint16:<span class="cov0" title="0">
                return float64(v)</span>
        case uint32:<span class="cov0" title="0">
                return float64(v)</span>
        case uint64:<span class="cov0" title="0">
                return float64(v)</span>
        case string:<span class="cov0" title="0">
                ret, err := strconv.ParseFloat(v, 64)
                if err != nil </span><span class="cov0" title="0">{
                        logrus.Errorf("[toFloat64] type error: v1[%T]", v)
                        panic(err)</span>
                }
                <span class="cov0" title="0">return ret</span>
        case bool:<span class="cov0" title="0">
                if v </span><span class="cov0" title="0">{
                        return float64(1)
                }</span> else<span class="cov0" title="0"> {
                        return float64(0)
                }</span>
        default:<span class="cov0" title="0">
                logrus.Errorf("[toFloat64] type error: v1[%T]", v)
                panic("type err")</span>
        }
}

func toUint(i interface{}) interface{} <span class="cov0" title="0">{
        switch v := i.(type) </span>{
        case float32:<span class="cov0" title="0">
                return uint(v)</span>
        case float64:<span class="cov0" title="0">
                return uint(v)</span>
        case int:<span class="cov0" title="0">
                return uint(v)</span>
        case int8:<span class="cov0" title="0">
                return uint(v)</span>
        case int16:<span class="cov0" title="0">
                return uint(v)</span>
        case int32:<span class="cov0" title="0">
                return uint(v)</span>
        case int64:<span class="cov0" title="0">
                return uint(v)</span>
        case uint:<span class="cov0" title="0">
                return v</span>
        case uint8:<span class="cov0" title="0">
                return uint(v)</span>
        case uint16:<span class="cov0" title="0">
                return uint(v)</span>
        case uint32:<span class="cov0" title="0">
                return uint(v)</span>
        case uint64:<span class="cov0" title="0">
                return uint(v)</span>
        case string:<span class="cov0" title="0">
                ret, err := strconv.Atoi(v)
                if err != nil </span><span class="cov0" title="0">{
                        logrus.Errorf("[toUint] type error: v1[%T]", v)
                        panic(err)</span>
                }
                <span class="cov0" title="0">return uint(ret)</span>
        case bool:<span class="cov0" title="0">
                if v </span><span class="cov0" title="0">{
                        return uint(1)
                }</span> else<span class="cov0" title="0"> {
                        return uint(0)
                }</span>
        default:<span class="cov0" title="0">
                logrus.Errorf("[toUint] type error: v1[%T]", v)
                panic("type err")</span>
        }
}

func toUint8(i interface{}) interface{} <span class="cov0" title="0">{
        switch v := i.(type) </span>{
        case float32:<span class="cov0" title="0">
                return uint8(v)</span>
        case float64:<span class="cov0" title="0">
                return uint8(v)</span>
        case int:<span class="cov0" title="0">
                return uint8(v)</span>
        case int8:<span class="cov0" title="0">
                return uint8(v)</span>
        case int16:<span class="cov0" title="0">
                return uint8(v)</span>
        case int32:<span class="cov0" title="0">
                return uint8(v)</span>
        case int64:<span class="cov0" title="0">
                return uint8(v)</span>
        case uint:<span class="cov0" title="0">
                return uint8(v)</span>
        case uint8:<span class="cov0" title="0">
                return v</span>
        case uint16:<span class="cov0" title="0">
                return uint8(v)</span>
        case uint32:<span class="cov0" title="0">
                return uint8(v)</span>
        case uint64:<span class="cov0" title="0">
                return uint8(v)</span>
        case string:<span class="cov0" title="0">
                ret, err := strconv.Atoi(v)
                if err != nil </span><span class="cov0" title="0">{
                        logrus.Errorf("[toUint8] type error: v1[%T]", v)
                        panic(err)</span>
                }
                <span class="cov0" title="0">return uint8(ret)</span>
        case bool:<span class="cov0" title="0">
                if v </span><span class="cov0" title="0">{
                        return uint8(1)
                }</span> else<span class="cov0" title="0"> {
                        return uint8(0)
                }</span>
        default:<span class="cov0" title="0">
                logrus.Errorf("[toUint8] type error: v1[%T]", v)
                panic("type err")</span>
        }
}

func toUint16(i interface{}) interface{} <span class="cov0" title="0">{
        switch v := i.(type) </span>{
        case float32:<span class="cov0" title="0">
                return uint16(v)</span>
        case float64:<span class="cov0" title="0">
                return uint16(v)</span>
        case int:<span class="cov0" title="0">
                return uint16(v)</span>
        case int8:<span class="cov0" title="0">
                return uint16(v)</span>
        case int16:<span class="cov0" title="0">
                return uint16(v)</span>
        case int32:<span class="cov0" title="0">
                return uint16(v)</span>
        case int64:<span class="cov0" title="0">
                return uint16(v)</span>
        case uint:<span class="cov0" title="0">
                return uint16(v)</span>
        case uint8:<span class="cov0" title="0">
                return uint16(v)</span>
        case uint16:<span class="cov0" title="0">
                return v</span>
        case uint32:<span class="cov0" title="0">
                return uint16(v)</span>
        case uint64:<span class="cov0" title="0">
                return uint16(v)</span>
        case string:<span class="cov0" title="0">
                ret, err := strconv.Atoi(v)
                if err != nil </span><span class="cov0" title="0">{
                        logrus.Errorf("[toUint16] type error: v1[%T]", v)
                        panic(err)</span>
                }
                <span class="cov0" title="0">return uint16(ret)</span>
        case bool:<span class="cov0" title="0">
                if v </span><span class="cov0" title="0">{
                        return uint16(1)
                }</span> else<span class="cov0" title="0"> {
                        return uint16(0)
                }</span>
        default:<span class="cov0" title="0">
                logrus.Errorf("[toUint16] type error: v1[%T]", v)
                panic("type err")</span>
        }
}

func toUint32(i interface{}) interface{} <span class="cov0" title="0">{
        switch v := i.(type) </span>{
        case float32:<span class="cov0" title="0">
                return uint32(v)</span>
        case float64:<span class="cov0" title="0">
                return uint32(v)</span>
        case int:<span class="cov0" title="0">
                return uint32(v)</span>
        case int8:<span class="cov0" title="0">
                return uint32(v)</span>
        case int16:<span class="cov0" title="0">
                return uint32(v)</span>
        case int32:<span class="cov0" title="0">
                return uint32(v)</span>
        case int64:<span class="cov0" title="0">
                return uint32(v)</span>
        case uint:<span class="cov0" title="0">
                return uint32(v)</span>
        case uint8:<span class="cov0" title="0">
                return uint32(v)</span>
        case uint16:<span class="cov0" title="0">
                return uint32(v)</span>
        case uint32:<span class="cov0" title="0">
                return v</span>
        case uint64:<span class="cov0" title="0">
                return uint32(v)</span>
        case string:<span class="cov0" title="0">
                ret, err := strconv.Atoi(v)
                if err != nil </span><span class="cov0" title="0">{
                        logrus.Errorf("[toUint32] type error: v1[%T]", v)
                        panic(err)</span>
                }
                <span class="cov0" title="0">return uint32(ret)</span>
        case bool:<span class="cov0" title="0">
                if v </span><span class="cov0" title="0">{
                        return uint32(1)
                }</span> else<span class="cov0" title="0"> {
                        return uint32(0)
                }</span>
        default:<span class="cov0" title="0">
                logrus.Errorf("[toUint32] type error: v1[%T]", v)
                panic("type err")</span>
        }
}

func toUint64(i interface{}) interface{} <span class="cov0" title="0">{
        switch v := i.(type) </span>{
        case float32:<span class="cov0" title="0">
                return uint64(v)</span>
        case float64:<span class="cov0" title="0">
                return uint64(v)</span>
        case int:<span class="cov0" title="0">
                return uint64(v)</span>
        case int8:<span class="cov0" title="0">
                return uint64(v)</span>
        case int16:<span class="cov0" title="0">
                return uint64(v)</span>
        case int32:<span class="cov0" title="0">
                return uint64(v)</span>
        case int64:<span class="cov0" title="0">
                return uint64(v)</span>
        case uint:<span class="cov0" title="0">
                return uint64(v)</span>
        case uint8:<span class="cov0" title="0">
                return uint64(v)</span>
        case uint16:<span class="cov0" title="0">
                return uint64(v)</span>
        case uint32:<span class="cov0" title="0">
                return uint64(v)</span>
        case uint64:<span class="cov0" title="0">
                return v</span>
        case string:<span class="cov0" title="0">
                ret, err := strconv.Atoi(v)
                if err != nil </span><span class="cov0" title="0">{
                        logrus.Errorf("[toUint64] type error: v1[%T]", v)
                        panic(err)</span>
                }
                <span class="cov0" title="0">return uint64(ret)</span>
        case bool:<span class="cov0" title="0">
                if v </span><span class="cov0" title="0">{
                        return uint64(1)
                }</span> else<span class="cov0" title="0"> {
                        return uint64(0)
                }</span>
        default:<span class="cov0" title="0">
                logrus.Errorf("[toUint64] type error: v1[%T]", v)
                panic("type err")</span>
        }
}

func toTime(stringTime interface{}) interface{} <span class="cov0" title="0">{
        switch v := stringTime.(type) </span>{
        case time.Time:<span class="cov0" title="0">
                return v</span>
        case string:<span class="cov0" title="0">
                l := len([]rune(v))
                if l == 19 </span><span class="cov0" title="0">{
                        theTime, err := time.ParseInLocation(timeLayout, v, time.Local)
                        if err != nil </span><span class="cov0" title="0">{
                                logrus.Errorf("[toTime] has error the stringTime len: %v", l)
                                panic(err)</span>
                        }
                        <span class="cov0" title="0">return theTime</span>
                }
                <span class="cov0" title="0">theTime, err := time.ParseInLocation(dateLayout, v, time.Local)
                if err != nil </span><span class="cov0" title="0">{
                        logrus.Errorf("[toTime] has error the stringTime len: %v", l)
                        panic(err)</span>
                }
                <span class="cov0" title="0">return theTime</span>
        }
        <span class="cov0" title="0">logrus.Errorf("[toTime] has error the stringTime: %v", stringTime)
        panic("type error")</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package functions

import (
        "github.com/sirupsen/logrus"
        "time"
)

func deflateFunc() SqlFunc <span class="cov8" title="1">{
        return func(x ...interface{}) interface{} </span><span class="cov8" title="1">{
                switch x0 := x[0].(type) </span>{
                case GroupRecord:<span class="cov8" title="1">
                        return deflate(x0, x[1], x[2].(GroupRecord))</span>
                default:<span class="cov0" title="0">
                        return deflate(x[0].([]interface{}), x[1], x[2].([]interface{}))</span>
                }
        }
}

func deflate(itemTypes []interface{}, valType interface{}, itemValues []interface{}) interface{} <span class="cov8" title="1">{
        // 多个记录中 itemTypes 字段的值等于 valType 的记录的值求和
        var res interface{} = 0
        for i, subType := range itemTypes </span><span class="cov8" title="1">{
                if Equal(subType, valType) </span><span class="cov8" title="1">{
                        res = Add(res, itemValues[i])
                }</span>
        }
        <span class="cov8" title="1">return res</span>
}

const dateLayout = "2006-01-02"
const timeLayout = "2006-01-02 15:04:05"

func dateToStr() SqlFunc <span class="cov0" title="0">{
        return func(x ...interface{}) interface{} </span><span class="cov0" title="0">{
                switch v := x[0].(type) </span>{
                case time.Time:<span class="cov0" title="0">
                        return v.Format(dateLayout)</span>
                case string:<span class="cov0" title="0">
                        return []rune(v)[:10]</span>
                default:<span class="cov0" title="0">
                        logrus.Errorf("[dateToStr] type error: %T", v)
                        panic("type error")</span>
                }
        }
}

func timeToStr() SqlFunc <span class="cov0" title="0">{
        return func(x ...interface{}) interface{} </span><span class="cov0" title="0">{
                switch v := x[0].(type) </span>{
                case time.Time:<span class="cov0" title="0">
                        return v.Format(timeLayout)</span>
                case string:<span class="cov0" title="0">
                        return []rune(v)[:19]</span>
                default:<span class="cov0" title="0">
                        logrus.Errorf("[timeToStr] type error: %T", v)
                        panic("type error")</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package functions

func not() SqlFunc <span class="cov0" title="0">{
        return func(x ...interface{}) interface{} </span><span class="cov0" title="0">{
                return x[0] == nil || x[0] == false || len(x[0].([]interface{})) == 0
        }</span>
}

func signalNot() SqlFunc <span class="cov0" title="0">{
        return func(x ...interface{}) interface{} </span><span class="cov0" title="0">{
                return x[0] == nil || x[0] == false || len(x[0].([]interface{})) == 0
        }</span>
}

func signalExclamation() SqlFunc <span class="cov0" title="0">{
        return func(x ...interface{}) interface{} </span><span class="cov0" title="0">{
                return x[0] == nil || x[0] == false || len(x[0].([]interface{})) == 0
        }</span>
}

func exist() SqlFunc <span class="cov0" title="0">{
        return func(x ...interface{}) interface{} </span><span class="cov0" title="0">{
                return x != nil
        }</span>
}

func is() SqlFunc <span class="cov0" title="0">{
        return func(x ...interface{}) interface{} </span><span class="cov0" title="0">{
                return Equal(x[0], x[1])
        }</span>
}

func isNot() SqlFunc <span class="cov0" title="0">{
        return func(x ...interface{}) interface{} </span><span class="cov0" title="0">{
                return !Equal(x[0], x[1])
        }</span>
}

func in() SqlFunc <span class="cov8" title="1">{
        return func(x ...interface{}) interface{} </span><span class="cov8" title="1">{
                for _, _x := range x[1].([]interface{}) </span><span class="cov8" title="1">{
                        if Equal(_x, x[0]) </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
                <span class="cov8" title="1">return false</span>
        }
}

func notIn() SqlFunc <span class="cov8" title="1">{
        return func(x ...interface{}) interface{} </span><span class="cov8" title="1">{
                for _, _x := range x[1].([]interface{}) </span><span class="cov8" title="1">{
                        if Equal(_x, x[0]) </span><span class="cov8" title="1">{
                                return false
                        }</span>
                }
                <span class="cov8" title="1">return true</span>
        }
}

func or() SqlFunc <span class="cov8" title="1">{
        return func(x ...interface{}) interface{} </span><span class="cov8" title="1">{
                return x[0].(bool) || x[1].(bool)
        }</span>
}

func and() SqlFunc <span class="cov8" title="1">{
        return func(x ...interface{}) interface{} </span><span class="cov8" title="1">{
                return x[0].(bool) &amp;&amp; x[1].(bool)
        }</span>
}

func equal() SqlFunc <span class="cov8" title="1">{
        return func(x ...interface{}) interface{} </span><span class="cov8" title="1">{
                return Equal(x[0], x[1])
        }</span>
}

func greaterEqual() SqlFunc <span class="cov8" title="1">{
        return func(x ...interface{}) interface{} </span><span class="cov8" title="1">{
                return GreaterEqual(x[0], x[1])
        }</span>
}

func lessEqual() SqlFunc <span class="cov0" title="0">{
        return func(x ...interface{}) interface{} </span><span class="cov0" title="0">{
                return LessEqual(x[0], x[1])
        }</span>
}

func greater() SqlFunc <span class="cov8" title="1">{
        return func(x ...interface{}) interface{} </span><span class="cov8" title="1">{
                return Greater(x[0], x[1])
        }</span>
}

func less() SqlFunc <span class="cov8" title="1">{
        return func(x ...interface{}) interface{} </span><span class="cov8" title="1">{
                return Less(x[0], x[1])
        }</span>
}

func notEqual() SqlFunc <span class="cov8" title="1">{
        return func(x ...interface{}) interface{} </span><span class="cov8" title="1">{
                return !Equal(x[0], x[1])
        }</span>
}

func allEqual() SqlFunc <span class="cov0" title="0">{
        return func(x ...interface{}) interface{} </span><span class="cov0" title="0">{
                for _, _y := range x[1].([]interface{}) </span><span class="cov0" title="0">{
                        if !Equal(x[0], _y) </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
                <span class="cov0" title="0">return true</span>
        }
}

func allGreaterEqual() SqlFunc <span class="cov0" title="0">{
        return func(x ...interface{}) interface{} </span><span class="cov0" title="0">{
                for _, _y := range x[1].([]interface{}) </span><span class="cov0" title="0">{
                        if Less(x[0], _y) </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
                <span class="cov0" title="0">return true</span>
        }
}

func allLessEqual() SqlFunc <span class="cov0" title="0">{
        return func(x ...interface{}) interface{} </span><span class="cov0" title="0">{
                for _, _y := range x[1].([]interface{}) </span><span class="cov0" title="0">{
                        if Greater(x[0], _y) </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
                <span class="cov0" title="0">return true</span>
        }
}

func allGreater() SqlFunc <span class="cov0" title="0">{
        return func(x ...interface{}) interface{} </span><span class="cov0" title="0">{
                for _, _y := range x[1].([]interface{}) </span><span class="cov0" title="0">{
                        if LessEqual(x[0], _y) </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
                <span class="cov0" title="0">return true</span>
        }
}

func allLess() SqlFunc <span class="cov0" title="0">{
        return func(x ...interface{}) interface{} </span><span class="cov0" title="0">{
                for _, _y := range x[1].([]interface{}) </span><span class="cov0" title="0">{
                        if GreaterEqual(x[0], _y) </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
                <span class="cov0" title="0">return true</span>
        }
}

func allNotEqual() SqlFunc <span class="cov0" title="0">{
        return func(x ...interface{}) interface{} </span><span class="cov0" title="0">{
                for _, _y := range x[1].([]interface{}) </span><span class="cov0" title="0">{
                        if !Equal(x[0], _y) </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
                <span class="cov0" title="0">return true</span>
        }
}

func anyEqual() SqlFunc <span class="cov0" title="0">{
        return func(x ...interface{}) interface{} </span><span class="cov0" title="0">{
                for _, _y := range x[1].([]interface{}) </span><span class="cov0" title="0">{
                        if Equal(x[0], _y) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
                <span class="cov0" title="0">return false</span>
        }
}

func anyGreaterEqual() SqlFunc <span class="cov0" title="0">{
        return func(x ...interface{}) interface{} </span><span class="cov0" title="0">{
                for _, _y := range x[1].([]interface{}) </span><span class="cov0" title="0">{
                        if GreaterEqual(x[0], _y) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
                <span class="cov0" title="0">return false</span>
        }
}

func anyLessEqual() SqlFunc <span class="cov0" title="0">{
        return func(x ...interface{}) interface{} </span><span class="cov0" title="0">{
                for _, _y := range x[1].([]interface{}) </span><span class="cov0" title="0">{
                        if LessEqual(x[0], _y) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
                <span class="cov0" title="0">return false</span>
        }
}

func anyGreater() SqlFunc <span class="cov0" title="0">{
        return func(x ...interface{}) interface{} </span><span class="cov0" title="0">{
                for _, _y := range x[1].([]interface{}) </span><span class="cov0" title="0">{
                        if Greater(x[0], _y) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
                <span class="cov0" title="0">return false</span>
        }
}

func anyLess() SqlFunc <span class="cov0" title="0">{
        return func(x ...interface{}) interface{} </span><span class="cov0" title="0">{
                for _, _y := range x[1].([]interface{}) </span><span class="cov0" title="0">{
                        if Less(x[0], _y) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
                <span class="cov0" title="0">return false</span>
        }
}

func anyNotEqual() SqlFunc <span class="cov0" title="0">{
        return func(x ...interface{}) interface{} </span><span class="cov0" title="0">{
                for _, _y := range x[1].([]interface{}) </span><span class="cov0" title="0">{
                        if !Equal(x[0], _y) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
                <span class="cov0" title="0">return false</span>
        }
}

func notBetween() SqlFunc <span class="cov0" title="0">{
        return func(x ...interface{}) interface{} </span><span class="cov0" title="0">{
                return Less(x[0], x[1]) || Greater(x[0], x[2])
        }</span>
}

func between() SqlFunc <span class="cov0" title="0">{
        return func(x ...interface{}) interface{} </span><span class="cov0" title="0">{
                return GreaterEqual(x[0], x[1]) || LessEqual(x[0], x[2])
        }</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package functions

func signalAdd() SqlFunc <span class="cov0" title="0">{
        return func(x ...interface{}) interface{} </span><span class="cov0" title="0">{
                return x[0]
        }</span>
}

func signalSub() SqlFunc <span class="cov0" title="0">{
        return func(x ...interface{}) interface{} </span><span class="cov0" title="0">{
                return Negate(x[0])
        }</span>
}

func doubleSub() SqlFunc <span class="cov0" title="0">{
        return func(x ...interface{}) interface{} </span><span class="cov0" title="0">{
                return x[0]
        }</span>
}

func add() SqlFunc <span class="cov8" title="1">{
        return func(x ...interface{}) interface{} </span><span class="cov8" title="1">{
                return Add(x[0], x[1])
        }</span>
}

func sub() SqlFunc <span class="cov8" title="1">{
        return func(x ...interface{}) interface{} </span><span class="cov8" title="1">{
                return Sub(x[0], x[1])
        }</span>
}

func mul() SqlFunc <span class="cov8" title="1">{
        return func(x ...interface{}) interface{} </span><span class="cov8" title="1">{
                return Mul(x[0], x[1])
        }</span>
}

func div() SqlFunc <span class="cov0" title="0">{
        return func(x ...interface{}) interface{} </span><span class="cov0" title="0">{
                return Div(x[0], x[1])
        }</span>
}

func res() SqlFunc <span class="cov0" title="0">{
        return func(x ...interface{}) interface{} </span><span class="cov0" title="0">{
                return Res(x[0], x[1])
        }</span>
}

func sum() SqlFunc <span class="cov8" title="1">{
        var s interface{} = 0
        return func(x ...interface{}) interface{} </span><span class="cov8" title="1">{
                switch v := x[0].(type) </span>{
                case []float64:<span class="cov0" title="0">
                        for _, item := range v </span><span class="cov0" title="0">{
                                s = Add(s, item)
                        }</span>
                case []int:<span class="cov0" title="0">
                        for _, item := range v </span><span class="cov0" title="0">{
                                s = Add(s, item)
                        }</span>
                case []float32:<span class="cov0" title="0">
                        for _, item := range v </span><span class="cov0" title="0">{
                                s = Add(s, item)
                        }</span>
                case []int8:<span class="cov0" title="0">
                        for _, item := range v </span><span class="cov0" title="0">{
                                s = Add(s, item)
                        }</span>
                case []int16:<span class="cov0" title="0">
                        for _, item := range v </span><span class="cov0" title="0">{
                                s = Add(s, item)
                        }</span>
                case []int32:<span class="cov0" title="0">
                        for _, item := range v </span><span class="cov0" title="0">{
                                s = Add(s, item)
                        }</span>
                case []int64:<span class="cov0" title="0">
                        for _, item := range v </span><span class="cov0" title="0">{
                                s = Add(s, item)
                        }</span>
                case []uint:<span class="cov0" title="0">
                        for _, item := range v </span><span class="cov0" title="0">{
                                s = Add(s, item)
                        }</span>
                case []uint8:<span class="cov0" title="0">
                        for _, item := range v </span><span class="cov0" title="0">{
                                s = Add(s, item)
                        }</span>
                case []uint16:<span class="cov0" title="0">
                        for _, item := range v </span><span class="cov0" title="0">{
                                s = Add(s, item)
                        }</span>
                case []uint32:<span class="cov0" title="0">
                        for _, item := range v </span><span class="cov0" title="0">{
                                s = Add(s, item)
                        }</span>
                case []uint64:<span class="cov0" title="0">
                        for _, item := range v </span><span class="cov0" title="0">{
                                s = Add(s, item)
                        }</span>
                default:<span class="cov8" title="1">
                        s = Add(s, v)</span>
                }
                <span class="cov8" title="1">return s</span>
        }
}

func count() SqlFunc <span class="cov8" title="1">{
        var s interface{} = 0
        return func(x ...interface{}) interface{} </span><span class="cov8" title="1">{
                switch v := x[0].(type) </span>{
                case []interface{}:<span class="cov8" title="1">
                        s = Add(s, len(v))</span>
                default:<span class="cov8" title="1">
                        s = Add(s, 1)</span>
                }
                <span class="cov8" title="1">return s</span>
        }
}

func gcount() SqlFunc <span class="cov8" title="1">{
        return func(x ...interface{}) interface{} </span><span class="cov8" title="1">{
                switch v := x[0].(type) </span>{
                case []interface{}:<span class="cov8" title="1">
                        return len(v)</span>
                case GroupRecord:<span class="cov0" title="0">
                        return len(v)</span>
                default:<span class="cov0" title="0">
                        return 1</span>
                }
        }
}

func gsum() SqlFunc <span class="cov8" title="1">{
        return func(x ...interface{}) interface{} </span><span class="cov8" title="1">{
                switch v := x[0].(type) </span>{
                case []interface{}:<span class="cov0" title="0">
                        var s interface{} = 0
                        for _, val := range v </span><span class="cov0" title="0">{
                                s = Add(s, val)
                        }</span>
                        <span class="cov0" title="0">return s</span>
                case GroupRecord:<span class="cov8" title="1">
                        var s interface{} = 0
                        for _, val := range v </span><span class="cov8" title="1">{
                                switch subV := val.(type) </span>{
                                case int, float32, float64, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64:<span class="cov8" title="1">
                                        s = Add(s, subV)</span>
                                default:<span class="cov0" title="0">
                                        s = Add(s, 1)</span>
                                }
                        }
                        <span class="cov8" title="1">return s</span>
                case int, float32, float64, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64:<span class="cov0" title="0">
                        return v</span>
                default:<span class="cov0" title="0">
                        return 1.0</span>
                }
        }
}

func lenFunc() SqlFunc <span class="cov8" title="1">{
        return func(x ...interface{}) interface{} </span><span class="cov8" title="1">{
                switch v := x[0].(type) </span>{
                case []interface{}:<span class="cov0" title="0">
                        return len(v)</span>
                case GroupRecord:<span class="cov0" title="0">
                        return len(v)</span>
                case string:<span class="cov8" title="1">
                        return len([]rune(v))</span>
                default:<span class="cov0" title="0">
                        return len(x)</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package functions

import "sync"

var (
        funcProxy       *FuncProxy
        once            sync.Once
        externalMethods = make(map[string]SqlClosureFunc, 10)
)

type SqlFunc func(...interface{}) interface{}
type SqlClosureFunc func() SqlFunc
type GroupRecord []interface{}

type FuncProxy struct {
        AggregateFuncNameSet map[string]bool
        SqlFunc              map[string]SqlClosureFunc
}

func NewFuncProxy() *FuncProxy <span class="cov8" title="1">{
        once.Do(func() </span><span class="cov8" title="1">{
                funcProxy = &amp;FuncProxy{
                        AggregateFuncNameSet: map[string]bool{
                                Keys.Sum:   true,
                                Keys.Count: true,
                        },
                        SqlFunc: map[string]SqlClosureFunc{
                                Keys.First:             first,
                                Keys.Not:               not,
                                Keys.SignalNot:         signalNot,
                                Keys.SignalExclamation: signalExclamation,
                                Keys.SignalAdd:         signalAdd,
                                Keys.SignalSub:         signalSub,
                                Keys.DoubleSub:         doubleSub,
                                Keys.Add:               add,
                                Keys.Sub:               sub,
                                Keys.Mul:               mul,
                                Keys.Div:               div,
                                Keys.Res:               res,
                                Keys.Exist:             exist,
                                Keys.Is:                is,
                                Keys.IsNot:             isNot,
                                Keys.In:                in,
                                Keys.NotIn:             notIn,
                                Keys.Or:                or,
                                Keys.And:               and,
                                Keys.Equal:             equal,
                                Keys.GreaterEqual:      greaterEqual,
                                Keys.LessEqual:         lessEqual,
                                Keys.Greater:           greater,
                                Keys.Less:              less,
                                Keys.NotEqual1:         notEqual,
                                Keys.NotEqual2:         notEqual,
                                Keys.NotEqual3:         notEqual,
                                Keys.AllEqual:          allEqual,
                                Keys.AllGreaterEqual:   allGreaterEqual,
                                Keys.AllLessEqual:      allLessEqual,
                                Keys.AllGreater:        allGreater,
                                Keys.AllLess:           allLess,
                                Keys.AllNotEqual1:      allNotEqual,
                                Keys.AllNotEqual2:      allNotEqual,
                                Keys.AllNotEqual3:      allNotEqual,
                                Keys.AnyEqual:          anyEqual,
                                Keys.AnyGreaterEqual:   anyGreaterEqual,
                                Keys.AnyLessEqual:      anyLessEqual,
                                Keys.AnyGreater:        anyGreater,
                                Keys.AnyLess:           anyLess,
                                Keys.AnyNotEqual1:      anyNotEqual,
                                Keys.AnyNotEqual2:      anyNotEqual,
                                Keys.AnyNotEqual3:      anyNotEqual,
                                Keys.SomeEqual:         anyEqual,
                                Keys.SomeGreaterEqual:  anyGreaterEqual,
                                Keys.SomeLessEqual:     anyLessEqual,
                                Keys.SomeGreater:       anyGreater,
                                Keys.SomeLess:          anyLess,
                                Keys.SomeNotEqual1:     anyNotEqual,
                                Keys.SomeNotEqual2:     anyNotEqual,
                                Keys.SomeNotEqual3:     anyNotEqual,
                                Keys.Int:               intFunc,
                                Keys.Int8:              int8Func,
                                Keys.Int16:             int16Func,
                                Keys.Int32:             int32Func,
                                Keys.Int64:             int64Func,
                                Keys.Float32:           float32Func,
                                Keys.Float64:           float64Func,
                                Keys.NotBetween:        notBetween,
                                Keys.Between:           between,
                                Keys.NotRegexp:         notRegexp,
                                Keys.Regexp:            regexpFunc,
                                Keys.Like:              like,
                                Keys.NotLike:           notLike,
                                Keys.Sum:               sum,
                                Keys.Count:             count,
                                Keys.Gcount:            gcount,
                                Keys.Gsum:              gsum,
                                Keys.Len:               lenFunc,
                                Keys.Deflate:           deflateFunc,
                                Keys.DateToStr:         dateToStr,
                                Keys.TimeToStr:         timeToStr,
                                Keys.String:            stringFunc,
                        },
                }
                for key, externalMethod := range externalMethods </span><span class="cov0" title="0">{
                        funcProxy.SqlFunc[key] = externalMethod
                }</span>
        })
        <span class="cov8" title="1">return funcProxy</span>
}

func AddFunc(key string, f SqlClosureFunc) <span class="cov0" title="0">{
        externalMethods[key] = f
}</span>

func (self *FuncProxy) Get(name string) SqlFunc <span class="cov8" title="1">{
        return self.SqlFunc[name]()
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package functions

import (
        "regexp"
        "strings"
)

func notRegexp() SqlFunc <span class="cov0" title="0">{
        return func(x ...interface{}) interface{} </span><span class="cov0" title="0">{
                ok, _ := regexp.MatchString(x[0].(string), x[1].(string))
                return ok == false
        }</span>
}

func regexpFunc() SqlFunc <span class="cov0" title="0">{
        return func(x ...interface{}) interface{} </span><span class="cov0" title="0">{
                ok, _ := regexp.MatchString(x[0].(string), x[1].(string))
                return ok != false
        }</span>
}

func like() SqlFunc <span class="cov0" title="0">{
        return func(x ...interface{}) interface{} </span><span class="cov0" title="0">{
                replace := strings.Replace
                ok, _ := regexp.MatchString(
                        replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(
                                x[1].(string), "\\", "\\\\", -1),
                                ".", "\\.", -1),
                                "^", "\\^", -1),
                                "$", "\\$", -1),
                                "*", "\\*", -1),
                                "+", "\\+", -1),
                                "?", "\\?", -1),
                                "{", "\\{", -1),
                                "}", "\\}", -1),
                                "|", "\\|", -1),
                                "(", "\\(", -1),
                                ")", "\\)", -1),
                                "%", ".*", -1), x[0].(string))
                return ok != false
        }</span>
}

func notLike() SqlFunc <span class="cov0" title="0">{
        return func(x ...interface{}) interface{} </span><span class="cov0" title="0">{
                replace := strings.Replace
                ok, _ := regexp.MatchString(
                        replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(
                                x[1].(string), "\\", "\\\\", -1),
                                ".", "\\.", -1),
                                "^", "\\^", -1),
                                "$", "\\$", -1),
                                "*", "\\*", -1),
                                "+", "\\+", -1),
                                "?", "\\?", -1),
                                "{", "\\{", -1),
                                "}", "\\}", -1),
                                "|", "\\|", -1),
                                "(", "\\(", -1),
                                ")", "\\)", -1),
                                "%", ".*", -1), x[0].(string))
                return ok == false
        }</span>
}

func first() SqlFunc <span class="cov0" title="0">{
        return func(x ...interface{}) interface{} </span><span class="cov0" title="0">{
                return string([]rune(x[0].(string))[0])
        }</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package functions

import (
        "fmt"
)

func intFunc() SqlFunc <span class="cov8" title="1">{
        return func(x ...interface{}) interface{} </span><span class="cov8" title="1">{
                return ToInt(x[0])
        }</span>
}

func int8Func() SqlFunc <span class="cov0" title="0">{
        return func(x ...interface{}) interface{} </span><span class="cov0" title="0">{
                return toInt8(x[0])
        }</span>
}

func int16Func() SqlFunc <span class="cov0" title="0">{
        return func(x ...interface{}) interface{} </span><span class="cov0" title="0">{
                return toInt16(x[0])
        }</span>
}

func int32Func() SqlFunc <span class="cov0" title="0">{
        return func(x ...interface{}) interface{} </span><span class="cov0" title="0">{
                return toInt32(x[0])
        }</span>
}

func int64Func() SqlFunc <span class="cov0" title="0">{
        return func(x ...interface{}) interface{} </span><span class="cov0" title="0">{
                return toInt64(x[0])
        }</span>
}

func float32Func() SqlFunc <span class="cov0" title="0">{
        return func(x ...interface{}) interface{} </span><span class="cov0" title="0">{
                return toFloat32(x[0])
        }</span>
}

func float64Func() SqlFunc <span class="cov0" title="0">{
        return func(x ...interface{}) interface{} </span><span class="cov0" title="0">{
                return toFloat64(x[0])
        }</span>
}

func stringFunc() SqlFunc <span class="cov0" title="0">{
        return func(x ...interface{}) interface{} </span><span class="cov0" title="0">{
                return fmt.Sprintf("%v", x[0])
        }</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Code generated from /Users/zhangzhiqiang/go/src/github.com/Aiyane/golinq/sql-parser/MySqlLexer.g4 by ANTLR 4.7.2. DO NOT EDIT.

package parser

import (
        "fmt"
        "unicode"

        "github.com/antlr/antlr4/runtime/Go/antlr"
)
// Suppress unused import error
var _ = fmt.Printf
var _ = unicode.IsLetter


var serializedLexerAtn = []uint16{
        3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 2, 86, 784, 
        8, 1, 4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 
        9, 7, 4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 
        4, 13, 9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 
        18, 9, 18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 
        9, 23, 4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 
        28, 4, 29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 
        4, 34, 9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 
        39, 9, 39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 
        9, 44, 4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 
        49, 4, 50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 
        4, 55, 9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 
        60, 9, 60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 
        9, 65, 4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 
        70, 4, 71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 
        4, 76, 9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 
        81, 9, 81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 
        9, 86, 4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 
        91, 4, 92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 
        4, 97, 9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 
        4, 102, 9, 102, 4, 103, 9, 103, 4, 104, 9, 104, 4, 105, 9, 105, 4, 106, 
        9, 106, 4, 107, 9, 107, 4, 108, 9, 108, 4, 109, 9, 109, 4, 110, 9, 110, 
        4, 111, 9, 111, 4, 112, 9, 112, 4, 113, 9, 113, 4, 114, 9, 114, 4, 115, 
        9, 115, 4, 116, 9, 116, 3, 2, 6, 2, 235, 10, 2, 13, 2, 14, 2, 236, 3, 2, 
        3, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6, 3, 246, 10, 3, 13, 3, 14, 3, 247, 
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 4, 3, 4, 3, 4, 7, 4, 259, 10, 4, 
        12, 4, 14, 4, 262, 11, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 5, 3, 5, 3, 
        5, 3, 5, 5, 5, 273, 10, 5, 3, 5, 7, 5, 276, 10, 5, 12, 5, 14, 5, 279, 11, 
        5, 3, 5, 5, 5, 282, 10, 5, 3, 5, 3, 5, 5, 5, 286, 10, 5, 3, 5, 3, 5, 3, 
        5, 3, 5, 5, 5, 292, 10, 5, 3, 5, 3, 5, 5, 5, 296, 10, 5, 5, 5, 298, 10, 
        5, 3, 5, 3, 5, 3, 6, 3, 6, 3, 6, 3, 6, 3, 7, 3, 7, 3, 7, 3, 7, 3, 8, 3, 
        8, 3, 8, 3, 9, 3, 9, 3, 9, 3, 9, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 
        10, 3, 10, 3, 10, 3, 11, 3, 11, 3, 11, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 
        3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 14, 3, 14, 3, 14, 3, 14, 3, 
        14, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 3, 16, 
        3, 16, 3, 16, 3, 16, 3, 16, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 
        17, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 19, 3, 19, 3, 19, 3, 19, 
        3, 19, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 21, 3, 21, 3, 21, 3, 
        21, 3, 21, 3, 21, 3, 21, 3, 22, 3, 22, 3, 22, 3, 23, 3, 23, 3, 23, 3, 23, 
        3, 23, 3, 23, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 25, 3, 25, 3, 25, 3, 
        26, 3, 26, 3, 26, 3, 26, 3, 26, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 28, 
        3, 28, 3, 28, 3, 28, 3, 28, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 
        30, 3, 30, 3, 30, 3, 30, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 32, 3, 32, 
        3, 32, 3, 33, 3, 33, 3, 33, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 
        35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 36, 3, 36, 3, 36, 3, 36, 3, 36, 
        3, 36, 3, 36, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 38, 3, 38, 3, 
        38, 3, 38, 3, 38, 3, 38, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 
        3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 
        42, 3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 
        3, 43, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 45, 3, 45, 3, 
        45, 3, 45, 3, 45, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 47, 3, 47, 
        3, 47, 3, 47, 3, 47, 3, 47, 3, 47, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 
        48, 3, 48, 3, 49, 3, 49, 3, 49, 3, 49, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 
        3, 50, 3, 50, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 52, 3, 52, 3, 
        52, 3, 52, 3, 52, 3, 52, 3, 52, 3, 52, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 
        3, 53, 3, 53, 3, 54, 3, 54, 3, 54, 3, 54, 3, 55, 3, 55, 3, 55, 3, 55, 3, 
        56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 57, 3, 57, 3, 57, 3, 57, 
        3, 57, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 3, 59, 3, 
        59, 3, 60, 3, 60, 3, 61, 3, 61, 3, 62, 3, 62, 3, 63, 3, 63, 3, 63, 3, 64, 
        3, 64, 3, 65, 3, 65, 3, 65, 3, 65, 3, 66, 3, 66, 3, 66, 3, 66, 3, 67, 3, 
        67, 3, 68, 3, 68, 3, 69, 3, 69, 3, 70, 3, 70, 3, 71, 3, 71, 3, 72, 3, 72, 
        3, 73, 3, 73, 3, 74, 3, 74, 3, 75, 3, 75, 3, 76, 3, 76, 3, 77, 3, 77, 3, 
        78, 3, 78, 3, 79, 3, 79, 5, 79, 641, 10, 79, 3, 80, 6, 80, 644, 10, 80, 
        13, 80, 14, 80, 645, 3, 81, 6, 81, 649, 10, 81, 13, 81, 14, 81, 650, 5, 
        81, 653, 10, 81, 3, 81, 3, 81, 6, 81, 657, 10, 81, 13, 81, 14, 81, 658, 
        3, 82, 3, 82, 3, 82, 3, 83, 3, 83, 3, 83, 3, 84, 3, 84, 5, 84, 669, 10, 
        84, 3, 85, 7, 85, 672, 10, 85, 12, 85, 14, 85, 675, 11, 85, 3, 85, 6, 85, 
        678, 10, 85, 13, 85, 14, 85, 679, 3, 85, 7, 85, 683, 10, 85, 12, 85, 14, 
        85, 686, 11, 85, 3, 86, 3, 86, 3, 86, 3, 86, 3, 86, 3, 86, 7, 86, 694, 
        10, 86, 12, 86, 14, 86, 697, 11, 86, 3, 86, 3, 86, 3, 87, 3, 87, 3, 87, 
        3, 87, 3, 87, 3, 87, 7, 87, 707, 10, 87, 12, 87, 14, 87, 710, 11, 87, 3, 
        87, 3, 87, 3, 88, 3, 88, 3, 88, 3, 88, 3, 88, 3, 88, 7, 88, 720, 10, 88, 
        12, 88, 14, 88, 723, 11, 88, 3, 88, 3, 88, 3, 89, 3, 89, 3, 90, 3, 90, 
        3, 91, 3, 91, 3, 92, 3, 92, 3, 93, 3, 93, 3, 94, 3, 94, 3, 95, 3, 95, 3, 
        96, 3, 96, 3, 97, 3, 97, 3, 98, 3, 98, 3, 99, 3, 99, 3, 100, 3, 100, 3, 
        101, 3, 101, 3, 102, 3, 102, 3, 103, 3, 103, 3, 104, 3, 104, 3, 105, 3, 
        105, 3, 106, 3, 106, 3, 107, 3, 107, 3, 108, 3, 108, 3, 109, 3, 109, 3, 
        110, 3, 110, 3, 111, 3, 111, 3, 112, 3, 112, 3, 113, 3, 113, 3, 114, 3, 
        114, 3, 115, 3, 115, 3, 116, 3, 116, 3, 116, 3, 116, 6, 247, 260, 673, 
        679, 2, 117, 3, 3, 5, 4, 7, 5, 9, 6, 11, 7, 13, 8, 15, 9, 17, 10, 19, 11, 
        21, 12, 23, 13, 25, 14, 27, 15, 29, 16, 31, 17, 33, 18, 35, 19, 37, 20, 
        39, 21, 41, 22, 43, 23, 45, 24, 47, 25, 49, 26, 51, 27, 53, 28, 55, 29, 
        57, 30, 59, 31, 61, 32, 63, 33, 65, 34, 67, 35, 69, 36, 71, 37, 73, 38, 
        75, 39, 77, 40, 79, 41, 81, 42, 83, 43, 85, 44, 87, 45, 89, 46, 91, 47, 
        93, 48, 95, 49, 97, 50, 99, 51, 101, 52, 103, 53, 105, 54, 107, 55, 109, 
        56, 111, 57, 113, 58, 115, 59, 117, 60, 119, 61, 121, 62, 123, 63, 125, 
        64, 127, 65, 129, 66, 131, 67, 133, 68, 135, 69, 137, 70, 139, 71, 141, 
        72, 143, 73, 145, 74, 147, 75, 149, 76, 151, 77, 153, 78, 155, 79, 157, 
        80, 159, 81, 161, 82, 163, 83, 165, 84, 167, 85, 169, 2, 171, 2, 173, 2, 
        175, 2, 177, 2, 179, 2, 181, 2, 183, 2, 185, 2, 187, 2, 189, 2, 191, 2, 
        193, 2, 195, 2, 197, 2, 199, 2, 201, 2, 203, 2, 205, 2, 207, 2, 209, 2, 
        211, 2, 213, 2, 215, 2, 217, 2, 219, 2, 221, 2, 223, 2, 225, 2, 227, 2, 
        229, 2, 231, 86, 3, 2, 36, 5, 2, 11, 12, 15, 15, 34, 34, 4, 2, 12, 12, 
        15, 15, 7, 2, 38, 38, 50, 59, 67, 92, 97, 97, 99, 124, 6, 2, 38, 38, 67, 
        92, 97, 97, 99, 124, 4, 2, 36, 36, 94, 94, 4, 2, 41, 41, 94, 94, 4, 2, 
        94, 94, 98, 98, 3, 2, 50, 59, 4, 2, 67, 67, 99, 99, 4, 2, 68, 68, 100, 
        100, 4, 2, 69, 69, 101, 101, 4, 2, 70, 70, 102, 102, 4, 2, 71, 71, 103, 
        103, 4, 2, 72, 72, 104, 104, 4, 2, 73, 73, 105, 105, 4, 2, 74, 74, 106, 
        106, 4, 2, 75, 75, 107, 107, 4, 2, 76, 76, 108, 108, 4, 2, 77, 77, 109, 
        109, 4, 2, 78, 78, 110, 110, 4, 2, 79, 79, 111, 111, 4, 2, 80, 80, 112, 
        112, 4, 2, 81, 81, 113, 113, 4, 2, 82, 82, 114, 114, 4, 2, 83, 83, 115, 
        115, 4, 2, 84, 84, 116, 116, 4, 2, 85, 85, 117, 117, 4, 2, 86, 86, 118, 
        118, 4, 2, 87, 87, 119, 119, 4, 2, 88, 88, 120, 120, 4, 2, 89, 89, 121, 
        121, 4, 2, 90, 90, 122, 122, 4, 2, 91, 91, 123, 123, 4, 2, 92, 92, 124, 
        124, 2, 780, 2, 3, 3, 2, 2, 2, 2, 5, 3, 2, 2, 2, 2, 7, 3, 2, 2, 2, 2, 9, 
        3, 2, 2, 2, 2, 11, 3, 2, 2, 2, 2, 13, 3, 2, 2, 2, 2, 15, 3, 2, 2, 2, 2, 
        17, 3, 2, 2, 2, 2, 19, 3, 2, 2, 2, 2, 21, 3, 2, 2, 2, 2, 23, 3, 2, 2, 2, 
        2, 25, 3, 2, 2, 2, 2, 27, 3, 2, 2, 2, 2, 29, 3, 2, 2, 2, 2, 31, 3, 2, 2, 
        2, 2, 33, 3, 2, 2, 2, 2, 35, 3, 2, 2, 2, 2, 37, 3, 2, 2, 2, 2, 39, 3, 2, 
        2, 2, 2, 41, 3, 2, 2, 2, 2, 43, 3, 2, 2, 2, 2, 45, 3, 2, 2, 2, 2, 47, 3, 
        2, 2, 2, 2, 49, 3, 2, 2, 2, 2, 51, 3, 2, 2, 2, 2, 53, 3, 2, 2, 2, 2, 55, 
        3, 2, 2, 2, 2, 57, 3, 2, 2, 2, 2, 59, 3, 2, 2, 2, 2, 61, 3, 2, 2, 2, 2, 
        63, 3, 2, 2, 2, 2, 65, 3, 2, 2, 2, 2, 67, 3, 2, 2, 2, 2, 69, 3, 2, 2, 2, 
        2, 71, 3, 2, 2, 2, 2, 73, 3, 2, 2, 2, 2, 75, 3, 2, 2, 2, 2, 77, 3, 2, 2, 
        2, 2, 79, 3, 2, 2, 2, 2, 81, 3, 2, 2, 2, 2, 83, 3, 2, 2, 2, 2, 85, 3, 2, 
        2, 2, 2, 87, 3, 2, 2, 2, 2, 89, 3, 2, 2, 2, 2, 91, 3, 2, 2, 2, 2, 93, 3, 
        2, 2, 2, 2, 95, 3, 2, 2, 2, 2, 97, 3, 2, 2, 2, 2, 99, 3, 2, 2, 2, 2, 101, 
        3, 2, 2, 2, 2, 103, 3, 2, 2, 2, 2, 105, 3, 2, 2, 2, 2, 107, 3, 2, 2, 2, 
        2, 109, 3, 2, 2, 2, 2, 111, 3, 2, 2, 2, 2, 113, 3, 2, 2, 2, 2, 115, 3, 
        2, 2, 2, 2, 117, 3, 2, 2, 2, 2, 119, 3, 2, 2, 2, 2, 121, 3, 2, 2, 2, 2, 
        123, 3, 2, 2, 2, 2, 125, 3, 2, 2, 2, 2, 127, 3, 2, 2, 2, 2, 129, 3, 2, 
        2, 2, 2, 131, 3, 2, 2, 2, 2, 133, 3, 2, 2, 2, 2, 135, 3, 2, 2, 2, 2, 137, 
        3, 2, 2, 2, 2, 139, 3, 2, 2, 2, 2, 141, 3, 2, 2, 2, 2, 143, 3, 2, 2, 2, 
        2, 145, 3, 2, 2, 2, 2, 147, 3, 2, 2, 2, 2, 149, 3, 2, 2, 2, 2, 151, 3, 
        2, 2, 2, 2, 153, 3, 2, 2, 2, 2, 155, 3, 2, 2, 2, 2, 157, 3, 2, 2, 2, 2, 
        159, 3, 2, 2, 2, 2, 161, 3, 2, 2, 2, 2, 163, 3, 2, 2, 2, 2, 165, 3, 2, 
        2, 2, 2, 167, 3, 2, 2, 2, 2, 231, 3, 2, 2, 2, 3, 234, 3, 2, 2, 2, 5, 240, 
        3, 2, 2, 2, 7, 254, 3, 2, 2, 2, 9, 297, 3, 2, 2, 2, 11, 301, 3, 2, 2, 2, 
        13, 305, 3, 2, 2, 2, 15, 309, 3, 2, 2, 2, 17, 312, 3, 2, 2, 2, 19, 316, 
        3, 2, 2, 2, 21, 324, 3, 2, 2, 2, 23, 327, 3, 2, 2, 2, 25, 332, 3, 2, 2, 
        2, 27, 338, 3, 2, 2, 2, 29, 343, 3, 2, 2, 2, 31, 352, 3, 2, 2, 2, 33, 357, 
        3, 2, 2, 2, 35, 364, 3, 2, 2, 2, 37, 370, 3, 2, 2, 2, 39, 375, 3, 2, 2, 
        2, 41, 381, 3, 2, 2, 2, 43, 388, 3, 2, 2, 2, 45, 391, 3, 2, 2, 2, 47, 397, 
        3, 2, 2, 2, 49, 402, 3, 2, 2, 2, 51, 405, 3, 2, 2, 2, 53, 410, 3, 2, 2, 
        2, 55, 415, 3, 2, 2, 2, 57, 420, 3, 2, 2, 2, 59, 426, 3, 2, 2, 2, 61, 430, 
        3, 2, 2, 2, 63, 435, 3, 2, 2, 2, 65, 438, 3, 2, 2, 2, 67, 441, 3, 2, 2, 
        2, 69, 447, 3, 2, 2, 2, 71, 453, 3, 2, 2, 2, 73, 460, 3, 2, 2, 2, 75, 466, 
        3, 2, 2, 2, 77, 472, 3, 2, 2, 2, 79, 479, 3, 2, 2, 2, 81, 484, 3, 2, 2, 
        2, 83, 489, 3, 2, 2, 2, 85, 495, 3, 2, 2, 2, 87, 501, 3, 2, 2, 2, 89, 508, 
        3, 2, 2, 2, 91, 513, 3, 2, 2, 2, 93, 519, 3, 2, 2, 2, 95, 526, 3, 2, 2, 
        2, 97, 533, 3, 2, 2, 2, 99, 537, 3, 2, 2, 2, 101, 544, 3, 2, 2, 2, 103, 
        550, 3, 2, 2, 2, 105, 558, 3, 2, 2, 2, 107, 565, 3, 2, 2, 2, 109, 569, 
        3, 2, 2, 2, 111, 573, 3, 2, 2, 2, 113, 580, 3, 2, 2, 2, 115, 585, 3, 2, 
        2, 2, 117, 593, 3, 2, 2, 2, 119, 595, 3, 2, 2, 2, 121, 597, 3, 2, 2, 2, 
        123, 599, 3, 2, 2, 2, 125, 601, 3, 2, 2, 2, 127, 604, 3, 2, 2, 2, 129, 
        606, 3, 2, 2, 2, 131, 610, 3, 2, 2, 2, 133, 614, 3, 2, 2, 2, 135, 616, 
        3, 2, 2, 2, 137, 618, 3, 2, 2, 2, 139, 620, 3, 2, 2, 2, 141, 622, 3, 2, 
        2, 2, 143, 624, 3, 2, 2, 2, 145, 626, 3, 2, 2, 2, 147, 628, 3, 2, 2, 2, 
        149, 630, 3, 2, 2, 2, 151, 632, 3, 2, 2, 2, 153, 634, 3, 2, 2, 2, 155, 
        636, 3, 2, 2, 2, 157, 640, 3, 2, 2, 2, 159, 643, 3, 2, 2, 2, 161, 652, 
        3, 2, 2, 2, 163, 660, 3, 2, 2, 2, 165, 663, 3, 2, 2, 2, 167, 668, 3, 2, 
        2, 2, 169, 673, 3, 2, 2, 2, 171, 687, 3, 2, 2, 2, 173, 700, 3, 2, 2, 2, 
        175, 713, 3, 2, 2, 2, 177, 726, 3, 2, 2, 2, 179, 728, 3, 2, 2, 2, 181, 
        730, 3, 2, 2, 2, 183, 732, 3, 2, 2, 2, 185, 734, 3, 2, 2, 2, 187, 736, 
        3, 2, 2, 2, 189, 738, 3, 2, 2, 2, 191, 740, 3, 2, 2, 2, 193, 742, 3, 2, 
        2, 2, 195, 744, 3, 2, 2, 2, 197, 746, 3, 2, 2, 2, 199, 748, 3, 2, 2, 2, 
        201, 750, 3, 2, 2, 2, 203, 752, 3, 2, 2, 2, 205, 754, 3, 2, 2, 2, 207, 
        756, 3, 2, 2, 2, 209, 758, 3, 2, 2, 2, 211, 760, 3, 2, 2, 2, 213, 762, 
        3, 2, 2, 2, 215, 764, 3, 2, 2, 2, 217, 766, 3, 2, 2, 2, 219, 768, 3, 2, 
        2, 2, 221, 770, 3, 2, 2, 2, 223, 772, 3, 2, 2, 2, 225, 774, 3, 2, 2, 2, 
        227, 776, 3, 2, 2, 2, 229, 778, 3, 2, 2, 2, 231, 780, 3, 2, 2, 2, 233, 
        235, 9, 2, 2, 2, 234, 233, 3, 2, 2, 2, 235, 236, 3, 2, 2, 2, 236, 234, 
        3, 2, 2, 2, 236, 237, 3, 2, 2, 2, 237, 238, 3, 2, 2, 2, 238, 239, 8, 2, 
        2, 2, 239, 4, 3, 2, 2, 2, 240, 241, 7, 49, 2, 2, 241, 242, 7, 44, 2, 2, 
        242, 243, 7, 35, 2, 2, 243, 245, 3, 2, 2, 2, 244, 246, 11, 2, 2, 2, 245, 
        244, 3, 2, 2, 2, 246, 247, 3, 2, 2, 2, 247, 248, 3, 2, 2, 2, 247, 245, 
        3, 2, 2, 2, 248, 249, 3, 2, 2, 2, 249, 250, 7, 44, 2, 2, 250, 251, 7, 49, 
        2, 2, 251, 252, 3, 2, 2, 2, 252, 253, 8, 3, 3, 2, 253, 6, 3, 2, 2, 2, 254, 
        255, 7, 49, 2, 2, 255, 256, 7, 44, 2, 2, 256, 260, 3, 2, 2, 2, 257, 259, 
        11, 2, 2, 2, 258, 257, 3, 2, 2, 2, 259, 262, 3, 2, 2, 2, 260, 261, 3, 2, 
        2, 2, 260, 258, 3, 2, 2, 2, 261, 263, 3, 2, 2, 2, 262, 260, 3, 2, 2, 2, 
        263, 264, 7, 44, 2, 2, 264, 265, 7, 49, 2, 2, 265, 266, 3, 2, 2, 2, 266, 
        267, 8, 4, 2, 2, 267, 8, 3, 2, 2, 2, 268, 269, 7, 47, 2, 2, 269, 270, 7, 
        47, 2, 2, 270, 273, 7, 34, 2, 2, 271, 273, 7, 37, 2, 2, 272, 268, 3, 2, 
        2, 2, 272, 271, 3, 2, 2, 2, 273, 277, 3, 2, 2, 2, 274, 276, 10, 3, 2, 2, 
        275, 274, 3, 2, 2, 2, 276, 279, 3, 2, 2, 2, 277, 275, 3, 2, 2, 2, 277, 
        278, 3, 2, 2, 2, 278, 285, 3, 2, 2, 2, 279, 277, 3, 2, 2, 2, 280, 282, 
        7, 15, 2, 2, 281, 280, 3, 2, 2, 2, 281, 282, 3, 2, 2, 2, 282, 283, 3, 2, 
        2, 2, 283, 286, 7, 12, 2, 2, 284, 286, 7, 2, 2, 3, 285, 281, 3, 2, 2, 2, 
        285, 284, 3, 2, 2, 2, 286, 298, 3, 2, 2, 2, 287, 288, 7, 47, 2, 2, 288, 
        289, 7, 47, 2, 2, 289, 295, 3, 2, 2, 2, 290, 292, 7, 15, 2, 2, 291, 290, 
        3, 2, 2, 2, 291, 292, 3, 2, 2, 2, 292, 293, 3, 2, 2, 2, 293, 296, 7, 12, 
        2, 2, 294, 296, 7, 2, 2, 3, 295, 291, 3, 2, 2, 2, 295, 294, 3, 2, 2, 2, 
        296, 298, 3, 2, 2, 2, 297, 272, 3, 2, 2, 2, 297, 287, 3, 2, 2, 2, 298, 
        299, 3, 2, 2, 2, 299, 300, 8, 5, 2, 2, 300, 10, 3, 2, 2, 2, 301, 302, 5, 
        179, 90, 2, 302, 303, 5, 201, 101, 2, 303, 304, 5, 201, 101, 2, 304, 12, 
        3, 2, 2, 2, 305, 306, 5, 179, 90, 2, 306, 307, 5, 205, 103, 2, 307, 308, 
        5, 185, 93, 2, 308, 14, 3, 2, 2, 2, 309, 310, 5, 179, 90, 2, 310, 311, 
        5, 215, 108, 2, 311, 16, 3, 2, 2, 2, 312, 313, 5, 179, 90, 2, 313, 314, 
        5, 215, 108, 2, 314, 315, 5, 183, 92, 2, 315, 18, 3, 2, 2, 2, 316, 317, 
        5, 181, 91, 2, 317, 318, 5, 187, 94, 2, 318, 319, 5, 217, 109, 2, 319, 
        320, 5, 223, 112, 2, 320, 321, 5, 187, 94, 2, 321, 322, 5, 187, 94, 2, 
        322, 323, 5, 205, 103, 2, 323, 20, 3, 2, 2, 2, 324, 325, 5, 181, 91, 2, 
        325, 326, 5, 227, 114, 2, 326, 22, 3, 2, 2, 2, 327, 328, 5, 183, 92, 2, 
        328, 329, 5, 179, 90, 2, 329, 330, 5, 215, 108, 2, 330, 331, 5, 187, 94, 
        2, 331, 24, 3, 2, 2, 2, 332, 333, 5, 183, 92, 2, 333, 334, 5, 213, 107, 
        2, 334, 335, 5, 207, 104, 2, 335, 336, 5, 215, 108, 2, 336, 337, 5, 215, 
        108, 2, 337, 26, 3, 2, 2, 2, 338, 339, 5, 185, 93, 2, 339, 340, 5, 187, 
        94, 2, 340, 341, 5, 215, 108, 2, 341, 342, 5, 183, 92, 2, 342, 28, 3, 2, 
        2, 2, 343, 344, 5, 185, 93, 2, 344, 345, 5, 195, 98, 2, 345, 346, 5, 215, 
        108, 2, 346, 347, 5, 217, 109, 2, 347, 348, 5, 195, 98, 2, 348, 349, 5, 
        205, 103, 2, 349, 350, 5, 183, 92, 2, 350, 351, 5, 217, 109, 2, 351, 30, 
        3, 2, 2, 2, 352, 353, 5, 187, 94, 2, 353, 354, 5, 201, 101, 2, 354, 355, 
        5, 215, 108, 2, 355, 356, 5, 187, 94, 2, 356, 32, 3, 2, 2, 2, 357, 358, 
        5, 187, 94, 2, 358, 359, 5, 225, 113, 2, 359, 360, 5, 195, 98, 2, 360, 
        361, 5, 215, 108, 2, 361, 362, 5, 217, 109, 2, 362, 363, 5, 215, 108, 2, 
        363, 34, 3, 2, 2, 2, 364, 365, 5, 189, 95, 2, 365, 366, 5, 179, 90, 2, 
        366, 367, 5, 201, 101, 2, 367, 368, 5, 215, 108, 2, 368, 369, 5, 187, 94, 
        2, 369, 36, 3, 2, 2, 2, 370, 371, 5, 189, 95, 2, 371, 372, 5, 213, 107, 
        2, 372, 373, 5, 207, 104, 2, 373, 374, 5, 203, 102, 2, 374, 38, 3, 2, 2, 
        2, 375, 376, 5, 191, 96, 2, 376, 377, 5, 213, 107, 2, 377, 378, 5, 207, 
        104, 2, 378, 379, 5, 219, 110, 2, 379, 380, 5, 209, 105, 2, 380, 40, 3, 
        2, 2, 2, 381, 382, 5, 193, 97, 2, 382, 383, 5, 179, 90, 2, 383, 384, 5, 
        221, 111, 2, 384, 385, 5, 195, 98, 2, 385, 386, 5, 205, 103, 2, 386, 387, 
        5, 191, 96, 2, 387, 42, 3, 2, 2, 2, 388, 389, 5, 195, 98, 2, 389, 390, 
        5, 205, 103, 2, 390, 44, 3, 2, 2, 2, 391, 392, 5, 195, 98, 2, 392, 393, 
        5, 205, 103, 2, 393, 394, 5, 205, 103, 2, 394, 395, 5, 187, 94, 2, 395, 
        396, 5, 213, 107, 2, 396, 46, 3, 2, 2, 2, 397, 398, 5, 195, 98, 2, 398, 
        399, 5, 205, 103, 2, 399, 400, 5, 217, 109, 2, 400, 401, 5, 207, 104, 2, 
        401, 48, 3, 2, 2, 2, 402, 403, 5, 195, 98, 2, 403, 404, 5, 215, 108, 2, 
        404, 50, 3, 2, 2, 2, 405, 406, 5, 197, 99, 2, 406, 407, 5, 207, 104, 2, 
        407, 408, 5, 195, 98, 2, 408, 409, 5, 205, 103, 2, 409, 52, 3, 2, 2, 2, 
        410, 411, 5, 201, 101, 2, 411, 412, 5, 187, 94, 2, 412, 413, 5, 189, 95, 
        2, 413, 414, 5, 217, 109, 2, 414, 54, 3, 2, 2, 2, 415, 416, 5, 201, 101, 
        2, 416, 417, 5, 195, 98, 2, 417, 418, 5, 199, 100, 2, 418, 419, 5, 187, 
        94, 2, 419, 56, 3, 2, 2, 2, 420, 421, 5, 201, 101, 2, 421, 422, 5, 195, 
        98, 2, 422, 423, 5, 203, 102, 2, 423, 424, 5, 195, 98, 2, 424, 425, 5, 
        217, 109, 2, 425, 58, 3, 2, 2, 2, 426, 427, 5, 205, 103, 2, 427, 428, 5, 
        207, 104, 2, 428, 429, 5, 217, 109, 2, 429, 60, 3, 2, 2, 2, 430, 431, 5, 
        205, 103, 2, 431, 432, 5, 219, 110, 2, 432, 433, 5, 201, 101, 2, 433, 434, 
        5, 201, 101, 2, 434, 62, 3, 2, 2, 2, 435, 436, 5, 207, 104, 2, 436, 437, 
        5, 205, 103, 2, 437, 64, 3, 2, 2, 2, 438, 439, 5, 207, 104, 2, 439, 440, 
        5, 213, 107, 2, 440, 66, 3, 2, 2, 2, 441, 442, 5, 207, 104, 2, 442, 443, 
        5, 213, 107, 2, 443, 444, 5, 185, 93, 2, 444, 445, 5, 187, 94, 2, 445, 
        446, 5, 213, 107, 2, 446, 68, 3, 2, 2, 2, 447, 448, 5, 207, 104, 2, 448, 
        449, 5, 219, 110, 2, 449, 450, 5, 217, 109, 2, 450, 451, 5, 187, 94, 2, 
        451, 452, 5, 213, 107, 2, 452, 70, 3, 2, 2, 2, 453, 454, 5, 213, 107, 2, 
        454, 455, 5, 187, 94, 2, 455, 456, 5, 191, 96, 2, 456, 457, 5, 187, 94, 
        2, 457, 458, 5, 225, 113, 2, 458, 459, 5, 209, 105, 2, 459, 72, 3, 2, 2, 
        2, 460, 461, 5, 213, 107, 2, 461, 462, 5, 195, 98, 2, 462, 463, 5, 191, 
        96, 2, 463, 464, 5, 193, 97, 2, 464, 465, 5, 217, 109, 2, 465, 74, 3, 2, 
        2, 2, 466, 467, 5, 213, 107, 2, 467, 468, 5, 201, 101, 2, 468, 469, 5, 
        195, 98, 2, 469, 470, 5, 199, 100, 2, 470, 471, 5, 187, 94, 2, 471, 76, 
        3, 2, 2, 2, 472, 473, 5, 215, 108, 2, 473, 474, 5, 187, 94, 2, 474, 475, 
        5, 201, 101, 2, 475, 476, 5, 187, 94, 2, 476, 477, 5, 183, 92, 2, 477, 
        478, 5, 217, 109, 2, 478, 78, 3, 2, 2, 2, 479, 480, 5, 217, 109, 2, 480, 
        481, 5, 193, 97, 2, 481, 482, 5, 187, 94, 2, 482, 483, 5, 205, 103, 2, 
        483, 80, 3, 2, 2, 2, 484, 485, 5, 217, 109, 2, 485, 486, 5, 213, 107, 2, 
        486, 487, 5, 219, 110, 2, 487, 488, 5, 187, 94, 2, 488, 82, 3, 2, 2, 2, 
        489, 490, 5, 219, 110, 2, 490, 491, 5, 205, 103, 2, 491, 492, 5, 195, 98, 
        2, 492, 493, 5, 207, 104, 2, 493, 494, 5, 205, 103, 2, 494, 84, 3, 2, 2, 
        2, 495, 496, 5, 219, 110, 2, 496, 497, 5, 215, 108, 2, 497, 498, 5, 195, 
        98, 2, 498, 499, 5, 205, 103, 2, 499, 500, 5, 191, 96, 2, 500, 86, 3, 2, 
        2, 2, 501, 502, 5, 221, 111, 2, 502, 503, 5, 179, 90, 2, 503, 504, 5, 201, 
        101, 2, 504, 505, 5, 219, 110, 2, 505, 506, 5, 187, 94, 2, 506, 507, 5, 
        215, 108, 2, 507, 88, 3, 2, 2, 2, 508, 509, 5, 223, 112, 2, 509, 510, 5, 
        193, 97, 2, 510, 511, 5, 187, 94, 2, 511, 512, 5, 205, 103, 2, 512, 90, 
        3, 2, 2, 2, 513, 514, 5, 223, 112, 2, 514, 515, 5, 193, 97, 2, 515, 516, 
        5, 187, 94, 2, 516, 517, 5, 213, 107, 2, 517, 518, 5, 187, 94, 2, 518, 
        92, 3, 2, 2, 2, 519, 520, 5, 185, 93, 2, 520, 521, 5, 187, 94, 2, 521, 
        522, 5, 201, 101, 2, 522, 523, 5, 187, 94, 2, 523, 524, 5, 217, 109, 2, 
        524, 525, 5, 187, 94, 2, 525, 94, 3, 2, 2, 2, 526, 527, 5, 195, 98, 2, 
        527, 528, 5, 205, 103, 2, 528, 529, 5, 215, 108, 2, 529, 530, 5, 187, 94, 
        2, 530, 531, 5, 213, 107, 2, 531, 532, 5, 217, 109, 2, 532, 96, 3, 2, 2, 
        2, 533, 534, 5, 215, 108, 2, 534, 535, 5, 187, 94, 2, 535, 536, 5, 217, 
        109, 2, 536, 98, 3, 2, 2, 2, 537, 538, 5, 219, 110, 2, 538, 539, 5, 209, 
        105, 2, 539, 540, 5, 185, 93, 2, 540, 541, 5, 179, 90, 2, 541, 542, 5, 
        217, 109, 2, 542, 543, 5, 187, 94, 2, 543, 100, 3, 2, 2, 2, 544, 545, 5, 
        221, 111, 2, 545, 546, 5, 179, 90, 2, 546, 547, 5, 201, 101, 2, 547, 548, 
        5, 219, 110, 2, 548, 549, 5, 187, 94, 2, 549, 102, 3, 2, 2, 2, 550, 551, 
        5, 185, 93, 2, 551, 552, 5, 187, 94, 2, 552, 553, 5, 189, 95, 2, 553, 554, 
        5, 179, 90, 2, 554, 555, 5, 219, 110, 2, 555, 556, 5, 201, 101, 2, 556, 
        557, 5, 217, 109, 2, 557, 104, 3, 2, 2, 2, 558, 559, 5, 195, 98, 2, 559, 
        560, 5, 191, 96, 2, 560, 561, 5, 205, 103, 2, 561, 562, 5, 207, 104, 2, 
        562, 563, 5, 213, 107, 2, 563, 564, 5, 187, 94, 2, 564, 106, 3, 2, 2, 2, 
        565, 566, 5, 179, 90, 2, 566, 567, 5, 205, 103, 2, 567, 568, 5, 227, 114, 
        2, 568, 108, 3, 2, 2, 2, 569, 570, 5, 187, 94, 2, 570, 571, 5, 205, 103, 
        2, 571, 572, 5, 185, 93, 2, 572, 110, 3, 2, 2, 2, 573, 574, 5, 207, 104, 
        2, 574, 575, 5, 189, 95, 2, 575, 576, 5, 189, 95, 2, 576, 577, 5, 215, 
        108, 2, 577, 578, 5, 187, 94, 2, 578, 579, 5, 217, 109, 2, 579, 112, 3, 
        2, 2, 2, 580, 581, 5, 215, 108, 2, 581, 582, 5, 207, 104, 2, 582, 583, 
        5, 203, 102, 2, 583, 584, 5, 187, 94, 2, 584, 114, 3, 2, 2, 2, 585, 586, 
        5, 219, 110, 2, 586, 587, 5, 205, 103, 2, 587, 588, 5, 199, 100, 2, 588, 
        589, 5, 205, 103, 2, 589, 590, 5, 207, 104, 2, 590, 591, 5, 223, 112, 2, 
        591, 592, 5, 205, 103, 2, 592, 116, 3, 2, 2, 2, 593, 594, 7, 44, 2, 2, 
        594, 118, 3, 2, 2, 2, 595, 596, 7, 49, 2, 2, 596, 120, 3, 2, 2, 2, 597, 
        598, 7, 39, 2, 2, 598, 122, 3, 2, 2, 2, 599, 600, 7, 45, 2, 2, 600, 124, 
        3, 2, 2, 2, 601, 602, 7, 47, 2, 2, 602, 603, 7, 47, 2, 2, 603, 126, 3, 
        2, 2, 2, 604, 605, 7, 47, 2, 2, 605, 128, 3, 2, 2, 2, 606, 607, 5, 185, 
        93, 2, 607, 608, 5, 195, 98, 2, 608, 609, 5, 221, 111, 2, 609, 130, 3, 
        2, 2, 2, 610, 611, 5, 203, 102, 2, 611, 612, 5, 207, 104, 2, 612, 613, 
        5, 185, 93, 2, 613, 132, 3, 2, 2, 2, 614, 615, 7, 63, 2, 2, 615, 134, 3, 
        2, 2, 2, 616, 617, 7, 64, 2, 2, 617, 136, 3, 2, 2, 2, 618, 619, 7, 62, 
        2, 2, 619, 138, 3, 2, 2, 2, 620, 621, 7, 35, 2, 2, 621, 140, 3, 2, 2, 2, 
        622, 623, 7, 128, 2, 2, 623, 142, 3, 2, 2, 2, 624, 625, 7, 126, 2, 2, 625, 
        144, 3, 2, 2, 2, 626, 627, 7, 40, 2, 2, 627, 146, 3, 2, 2, 2, 628, 629, 
        7, 96, 2, 2, 629, 148, 3, 2, 2, 2, 630, 631, 7, 48, 2, 2, 631, 150, 3, 
        2, 2, 2, 632, 633, 7, 42, 2, 2, 633, 152, 3, 2, 2, 2, 634, 635, 7, 43, 
        2, 2, 635, 154, 3, 2, 2, 2, 636, 637, 7, 46, 2, 2, 637, 156, 3, 2, 2, 2, 
        638, 641, 5, 171, 86, 2, 639, 641, 5, 173, 87, 2, 640, 638, 3, 2, 2, 2, 
        640, 639, 3, 2, 2, 2, 641, 158, 3, 2, 2, 2, 642, 644, 5, 177, 89, 2, 643, 
        642, 3, 2, 2, 2, 644, 645, 3, 2, 2, 2, 645, 643, 3, 2, 2, 2, 645, 646, 
        3, 2, 2, 2, 646, 160, 3, 2, 2, 2, 647, 649, 5, 177, 89, 2, 648, 647, 3, 
        2, 2, 2, 649, 650, 3, 2, 2, 2, 650, 648, 3, 2, 2, 2, 650, 651, 3, 2, 2, 
        2, 651, 653, 3, 2, 2, 2, 652, 648, 3, 2, 2, 2, 652, 653, 3, 2, 2, 2, 653, 
        654, 3, 2, 2, 2, 654, 656, 7, 48, 2, 2, 655, 657, 5, 177, 89, 2, 656, 655, 
        3, 2, 2, 2, 657, 658, 3, 2, 2, 2, 658, 656, 3, 2, 2, 2, 658, 659, 3, 2, 
        2, 2, 659, 162, 3, 2, 2, 2, 660, 661, 7, 94, 2, 2, 661, 662, 7, 80, 2, 
        2, 662, 164, 3, 2, 2, 2, 663, 664, 7, 48, 2, 2, 664, 665, 5, 169, 85, 2, 
        665, 166, 3, 2, 2, 2, 666, 669, 5, 169, 85, 2, 667, 669, 5, 175, 88, 2, 
        668, 666, 3, 2, 2, 2, 668, 667, 3, 2, 2, 2, 669, 168, 3, 2, 2, 2, 670, 
        672, 9, 4, 2, 2, 671, 670, 3, 2, 2, 2, 672, 675, 3, 2, 2, 2, 673, 674, 
        3, 2, 2, 2, 673, 671, 3, 2, 2, 2, 674, 677, 3, 2, 2, 2, 675, 673, 3, 2, 
        2, 2, 676, 678, 9, 5, 2, 2, 677, 676, 3, 2, 2, 2, 678, 679, 3, 2, 2, 2, 
        679, 680, 3, 2, 2, 2, 679, 677, 3, 2, 2, 2, 680, 684, 3, 2, 2, 2, 681, 
        683, 9, 4, 2, 2, 682, 681, 3, 2, 2, 2, 683, 686, 3, 2, 2, 2, 684, 682, 
        3, 2, 2, 2, 684, 685, 3, 2, 2, 2, 685, 170, 3, 2, 2, 2, 686, 684, 3, 2, 
        2, 2, 687, 695, 7, 36, 2, 2, 688, 689, 7, 94, 2, 2, 689, 694, 11, 2, 2, 
        2, 690, 691, 7, 36, 2, 2, 691, 694, 7, 36, 2, 2, 692, 694, 10, 6, 2, 2, 
        693, 688, 3, 2, 2, 2, 693, 690, 3, 2, 2, 2, 693, 692, 3, 2, 2, 2, 694, 
        697, 3, 2, 2, 2, 695, 693, 3, 2, 2, 2, 695, 696, 3, 2, 2, 2, 696, 698, 
        3, 2, 2, 2, 697, 695, 3, 2, 2, 2, 698, 699, 7, 36, 2, 2, 699, 172, 3, 2, 
        2, 2, 700, 708, 7, 41, 2, 2, 701, 702, 7, 94, 2, 2, 702, 707, 11, 2, 2, 
        2, 703, 704, 7, 41, 2, 2, 704, 707, 7, 41, 2, 2, 705, 707, 10, 7, 2, 2, 
        706, 701, 3, 2, 2, 2, 706, 703, 3, 2, 2, 2, 706, 705, 3, 2, 2, 2, 707, 
        710, 3, 2, 2, 2, 708, 706, 3, 2, 2, 2, 708, 709, 3, 2, 2, 2, 709, 711, 
        3, 2, 2, 2, 710, 708, 3, 2, 2, 2, 711, 712, 7, 41, 2, 2, 712, 174, 3, 2, 
        2, 2, 713, 721, 7, 98, 2, 2, 714, 715, 7, 94, 2, 2, 715, 720, 11, 2, 2, 
        2, 716, 717, 7, 98, 2, 2, 717, 720, 7, 98, 2, 2, 718, 720, 10, 8, 2, 2, 
        719, 714, 3, 2, 2, 2, 719, 716, 3, 2, 2, 2, 719, 718, 3, 2, 2, 2, 720, 
        723, 3, 2, 2, 2, 721, 719, 3, 2, 2, 2, 721, 722, 3, 2, 2, 2, 722, 724, 
        3, 2, 2, 2, 723, 721, 3, 2, 2, 2, 724, 725, 7, 98, 2, 2, 725, 176, 3, 2, 
        2, 2, 726, 727, 9, 9, 2, 2, 727, 178, 3, 2, 2, 2, 728, 729, 9, 10, 2, 2, 
        729, 180, 3, 2, 2, 2, 730, 731, 9, 11, 2, 2, 731, 182, 3, 2, 2, 2, 732, 
        733, 9, 12, 2, 2, 733, 184, 3, 2, 2, 2, 734, 735, 9, 13, 2, 2, 735, 186, 
        3, 2, 2, 2, 736, 737, 9, 14, 2, 2, 737, 188, 3, 2, 2, 2, 738, 739, 9, 15, 
        2, 2, 739, 190, 3, 2, 2, 2, 740, 741, 9, 16, 2, 2, 741, 192, 3, 2, 2, 2, 
        742, 743, 9, 17, 2, 2, 743, 194, 3, 2, 2, 2, 744, 745, 9, 18, 2, 2, 745, 
        196, 3, 2, 2, 2, 746, 747, 9, 19, 2, 2, 747, 198, 3, 2, 2, 2, 748, 749, 
        9, 20, 2, 2, 749, 200, 3, 2, 2, 2, 750, 751, 9, 21, 2, 2, 751, 202, 3, 
        2, 2, 2, 752, 753, 9, 22, 2, 2, 753, 204, 3, 2, 2, 2, 754, 755, 9, 23, 
        2, 2, 755, 206, 3, 2, 2, 2, 756, 757, 9, 24, 2, 2, 757, 208, 3, 2, 2, 2, 
        758, 759, 9, 25, 2, 2, 759, 210, 3, 2, 2, 2, 760, 761, 9, 26, 2, 2, 761, 
        212, 3, 2, 2, 2, 762, 763, 9, 27, 2, 2, 763, 214, 3, 2, 2, 2, 764, 765, 
        9, 28, 2, 2, 765, 216, 3, 2, 2, 2, 766, 767, 9, 29, 2, 2, 767, 218, 3, 
        2, 2, 2, 768, 769, 9, 30, 2, 2, 769, 220, 3, 2, 2, 2, 770, 771, 9, 31, 
        2, 2, 771, 222, 3, 2, 2, 2, 772, 773, 9, 32, 2, 2, 773, 224, 3, 2, 2, 2, 
        774, 775, 9, 33, 2, 2, 775, 226, 3, 2, 2, 2, 776, 777, 9, 34, 2, 2, 777, 
        228, 3, 2, 2, 2, 778, 779, 9, 35, 2, 2, 779, 230, 3, 2, 2, 2, 780, 781, 
        11, 2, 2, 2, 781, 782, 3, 2, 2, 2, 782, 783, 8, 116, 4, 2, 783, 232, 3, 
        2, 2, 2, 28, 2, 236, 247, 260, 272, 277, 281, 285, 291, 295, 297, 640, 
        645, 650, 652, 658, 668, 673, 679, 684, 693, 695, 706, 708, 719, 721, 5, 
        2, 3, 2, 2, 4, 2, 2, 5, 2,
}

var lexerDeserializer = antlr.NewATNDeserializer(nil)
var lexerAtn = lexerDeserializer.DeserializeFromUInt16(serializedLexerAtn)

var lexerChannelNames = []string{
        "DEFAULT_TOKEN_CHANNEL", "HIDDEN", "MYSQLCOMMENT", "ERRORCHANNEL",
}

var lexerModeNames = []string{
        "DEFAULT_MODE",
}

var lexerLiteralNames = []string{
        "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
        "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
        "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
        "", "", "", "", "'*'", "'/'", "'%'", "'+'", "'--'", "'-'", "", "", "'='", 
        "'&gt;'", "'&lt;'", "'!'", "'~'", "'|'", "'&amp;'", "'^'", "'.'", "'('", "')'", "','",
}

var lexerSymbolicNames = []string{
        "", "SPACE", "SPEC_MYSQL_COMMENT", "COMMENT_INPUT", "LINE_COMMENT", "ALL", 
        "AND", "AS", "ASC", "BETWEEN", "BY", "CASE", "CROSS", "DESC", "DISTINCT", 
        "ELSE", "EXISTS", "FALSE", "FROM", "GROUP", "HAVING", "IN", "INNER", "INTO", 
        "IS", "JOIN", "LEFT", "LIKE", "LIMIT", "NOT", "NULL_LITERAL", "ON", "OR", 
        "ORDER", "OUTER", "REGEXP", "RIGHT", "RLIKE", "SELECT", "THEN", "TRUE", 
        "UNION", "USING", "VALUES", "WHEN", "WHERE", "DELETE", "INSERT", "SET", 
        "UPDATE", "VALUE", "DEFAULT", "IGNORE", "ANY", "END", "OFFSET", "SOME", 
        "UNKNOWN", "STAR", "DIVIDE", "MODULE", "PLUS", "MINUSMINUS", "MINUS", "DIV", 
        "MOD", "EQUAL_SYMBOL", "GREATER_SYMBOL", "LESS_SYMBOL", "EXCLAMATION_SYMBOL", 
        "BIT_NOT_OP", "BIT_OR_OP", "BIT_AND_OP", "BIT_XOR_OP", "DOT", "LR_BRACKET", 
        "RR_BRACKET", "COMMA", "STRING_LITERAL", "DECIMAL_LITERAL", "REAL_LITERAL", 
        "NULL_SPEC_LITERAL", "DOT_ID", "ID", "ERROR_RECONGNIGION",
}

var lexerRuleNames = []string{
        "SPACE", "SPEC_MYSQL_COMMENT", "COMMENT_INPUT", "LINE_COMMENT", "ALL", 
        "AND", "AS", "ASC", "BETWEEN", "BY", "CASE", "CROSS", "DESC", "DISTINCT", 
        "ELSE", "EXISTS", "FALSE", "FROM", "GROUP", "HAVING", "IN", "INNER", "INTO", 
        "IS", "JOIN", "LEFT", "LIKE", "LIMIT", "NOT", "NULL_LITERAL", "ON", "OR", 
        "ORDER", "OUTER", "REGEXP", "RIGHT", "RLIKE", "SELECT", "THEN", "TRUE", 
        "UNION", "USING", "VALUES", "WHEN", "WHERE", "DELETE", "INSERT", "SET", 
        "UPDATE", "VALUE", "DEFAULT", "IGNORE", "ANY", "END", "OFFSET", "SOME", 
        "UNKNOWN", "STAR", "DIVIDE", "MODULE", "PLUS", "MINUSMINUS", "MINUS", "DIV", 
        "MOD", "EQUAL_SYMBOL", "GREATER_SYMBOL", "LESS_SYMBOL", "EXCLAMATION_SYMBOL", 
        "BIT_NOT_OP", "BIT_OR_OP", "BIT_AND_OP", "BIT_XOR_OP", "DOT", "LR_BRACKET", 
        "RR_BRACKET", "COMMA", "STRING_LITERAL", "DECIMAL_LITERAL", "REAL_LITERAL", 
        "NULL_SPEC_LITERAL", "DOT_ID", "ID", "ID_LITERAL", "DQUOTA_STRING", "SQUOTA_STRING", 
        "BQUOTA_STRING", "DEC_DIGIT", "A", "B", "C", "D", "E", "F", "G", "H", "I", 
        "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", 
        "Y", "Z", "ERROR_RECONGNIGION",
}

type MySqlLexer struct {
        *antlr.BaseLexer
        channelNames []string
        modeNames []string
        // TODO: EOF string
}

var lexerDecisionToDFA = make([]*antlr.DFA, len(lexerAtn.DecisionToState))

func init() <span class="cov8" title="1">{
        for index, ds := range lexerAtn.DecisionToState </span><span class="cov8" title="1">{
                lexerDecisionToDFA[index] = antlr.NewDFA(ds, index)
        }</span>
}

func NewMySqlLexer(input antlr.CharStream) *MySqlLexer <span class="cov8" title="1">{

        l := new(MySqlLexer)

        l.BaseLexer = antlr.NewBaseLexer(input)
        l.Interpreter = antlr.NewLexerATNSimulator(l, lexerAtn, lexerDecisionToDFA, antlr.NewPredictionContextCache())

        l.channelNames = lexerChannelNames
        l.modeNames = lexerModeNames
        l.RuleNames = lexerRuleNames
        l.LiteralNames = lexerLiteralNames
        l.SymbolicNames = lexerSymbolicNames
        l.GrammarFileName = "MySqlLexer.g4"
        // TODO: l.EOF = antlr.TokenEOF

        return l
}</span>

// MySqlLexer tokens.
const (
        MySqlLexerSPACE = 1
        MySqlLexerSPEC_MYSQL_COMMENT = 2
        MySqlLexerCOMMENT_INPUT = 3
        MySqlLexerLINE_COMMENT = 4
        MySqlLexerALL = 5
        MySqlLexerAND = 6
        MySqlLexerAS = 7
        MySqlLexerASC = 8
        MySqlLexerBETWEEN = 9
        MySqlLexerBY = 10
        MySqlLexerCASE = 11
        MySqlLexerCROSS = 12
        MySqlLexerDESC = 13
        MySqlLexerDISTINCT = 14
        MySqlLexerELSE = 15
        MySqlLexerEXISTS = 16
        MySqlLexerFALSE = 17
        MySqlLexerFROM = 18
        MySqlLexerGROUP = 19
        MySqlLexerHAVING = 20
        MySqlLexerIN = 21
        MySqlLexerINNER = 22
        MySqlLexerINTO = 23
        MySqlLexerIS = 24
        MySqlLexerJOIN = 25
        MySqlLexerLEFT = 26
        MySqlLexerLIKE = 27
        MySqlLexerLIMIT = 28
        MySqlLexerNOT = 29
        MySqlLexerNULL_LITERAL = 30
        MySqlLexerON = 31
        MySqlLexerOR = 32
        MySqlLexerORDER = 33
        MySqlLexerOUTER = 34
        MySqlLexerREGEXP = 35
        MySqlLexerRIGHT = 36
        MySqlLexerRLIKE = 37
        MySqlLexerSELECT = 38
        MySqlLexerTHEN = 39
        MySqlLexerTRUE = 40
        MySqlLexerUNION = 41
        MySqlLexerUSING = 42
        MySqlLexerVALUES = 43
        MySqlLexerWHEN = 44
        MySqlLexerWHERE = 45
        MySqlLexerDELETE = 46
        MySqlLexerINSERT = 47
        MySqlLexerSET = 48
        MySqlLexerUPDATE = 49
        MySqlLexerVALUE = 50
        MySqlLexerDEFAULT = 51
        MySqlLexerIGNORE = 52
        MySqlLexerANY = 53
        MySqlLexerEND = 54
        MySqlLexerOFFSET = 55
        MySqlLexerSOME = 56
        MySqlLexerUNKNOWN = 57
        MySqlLexerSTAR = 58
        MySqlLexerDIVIDE = 59
        MySqlLexerMODULE = 60
        MySqlLexerPLUS = 61
        MySqlLexerMINUSMINUS = 62
        MySqlLexerMINUS = 63
        MySqlLexerDIV = 64
        MySqlLexerMOD = 65
        MySqlLexerEQUAL_SYMBOL = 66
        MySqlLexerGREATER_SYMBOL = 67
        MySqlLexerLESS_SYMBOL = 68
        MySqlLexerEXCLAMATION_SYMBOL = 69
        MySqlLexerBIT_NOT_OP = 70
        MySqlLexerBIT_OR_OP = 71
        MySqlLexerBIT_AND_OP = 72
        MySqlLexerBIT_XOR_OP = 73
        MySqlLexerDOT = 74
        MySqlLexerLR_BRACKET = 75
        MySqlLexerRR_BRACKET = 76
        MySqlLexerCOMMA = 77
        MySqlLexerSTRING_LITERAL = 78
        MySqlLexerDECIMAL_LITERAL = 79
        MySqlLexerREAL_LITERAL = 80
        MySqlLexerNULL_SPEC_LITERAL = 81
        MySqlLexerDOT_ID = 82
        MySqlLexerID = 83
        MySqlLexerERROR_RECONGNIGION = 84
)

// MySqlLexer channels.
const (
        MySqlLexerMYSQLCOMMENT = 2
        MySqlLexerERRORCHANNEL = 3
)

</pre>
		
		<pre class="file" id="file11" style="display: none">// Code generated from /Users/zhangzhiqiang/go/src/github.com/Aiyane/golinq/sql-parser/MySqlParser.g4 by ANTLR 4.7.2. DO NOT EDIT.

package parser // MySqlParser

import (
        "fmt"
        "reflect"
        "strconv"

        "github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa


var parserATN = []uint16{
        3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 86, 622, 
        4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7, 
        4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13, 
        9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9, 
        18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23, 
        4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4, 
        29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34, 
        9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9, 
        39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 3, 2, 3, 2, 3, 2, 3, 2, 5, 
        2, 89, 10, 2, 3, 3, 3, 3, 5, 3, 93, 10, 3, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 
        7, 4, 100, 10, 4, 12, 4, 14, 4, 103, 11, 4, 3, 5, 3, 5, 5, 5, 107, 10, 
        5, 3, 6, 3, 6, 7, 6, 111, 10, 6, 12, 6, 14, 6, 114, 11, 6, 3, 6, 3, 6, 
        3, 6, 7, 6, 119, 10, 6, 12, 6, 14, 6, 122, 11, 6, 3, 6, 3, 6, 5, 6, 126, 
        10, 6, 3, 7, 3, 7, 3, 7, 7, 7, 131, 10, 7, 12, 7, 14, 7, 134, 11, 7, 3, 
        8, 3, 8, 5, 8, 138, 10, 8, 3, 8, 5, 8, 141, 10, 8, 3, 8, 3, 8, 3, 8, 3, 
        8, 3, 8, 5, 8, 148, 10, 8, 3, 8, 5, 8, 151, 10, 8, 3, 8, 3, 8, 3, 8, 3, 
        8, 3, 8, 3, 8, 5, 8, 159, 10, 8, 3, 9, 5, 9, 162, 10, 9, 3, 9, 3, 9, 3, 
        9, 3, 9, 5, 9, 168, 10, 9, 3, 9, 3, 9, 5, 9, 172, 10, 9, 3, 9, 3, 9, 3, 
        9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 5, 9, 183, 10, 9, 5, 9, 185, 10, 
        9, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 5, 10, 195, 
        10, 10, 3, 11, 3, 11, 5, 11, 199, 10, 11, 3, 11, 3, 11, 5, 11, 203, 10, 
        11, 3, 11, 5, 11, 206, 10, 11, 3, 11, 5, 11, 209, 10, 11, 3, 12, 3, 12, 
        5, 12, 213, 10, 12, 3, 12, 3, 12, 7, 12, 217, 10, 12, 12, 12, 14, 12, 220, 
        11, 12, 3, 13, 3, 13, 5, 13, 224, 10, 13, 3, 13, 5, 13, 227, 10, 13, 3, 
        13, 3, 13, 5, 13, 231, 10, 13, 3, 13, 5, 13, 234, 10, 13, 3, 13, 3, 13, 
        5, 13, 238, 10, 13, 3, 13, 5, 13, 241, 10, 13, 5, 13, 243, 10, 13, 3, 14, 
        3, 14, 3, 14, 3, 14, 5, 14, 249, 10, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 
        14, 7, 14, 256, 10, 14, 12, 14, 14, 14, 259, 11, 14, 3, 14, 3, 14, 5, 14, 
        263, 10, 14, 5, 14, 265, 10, 14, 3, 15, 3, 15, 5, 15, 269, 10, 15, 3, 16, 
        3, 16, 3, 16, 5, 16, 274, 10, 16, 3, 16, 3, 16, 3, 16, 3, 16, 5, 16, 280, 
        10, 16, 3, 17, 3, 17, 7, 17, 284, 10, 17, 12, 17, 14, 17, 287, 11, 17, 
        3, 18, 3, 18, 3, 19, 5, 19, 292, 10, 19, 3, 19, 3, 19, 3, 20, 3, 20, 3, 
        20, 3, 20, 3, 20, 3, 20, 3, 20, 5, 20, 303, 10, 20, 3, 20, 5, 20, 306, 
        10, 20, 3, 21, 3, 21, 3, 21, 7, 21, 311, 10, 21, 12, 21, 14, 21, 314, 11, 
        21, 3, 22, 3, 22, 3, 22, 7, 22, 319, 10, 22, 12, 22, 14, 22, 322, 11, 22, 
        3, 23, 3, 23, 3, 23, 3, 23, 5, 23, 328, 10, 23, 3, 23, 5, 23, 331, 10, 
        23, 3, 24, 3, 24, 3, 24, 6, 24, 336, 10, 24, 13, 24, 14, 24, 337, 3, 24, 
        3, 24, 5, 24, 342, 10, 24, 3, 24, 3, 24, 3, 24, 3, 24, 6, 24, 348, 10, 
        24, 13, 24, 14, 24, 349, 3, 24, 3, 24, 5, 24, 354, 10, 24, 3, 24, 3, 24, 
        5, 24, 358, 10, 24, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 26, 3, 26, 3, 
        26, 7, 26, 368, 10, 26, 12, 26, 14, 26, 371, 11, 26, 3, 27, 3, 27, 3, 27, 
        3, 27, 3, 27, 3, 27, 5, 27, 379, 10, 27, 3, 28, 3, 28, 3, 28, 3, 28, 5, 
        28, 385, 10, 28, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 5, 29, 393, 
        10, 29, 3, 29, 3, 29, 3, 29, 5, 29, 398, 10, 29, 3, 29, 3, 29, 3, 29, 3, 
        29, 7, 29, 404, 10, 29, 12, 29, 14, 29, 407, 11, 29, 3, 30, 3, 30, 3, 30, 
        3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 5, 30, 418, 10, 30, 3, 30, 3, 
        30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 5, 30, 427, 10, 30, 3, 30, 3, 30, 
        3, 30, 3, 30, 5, 30, 433, 10, 30, 3, 30, 3, 30, 3, 30, 3, 30, 5, 30, 439, 
        10, 30, 3, 30, 3, 30, 3, 30, 3, 30, 5, 30, 445, 10, 30, 3, 30, 3, 30, 3, 
        30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 7, 30, 
        459, 10, 30, 12, 30, 14, 30, 462, 11, 30, 3, 31, 3, 31, 3, 31, 3, 31, 3, 
        31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 7, 31, 475, 10, 31, 12, 31, 
        14, 31, 478, 11, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 
        31, 3, 31, 3, 31, 3, 31, 5, 31, 491, 10, 31, 3, 31, 3, 31, 3, 31, 3, 31, 
        3, 31, 3, 31, 3, 31, 7, 31, 500, 10, 31, 12, 31, 14, 31, 503, 11, 31, 3, 
        32, 3, 32, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 
        3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 5, 33, 521, 10, 33, 3, 34, 3, 34, 3, 
        35, 3, 35, 3, 36, 3, 36, 5, 36, 529, 10, 36, 3, 36, 5, 36, 532, 10, 36, 
        3, 36, 3, 36, 3, 36, 3, 36, 3, 36, 5, 36, 539, 10, 36, 3, 36, 3, 36, 3, 
        37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 7, 37, 
        553, 10, 37, 12, 37, 14, 37, 556, 11, 37, 5, 37, 558, 10, 37, 3, 38, 3, 
        38, 3, 38, 3, 38, 3, 39, 3, 39, 3, 39, 7, 39, 567, 10, 39, 12, 39, 14, 
        39, 570, 11, 39, 3, 40, 3, 40, 5, 40, 574, 10, 40, 3, 41, 3, 41, 5, 41, 
        578, 10, 41, 3, 41, 3, 41, 3, 41, 3, 41, 5, 41, 584, 10, 41, 3, 41, 5, 
        41, 587, 10, 41, 3, 41, 5, 41, 590, 10, 41, 3, 42, 3, 42, 5, 42, 594, 10, 
        42, 3, 42, 3, 42, 5, 42, 598, 10, 42, 3, 42, 5, 42, 601, 10, 42, 3, 42, 
        3, 42, 3, 42, 3, 42, 7, 42, 607, 10, 42, 12, 42, 14, 42, 610, 11, 42, 3, 
        42, 3, 42, 5, 42, 614, 10, 42, 3, 42, 5, 42, 617, 10, 42, 3, 42, 5, 42, 
        620, 10, 42, 3, 42, 2, 5, 56, 58, 60, 43, 2, 4, 6, 8, 10, 12, 14, 16, 18, 
        20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 
        56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 2, 16, 4, 2, 10, 
        10, 15, 15, 4, 2, 14, 14, 24, 24, 4, 2, 28, 28, 38, 38, 4, 2, 19, 19, 42, 
        42, 4, 2, 32, 32, 83, 83, 4, 2, 31, 31, 71, 71, 5, 2, 19, 19, 42, 42, 59, 
        59, 4, 2, 37, 37, 39, 39, 5, 2, 7, 7, 55, 55, 58, 58, 4, 2, 60, 62, 66, 
        67, 6, 2, 31, 31, 63, 63, 65, 65, 71, 72, 4, 2, 8, 8, 34, 34, 3, 2, 63, 
        65, 4, 2, 45, 45, 52, 52, 2, 699, 2, 88, 3, 2, 2, 2, 4, 92, 3, 2, 2, 2, 
        6, 94, 3, 2, 2, 2, 8, 104, 3, 2, 2, 2, 10, 125, 3, 2, 2, 2, 12, 127, 3, 
        2, 2, 2, 14, 158, 3, 2, 2, 2, 16, 184, 3, 2, 2, 2, 18, 194, 3, 2, 2, 2, 
        20, 196, 3, 2, 2, 2, 22, 212, 3, 2, 2, 2, 24, 242, 3, 2, 2, 2, 26, 244, 
        3, 2, 2, 2, 28, 266, 3, 2, 2, 2, 30, 270, 3, 2, 2, 2, 32, 281, 3, 2, 2, 
        2, 34, 288, 3, 2, 2, 2, 36, 291, 3, 2, 2, 2, 38, 305, 3, 2, 2, 2, 40, 307, 
        3, 2, 2, 2, 42, 315, 3, 2, 2, 2, 44, 330, 3, 2, 2, 2, 46, 357, 3, 2, 2, 
        2, 48, 359, 3, 2, 2, 2, 50, 364, 3, 2, 2, 2, 52, 378, 3, 2, 2, 2, 54, 384, 
        3, 2, 2, 2, 56, 397, 3, 2, 2, 2, 58, 408, 3, 2, 2, 2, 60, 490, 3, 2, 2, 
        2, 62, 504, 3, 2, 2, 2, 64, 520, 3, 2, 2, 2, 66, 522, 3, 2, 2, 2, 68, 524, 
        3, 2, 2, 2, 70, 526, 3, 2, 2, 2, 72, 557, 3, 2, 2, 2, 74, 559, 3, 2, 2, 
        2, 76, 563, 3, 2, 2, 2, 78, 573, 3, 2, 2, 2, 80, 575, 3, 2, 2, 2, 82, 591, 
        3, 2, 2, 2, 84, 89, 5, 20, 11, 2, 85, 89, 5, 70, 36, 2, 86, 89, 5, 82, 
        42, 2, 87, 89, 5, 80, 41, 2, 88, 84, 3, 2, 2, 2, 88, 85, 3, 2, 2, 2, 88, 
        86, 3, 2, 2, 2, 88, 87, 3, 2, 2, 2, 89, 3, 3, 2, 2, 2, 90, 93, 5, 20, 11, 
        2, 91, 93, 5, 18, 10, 2, 92, 90, 3, 2, 2, 2, 92, 91, 3, 2, 2, 2, 93, 5, 
        3, 2, 2, 2, 94, 95, 7, 35, 2, 2, 95, 96, 7, 12, 2, 2, 96, 101, 5, 8, 5, 
        2, 97, 98, 7, 79, 2, 2, 98, 100, 5, 8, 5, 2, 99, 97, 3, 2, 2, 2, 100, 103, 
        3, 2, 2, 2, 101, 99, 3, 2, 2, 2, 101, 102, 3, 2, 2, 2, 102, 7, 3, 2, 2, 
        2, 103, 101, 3, 2, 2, 2, 104, 106, 5, 56, 29, 2, 105, 107, 9, 2, 2, 2, 
        106, 105, 3, 2, 2, 2, 106, 107, 3, 2, 2, 2, 107, 9, 3, 2, 2, 2, 108, 112, 
        5, 14, 8, 2, 109, 111, 5, 16, 9, 2, 110, 109, 3, 2, 2, 2, 111, 114, 3, 
        2, 2, 2, 112, 110, 3, 2, 2, 2, 112, 113, 3, 2, 2, 2, 113, 126, 3, 2, 2, 
        2, 114, 112, 3, 2, 2, 2, 115, 116, 7, 77, 2, 2, 116, 120, 5, 14, 8, 2, 
        117, 119, 5, 16, 9, 2, 118, 117, 3, 2, 2, 2, 119, 122, 3, 2, 2, 2, 120, 
        118, 3, 2, 2, 2, 120, 121, 3, 2, 2, 2, 121, 123, 3, 2, 2, 2, 122, 120, 
        3, 2, 2, 2, 123, 124, 7, 78, 2, 2, 124, 126, 3, 2, 2, 2, 125, 108, 3, 2, 
        2, 2, 125, 115, 3, 2, 2, 2, 126, 11, 3, 2, 2, 2, 127, 132, 5, 10, 6, 2, 
        128, 129, 7, 79, 2, 2, 129, 131, 5, 10, 6, 2, 130, 128, 3, 2, 2, 2, 131, 
        134, 3, 2, 2, 2, 132, 130, 3, 2, 2, 2, 132, 133, 3, 2, 2, 2, 133, 13, 3, 
        2, 2, 2, 134, 132, 3, 2, 2, 2, 135, 140, 5, 32, 17, 2, 136, 138, 7, 9, 
        2, 2, 137, 136, 3, 2, 2, 2, 137, 138, 3, 2, 2, 2, 138, 139, 3, 2, 2, 2, 
        139, 141, 7, 85, 2, 2, 140, 137, 3, 2, 2, 2, 140, 141, 3, 2, 2, 2, 141, 
        159, 3, 2, 2, 2, 142, 148, 5, 4, 3, 2, 143, 144, 7, 77, 2, 2, 144, 145, 
        5, 4, 3, 2, 145, 146, 7, 78, 2, 2, 146, 148, 3, 2, 2, 2, 147, 142, 3, 2, 
        2, 2, 147, 143, 3, 2, 2, 2, 148, 150, 3, 2, 2, 2, 149, 151, 7, 9, 2, 2, 
        150, 149, 3, 2, 2, 2, 150, 151, 3, 2, 2, 2, 151, 152, 3, 2, 2, 2, 152, 
        153, 7, 85, 2, 2, 153, 159, 3, 2, 2, 2, 154, 155, 7, 77, 2, 2, 155, 156, 
        5, 12, 7, 2, 156, 157, 7, 78, 2, 2, 157, 159, 3, 2, 2, 2, 158, 135, 3, 
        2, 2, 2, 158, 147, 3, 2, 2, 2, 158, 154, 3, 2, 2, 2, 159, 15, 3, 2, 2, 
        2, 160, 162, 9, 3, 2, 2, 161, 160, 3, 2, 2, 2, 161, 162, 3, 2, 2, 2, 162, 
        163, 3, 2, 2, 2, 163, 164, 7, 27, 2, 2, 164, 167, 5, 14, 8, 2, 165, 166, 
        7, 33, 2, 2, 166, 168, 5, 56, 29, 2, 167, 165, 3, 2, 2, 2, 167, 168, 3, 
        2, 2, 2, 168, 185, 3, 2, 2, 2, 169, 171, 9, 4, 2, 2, 170, 172, 7, 36, 2, 
        2, 171, 170, 3, 2, 2, 2, 171, 172, 3, 2, 2, 2, 172, 173, 3, 2, 2, 2, 173, 
        174, 7, 27, 2, 2, 174, 182, 5, 14, 8, 2, 175, 176, 7, 33, 2, 2, 176, 183, 
        5, 56, 29, 2, 177, 178, 7, 44, 2, 2, 178, 179, 7, 77, 2, 2, 179, 180, 5, 
        40, 21, 2, 180, 181, 7, 78, 2, 2, 181, 183, 3, 2, 2, 2, 182, 175, 3, 2, 
        2, 2, 182, 177, 3, 2, 2, 2, 183, 185, 3, 2, 2, 2, 184, 161, 3, 2, 2, 2, 
        184, 169, 3, 2, 2, 2, 185, 17, 3, 2, 2, 2, 186, 187, 7, 77, 2, 2, 187, 
        188, 5, 20, 11, 2, 188, 189, 7, 78, 2, 2, 189, 195, 3, 2, 2, 2, 190, 191, 
        7, 77, 2, 2, 191, 192, 5, 18, 10, 2, 192, 193, 7, 78, 2, 2, 193, 195, 3, 
        2, 2, 2, 194, 186, 3, 2, 2, 2, 194, 190, 3, 2, 2, 2, 195, 19, 3, 2, 2, 
        2, 196, 198, 7, 40, 2, 2, 197, 199, 7, 16, 2, 2, 198, 197, 3, 2, 2, 2, 
        198, 199, 3, 2, 2, 2, 199, 200, 3, 2, 2, 2, 200, 202, 5, 22, 12, 2, 201, 
        203, 5, 26, 14, 2, 202, 201, 3, 2, 2, 2, 202, 203, 3, 2, 2, 2, 203, 205, 
        3, 2, 2, 2, 204, 206, 5, 6, 4, 2, 205, 204, 3, 2, 2, 2, 205, 206, 3, 2, 
        2, 2, 206, 208, 3, 2, 2, 2, 207, 209, 5, 30, 16, 2, 208, 207, 3, 2, 2, 
        2, 208, 209, 3, 2, 2, 2, 209, 21, 3, 2, 2, 2, 210, 213, 7, 60, 2, 2, 211, 
        213, 5, 24, 13, 2, 212, 210, 3, 2, 2, 2, 212, 211, 3, 2, 2, 2, 213, 218, 
        3, 2, 2, 2, 214, 215, 7, 79, 2, 2, 215, 217, 5, 24, 13, 2, 216, 214, 3, 
        2, 2, 2, 217, 220, 3, 2, 2, 2, 218, 216, 3, 2, 2, 2, 218, 219, 3, 2, 2, 
        2, 219, 23, 3, 2, 2, 2, 220, 218, 3, 2, 2, 2, 221, 226, 5, 32, 17, 2, 222, 
        224, 7, 9, 2, 2, 223, 222, 3, 2, 2, 2, 223, 224, 3, 2, 2, 2, 224, 225, 
        3, 2, 2, 2, 225, 227, 7, 85, 2, 2, 226, 223, 3, 2, 2, 2, 226, 227, 3, 2, 
        2, 2, 227, 243, 3, 2, 2, 2, 228, 233, 5, 44, 23, 2, 229, 231, 7, 9, 2, 
        2, 230, 229, 3, 2, 2, 2, 230, 231, 3, 2, 2, 2, 231, 232, 3, 2, 2, 2, 232, 
        234, 7, 85, 2, 2, 233, 230, 3, 2, 2, 2, 233, 234, 3, 2, 2, 2, 234, 243, 
        3, 2, 2, 2, 235, 240, 5, 56, 29, 2, 236, 238, 7, 9, 2, 2, 237, 236, 3, 
        2, 2, 2, 237, 238, 3, 2, 2, 2, 238, 239, 3, 2, 2, 2, 239, 241, 7, 85, 2, 
        2, 240, 237, 3, 2, 2, 2, 240, 241, 3, 2, 2, 2, 241, 243, 3, 2, 2, 2, 242, 
        221, 3, 2, 2, 2, 242, 228, 3, 2, 2, 2, 242, 235, 3, 2, 2, 2, 243, 25, 3, 
        2, 2, 2, 244, 245, 7, 20, 2, 2, 245, 248, 5, 12, 7, 2, 246, 247, 7, 47, 
        2, 2, 247, 249, 5, 56, 29, 2, 248, 246, 3, 2, 2, 2, 248, 249, 3, 2, 2, 
        2, 249, 264, 3, 2, 2, 2, 250, 251, 7, 21, 2, 2, 251, 252, 7, 12, 2, 2, 
        252, 257, 5, 28, 15, 2, 253, 254, 7, 79, 2, 2, 254, 256, 5, 28, 15, 2, 
        255, 253, 3, 2, 2, 2, 256, 259, 3, 2, 2, 2, 257, 255, 3, 2, 2, 2, 257, 
        258, 3, 2, 2, 2, 258, 262, 3, 2, 2, 2, 259, 257, 3, 2, 2, 2, 260, 261, 
        7, 22, 2, 2, 261, 263, 5, 56, 29, 2, 262, 260, 3, 2, 2, 2, 262, 263, 3, 
        2, 2, 2, 263, 265, 3, 2, 2, 2, 264, 250, 3, 2, 2, 2, 264, 265, 3, 2, 2, 
        2, 265, 27, 3, 2, 2, 2, 266, 268, 5, 56, 29, 2, 267, 269, 9, 2, 2, 2, 268, 
        267, 3, 2, 2, 2, 268, 269, 3, 2, 2, 2, 269, 29, 3, 2, 2, 2, 270, 279, 7, 
        30, 2, 2, 271, 272, 7, 81, 2, 2, 272, 274, 7, 79, 2, 2, 273, 271, 3, 2, 
        2, 2, 273, 274, 3, 2, 2, 2, 274, 275, 3, 2, 2, 2, 275, 280, 7, 81, 2, 2, 
        276, 277, 7, 81, 2, 2, 277, 278, 7, 57, 2, 2, 278, 280, 7, 81, 2, 2, 279, 
        273, 3, 2, 2, 2, 279, 276, 3, 2, 2, 2, 280, 31, 3, 2, 2, 2, 281, 285, 7, 
        85, 2, 2, 282, 284, 7, 84, 2, 2, 283, 282, 3, 2, 2, 2, 284, 287, 3, 2, 
        2, 2, 285, 283, 3, 2, 2, 2, 285, 286, 3, 2, 2, 2, 286, 33, 3, 2, 2, 2, 
        287, 285, 3, 2, 2, 2, 288, 289, 9, 5, 2, 2, 289, 35, 3, 2, 2, 2, 290, 292, 
        7, 31, 2, 2, 291, 290, 3, 2, 2, 2, 291, 292, 3, 2, 2, 2, 292, 293, 3, 2, 
        2, 2, 293, 294, 9, 6, 2, 2, 294, 37, 3, 2, 2, 2, 295, 306, 7, 80, 2, 2, 
        296, 306, 7, 81, 2, 2, 297, 298, 7, 65, 2, 2, 298, 306, 7, 81, 2, 2, 299, 
        306, 5, 34, 18, 2, 300, 306, 7, 82, 2, 2, 301, 303, 7, 31, 2, 2, 302, 301, 
        3, 2, 2, 2, 302, 303, 3, 2, 2, 2, 303, 304, 3, 2, 2, 2, 304, 306, 9, 6, 
        2, 2, 305, 295, 3, 2, 2, 2, 305, 296, 3, 2, 2, 2, 305, 297, 3, 2, 2, 2, 
        305, 299, 3, 2, 2, 2, 305, 300, 3, 2, 2, 2, 305, 302, 3, 2, 2, 2, 306, 
        39, 3, 2, 2, 2, 307, 312, 7, 85, 2, 2, 308, 309, 7, 79, 2, 2, 309, 311, 
        7, 85, 2, 2, 310, 308, 3, 2, 2, 2, 311, 314, 3, 2, 2, 2, 312, 310, 3, 2, 
        2, 2, 312, 313, 3, 2, 2, 2, 313, 41, 3, 2, 2, 2, 314, 312, 3, 2, 2, 2, 
        315, 320, 5, 56, 29, 2, 316, 317, 7, 79, 2, 2, 317, 319, 5, 56, 29, 2, 
        318, 316, 3, 2, 2, 2, 319, 322, 3, 2, 2, 2, 320, 318, 3, 2, 2, 2, 320, 
        321, 3, 2, 2, 2, 321, 43, 3, 2, 2, 2, 322, 320, 3, 2, 2, 2, 323, 331, 5, 
        46, 24, 2, 324, 325, 7, 85, 2, 2, 325, 327, 7, 77, 2, 2, 326, 328, 5, 50, 
        26, 2, 327, 326, 3, 2, 2, 2, 327, 328, 3, 2, 2, 2, 328, 329, 3, 2, 2, 2, 
        329, 331, 7, 78, 2, 2, 330, 323, 3, 2, 2, 2, 330, 324, 3, 2, 2, 2, 331, 
        45, 3, 2, 2, 2, 332, 333, 7, 13, 2, 2, 333, 335, 5, 32, 17, 2, 334, 336, 
        5, 48, 25, 2, 335, 334, 3, 2, 2, 2, 336, 337, 3, 2, 2, 2, 337, 335, 3, 
        2, 2, 2, 337, 338, 3, 2, 2, 2, 338, 341, 3, 2, 2, 2, 339, 340, 7, 17, 2, 
        2, 340, 342, 5, 54, 28, 2, 341, 339, 3, 2, 2, 2, 341, 342, 3, 2, 2, 2, 
        342, 343, 3, 2, 2, 2, 343, 344, 7, 56, 2, 2, 344, 358, 3, 2, 2, 2, 345, 
        347, 7, 13, 2, 2, 346, 348, 5, 48, 25, 2, 347, 346, 3, 2, 2, 2, 348, 349, 
        3, 2, 2, 2, 349, 347, 3, 2, 2, 2, 349, 350, 3, 2, 2, 2, 350, 353, 3, 2, 
        2, 2, 351, 352, 7, 17, 2, 2, 352, 354, 5, 54, 28, 2, 353, 351, 3, 2, 2, 
        2, 353, 354, 3, 2, 2, 2, 354, 355, 3, 2, 2, 2, 355, 356, 7, 56, 2, 2, 356, 
        358, 3, 2, 2, 2, 357, 332, 3, 2, 2, 2, 357, 345, 3, 2, 2, 2, 358, 47, 3, 
        2, 2, 2, 359, 360, 7, 46, 2, 2, 360, 361, 5, 54, 28, 2, 361, 362, 7, 41, 
        2, 2, 362, 363, 5, 54, 28, 2, 363, 49, 3, 2, 2, 2, 364, 369, 5, 52, 27, 
        2, 365, 366, 7, 79, 2, 2, 366, 368, 5, 52, 27, 2, 367, 365, 3, 2, 2, 2, 
        368, 371, 3, 2, 2, 2, 369, 367, 3, 2, 2, 2, 369, 370, 3, 2, 2, 2, 370, 
        51, 3, 2, 2, 2, 371, 369, 3, 2, 2, 2, 372, 379, 7, 60, 2, 2, 373, 379, 
        7, 7, 2, 2, 374, 379, 5, 38, 20, 2, 375, 379, 5, 32, 17, 2, 376, 379, 5, 
        44, 23, 2, 377, 379, 5, 56, 29, 2, 378, 372, 3, 2, 2, 2, 378, 373, 3, 2, 
        2, 2, 378, 374, 3, 2, 2, 2, 378, 375, 3, 2, 2, 2, 378, 376, 3, 2, 2, 2, 
        378, 377, 3, 2, 2, 2, 379, 53, 3, 2, 2, 2, 380, 385, 5, 38, 20, 2, 381, 
        385, 5, 32, 17, 2, 382, 385, 5, 44, 23, 2, 383, 385, 5, 56, 29, 2, 384, 
        380, 3, 2, 2, 2, 384, 381, 3, 2, 2, 2, 384, 382, 3, 2, 2, 2, 384, 383, 
        3, 2, 2, 2, 385, 55, 3, 2, 2, 2, 386, 387, 8, 29, 1, 2, 387, 388, 9, 7, 
        2, 2, 388, 398, 5, 56, 29, 6, 389, 390, 5, 58, 30, 2, 390, 392, 7, 26, 
        2, 2, 391, 393, 7, 31, 2, 2, 392, 391, 3, 2, 2, 2, 392, 393, 3, 2, 2, 2, 
        393, 394, 3, 2, 2, 2, 394, 395, 9, 8, 2, 2, 395, 398, 3, 2, 2, 2, 396, 
        398, 5, 58, 30, 2, 397, 386, 3, 2, 2, 2, 397, 389, 3, 2, 2, 2, 397, 396, 
        3, 2, 2, 2, 398, 405, 3, 2, 2, 2, 399, 400, 12, 5, 2, 2, 400, 401, 5, 66, 
        34, 2, 401, 402, 5, 56, 29, 6, 402, 404, 3, 2, 2, 2, 403, 399, 3, 2, 2, 
        2, 404, 407, 3, 2, 2, 2, 405, 403, 3, 2, 2, 2, 405, 406, 3, 2, 2, 2, 406, 
        57, 3, 2, 2, 2, 407, 405, 3, 2, 2, 2, 408, 409, 8, 30, 1, 2, 409, 410, 
        5, 60, 31, 2, 410, 460, 3, 2, 2, 2, 411, 412, 12, 8, 2, 2, 412, 413, 5, 
        64, 33, 2, 413, 414, 5, 58, 30, 9, 414, 459, 3, 2, 2, 2, 415, 417, 12, 
        6, 2, 2, 416, 418, 7, 31, 2, 2, 417, 416, 3, 2, 2, 2, 417, 418, 3, 2, 2, 
        2, 418, 419, 3, 2, 2, 2, 419, 420, 7, 11, 2, 2, 420, 421, 5, 58, 30, 2, 
        421, 422, 7, 8, 2, 2, 422, 423, 5, 58, 30, 7, 423, 459, 3, 2, 2, 2, 424, 
        426, 12, 5, 2, 2, 425, 427, 7, 31, 2, 2, 426, 425, 3, 2, 2, 2, 426, 427, 
        3, 2, 2, 2, 427, 428, 3, 2, 2, 2, 428, 429, 7, 29, 2, 2, 429, 459, 5, 58, 
        30, 6, 430, 432, 12, 4, 2, 2, 431, 433, 7, 31, 2, 2, 432, 431, 3, 2, 2, 
        2, 432, 433, 3, 2, 2, 2, 433, 434, 3, 2, 2, 2, 434, 435, 9, 9, 2, 2, 435, 
        459, 5, 58, 30, 5, 436, 438, 12, 10, 2, 2, 437, 439, 7, 31, 2, 2, 438, 
        437, 3, 2, 2, 2, 438, 439, 3, 2, 2, 2, 439, 440, 3, 2, 2, 2, 440, 441, 
        7, 23, 2, 2, 441, 444, 7, 77, 2, 2, 442, 445, 5, 4, 3, 2, 443, 445, 5, 
        42, 22, 2, 444, 442, 3, 2, 2, 2, 444, 443, 3, 2, 2, 2, 445, 446, 3, 2, 
        2, 2, 446, 447, 7, 78, 2, 2, 447, 459, 3, 2, 2, 2, 448, 449, 12, 9, 2, 
        2, 449, 450, 7, 26, 2, 2, 450, 459, 5, 36, 19, 2, 451, 452, 12, 7, 2, 2, 
        452, 453, 5, 64, 33, 2, 453, 454, 9, 10, 2, 2, 454, 455, 7, 77, 2, 2, 455, 
        456, 5, 4, 3, 2, 456, 457, 7, 78, 2, 2, 457, 459, 3, 2, 2, 2, 458, 411, 
        3, 2, 2, 2, 458, 415, 3, 2, 2, 2, 458, 424, 3, 2, 2, 2, 458, 430, 3, 2, 
        2, 2, 458, 436, 3, 2, 2, 2, 458, 448, 3, 2, 2, 2, 458, 451, 3, 2, 2, 2, 
        459, 462, 3, 2, 2, 2, 460, 458, 3, 2, 2, 2, 460, 461, 3, 2, 2, 2, 461, 
        59, 3, 2, 2, 2, 462, 460, 3, 2, 2, 2, 463, 464, 8, 31, 1, 2, 464, 491, 
        5, 38, 20, 2, 465, 491, 5, 32, 17, 2, 466, 491, 5, 44, 23, 2, 467, 468, 
        5, 62, 32, 2, 468, 469, 5, 60, 31, 8, 469, 491, 3, 2, 2, 2, 470, 471, 7, 
        77, 2, 2, 471, 476, 5, 56, 29, 2, 472, 473, 7, 79, 2, 2, 473, 475, 5, 56, 
        29, 2, 474, 472, 3, 2, 2, 2, 475, 478, 3, 2, 2, 2, 476, 474, 3, 2, 2, 2, 
        476, 477, 3, 2, 2, 2, 477, 479, 3, 2, 2, 2, 478, 476, 3, 2, 2, 2, 479, 
        480, 7, 78, 2, 2, 480, 491, 3, 2, 2, 2, 481, 482, 7, 18, 2, 2, 482, 483, 
        7, 77, 2, 2, 483, 484, 5, 4, 3, 2, 484, 485, 7, 78, 2, 2, 485, 491, 3, 
        2, 2, 2, 486, 487, 7, 77, 2, 2, 487, 488, 5, 4, 3, 2, 488, 489, 7, 78, 
        2, 2, 489, 491, 3, 2, 2, 2, 490, 463, 3, 2, 2, 2, 490, 465, 3, 2, 2, 2, 
        490, 466, 3, 2, 2, 2, 490, 467, 3, 2, 2, 2, 490, 470, 3, 2, 2, 2, 490, 
        481, 3, 2, 2, 2, 490, 486, 3, 2, 2, 2, 491, 501, 3, 2, 2, 2, 492, 493, 
        12, 4, 2, 2, 493, 494, 9, 11, 2, 2, 494, 500, 5, 60, 31, 5, 495, 496, 12, 
        3, 2, 2, 496, 497, 5, 68, 35, 2, 497, 498, 5, 60, 31, 4, 498, 500, 3, 2, 
        2, 2, 499, 492, 3, 2, 2, 2, 499, 495, 3, 2, 2, 2, 500, 503, 3, 2, 2, 2, 
        501, 499, 3, 2, 2, 2, 501, 502, 3, 2, 2, 2, 502, 61, 3, 2, 2, 2, 503, 501, 
        3, 2, 2, 2, 504, 505, 9, 12, 2, 2, 505, 63, 3, 2, 2, 2, 506, 521, 7, 68, 
        2, 2, 507, 521, 7, 69, 2, 2, 508, 521, 7, 70, 2, 2, 509, 510, 7, 70, 2, 
        2, 510, 521, 7, 68, 2, 2, 511, 512, 7, 69, 2, 2, 512, 521, 7, 68, 2, 2, 
        513, 514, 7, 70, 2, 2, 514, 521, 7, 69, 2, 2, 515, 516, 7, 71, 2, 2, 516, 
        521, 7, 68, 2, 2, 517, 518, 7, 70, 2, 2, 518, 519, 7, 68, 2, 2, 519, 521, 
        7, 69, 2, 2, 520, 506, 3, 2, 2, 2, 520, 507, 3, 2, 2, 2, 520, 508, 3, 2, 
        2, 2, 520, 509, 3, 2, 2, 2, 520, 511, 3, 2, 2, 2, 520, 513, 3, 2, 2, 2, 
        520, 515, 3, 2, 2, 2, 520, 517, 3, 2, 2, 2, 521, 65, 3, 2, 2, 2, 522, 523, 
        9, 13, 2, 2, 523, 67, 3, 2, 2, 2, 524, 525, 9, 14, 2, 2, 525, 69, 3, 2, 
        2, 2, 526, 528, 7, 49, 2, 2, 527, 529, 7, 54, 2, 2, 528, 527, 3, 2, 2, 
        2, 528, 529, 3, 2, 2, 2, 529, 531, 3, 2, 2, 2, 530, 532, 7, 25, 2, 2, 531, 
        530, 3, 2, 2, 2, 531, 532, 3, 2, 2, 2, 532, 533, 3, 2, 2, 2, 533, 538, 
        7, 85, 2, 2, 534, 535, 7, 77, 2, 2, 535, 536, 5, 40, 21, 2, 536, 537, 7, 
        78, 2, 2, 537, 539, 3, 2, 2, 2, 538, 534, 3, 2, 2, 2, 538, 539, 3, 2, 2, 
        2, 539, 540, 3, 2, 2, 2, 540, 541, 5, 72, 37, 2, 541, 71, 3, 2, 2, 2, 542, 
        558, 5, 4, 3, 2, 543, 544, 9, 15, 2, 2, 544, 545, 7, 77, 2, 2, 545, 546, 
        5, 76, 39, 2, 546, 554, 7, 78, 2, 2, 547, 548, 7, 79, 2, 2, 548, 549, 7, 
        77, 2, 2, 549, 550, 5, 76, 39, 2, 550, 551, 7, 78, 2, 2, 551, 553, 3, 2, 
        2, 2, 552, 547, 3, 2, 2, 2, 553, 556, 3, 2, 2, 2, 554, 552, 3, 2, 2, 2, 
        554, 555, 3, 2, 2, 2, 555, 558, 3, 2, 2, 2, 556, 554, 3, 2, 2, 2, 557, 
        542, 3, 2, 2, 2, 557, 543, 3, 2, 2, 2, 558, 73, 3, 2, 2, 2, 559, 560, 5, 
        32, 17, 2, 560, 561, 7, 68, 2, 2, 561, 562, 5, 78, 40, 2, 562, 75, 3, 2, 
        2, 2, 563, 568, 5, 78, 40, 2, 564, 565, 7, 79, 2, 2, 565, 567, 5, 78, 40, 
        2, 566, 564, 3, 2, 2, 2, 567, 570, 3, 2, 2, 2, 568, 566, 3, 2, 2, 2, 568, 
        569, 3, 2, 2, 2, 569, 77, 3, 2, 2, 2, 570, 568, 3, 2, 2, 2, 571, 574, 5, 
        56, 29, 2, 572, 574, 7, 53, 2, 2, 573, 571, 3, 2, 2, 2, 573, 572, 3, 2, 
        2, 2, 574, 79, 3, 2, 2, 2, 575, 577, 7, 48, 2, 2, 576, 578, 7, 54, 2, 2, 
        577, 576, 3, 2, 2, 2, 577, 578, 3, 2, 2, 2, 578, 579, 3, 2, 2, 2, 579, 
        580, 7, 20, 2, 2, 580, 583, 7, 85, 2, 2, 581, 582, 7, 47, 2, 2, 582, 584, 
        5, 56, 29, 2, 583, 581, 3, 2, 2, 2, 583, 584, 3, 2, 2, 2, 584, 586, 3, 
        2, 2, 2, 585, 587, 5, 6, 4, 2, 586, 585, 3, 2, 2, 2, 586, 587, 3, 2, 2, 
        2, 587, 589, 3, 2, 2, 2, 588, 590, 5, 30, 16, 2, 589, 588, 3, 2, 2, 2, 
        589, 590, 3, 2, 2, 2, 590, 81, 3, 2, 2, 2, 591, 593, 7, 51, 2, 2, 592, 
        594, 7, 54, 2, 2, 593, 592, 3, 2, 2, 2, 593, 594, 3, 2, 2, 2, 594, 595, 
        3, 2, 2, 2, 595, 600, 7, 85, 2, 2, 596, 598, 7, 9, 2, 2, 597, 596, 3, 2, 
        2, 2, 597, 598, 3, 2, 2, 2, 598, 599, 3, 2, 2, 2, 599, 601, 7, 85, 2, 2, 
        600, 597, 3, 2, 2, 2, 600, 601, 3, 2, 2, 2, 601, 602, 3, 2, 2, 2, 602, 
        603, 7, 50, 2, 2, 603, 608, 5, 74, 38, 2, 604, 605, 7, 79, 2, 2, 605, 607, 
        5, 74, 38, 2, 606, 604, 3, 2, 2, 2, 607, 610, 3, 2, 2, 2, 608, 606, 3, 
        2, 2, 2, 608, 609, 3, 2, 2, 2, 609, 613, 3, 2, 2, 2, 610, 608, 3, 2, 2, 
        2, 611, 612, 7, 47, 2, 2, 612, 614, 5, 56, 29, 2, 613, 611, 3, 2, 2, 2, 
        613, 614, 3, 2, 2, 2, 614, 616, 3, 2, 2, 2, 615, 617, 5, 6, 4, 2, 616, 
        615, 3, 2, 2, 2, 616, 617, 3, 2, 2, 2, 617, 619, 3, 2, 2, 2, 618, 620, 
        5, 30, 16, 2, 619, 618, 3, 2, 2, 2, 619, 620, 3, 2, 2, 2, 620, 83, 3, 2, 
        2, 2, 90, 88, 92, 101, 106, 112, 120, 125, 132, 137, 140, 147, 150, 158, 
        161, 167, 171, 182, 184, 194, 198, 202, 205, 208, 212, 218, 223, 226, 230, 
        233, 237, 240, 242, 248, 257, 262, 264, 268, 273, 279, 285, 291, 302, 305, 
        312, 320, 327, 330, 337, 341, 349, 353, 357, 369, 378, 384, 392, 397, 405, 
        417, 426, 432, 438, 444, 458, 460, 476, 490, 499, 501, 520, 528, 531, 538, 
        554, 557, 568, 573, 577, 583, 586, 589, 593, 597, 600, 608, 613, 616, 619,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
        "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
        "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
        "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
        "", "", "", "", "'*'", "'/'", "'%'", "'+'", "'--'", "'-'", "", "", "'='", 
        "'&gt;'", "'&lt;'", "'!'", "'~'", "'|'", "'&amp;'", "'^'", "'.'", "'('", "')'", "','",
}
var symbolicNames = []string{
        "", "SPACE", "SPEC_MYSQL_COMMENT", "COMMENT_INPUT", "LINE_COMMENT", "ALL", 
        "AND", "AS", "ASC", "BETWEEN", "BY", "CASE", "CROSS", "DESC", "DISTINCT", 
        "ELSE", "EXISTS", "FALSE", "FROM", "GROUP", "HAVING", "IN", "INNER", "INTO", 
        "IS", "JOIN", "LEFT", "LIKE", "LIMIT", "NOT", "NULL_LITERAL", "ON", "OR", 
        "ORDER", "OUTER", "REGEXP", "RIGHT", "RLIKE", "SELECT", "THEN", "TRUE", 
        "UNION", "USING", "VALUES", "WHEN", "WHERE", "DELETE", "INSERT", "SET", 
        "UPDATE", "VALUE", "DEFAULT", "IGNORE", "ANY", "END", "OFFSET", "SOME", 
        "UNKNOWN", "STAR", "DIVIDE", "MODULE", "PLUS", "MINUSMINUS", "MINUS", "DIV", 
        "MOD", "EQUAL_SYMBOL", "GREATER_SYMBOL", "LESS_SYMBOL", "EXCLAMATION_SYMBOL", 
        "BIT_NOT_OP", "BIT_OR_OP", "BIT_AND_OP", "BIT_XOR_OP", "DOT", "LR_BRACKET", 
        "RR_BRACKET", "COMMA", "STRING_LITERAL", "DECIMAL_LITERAL", "REAL_LITERAL", 
        "NULL_SPEC_LITERAL", "DOT_ID", "ID", "ERROR_RECONGNIGION",
}

var ruleNames = []string{
        "dmlStatement", "selectStatement", "orderByClause", "orderByExpression", 
        "tableSource", "tableSources", "tableSourceItem", "joinPart", "queryExpression", 
        "querySpecification", "selectElements", "selectElement", "fromClause", 
        "groupByItem", "limitClause", "fullColumnName", "booleanLiteral", "nullNotnull", 
        "constant", "uidList", "expressions", "functionCall", "specificFunction", 
        "caseFuncAlternative", "functionArgs", "allFunctionArg", "functionArg", 
        "expression", "predicate", "expressionAtom", "unaryOperator", "comparisonOperator", 
        "logicalOperator", "mathOperator", "insertStatement", "insertStatementValue", 
        "updatedElement", "expressionsWithDefaults", "expressionOrDefault", "deleteStatement", 
        "updateStatement",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() <span class="cov8" title="1">{
        for index, ds := range deserializedATN.DecisionToState </span><span class="cov8" title="1">{
                decisionToDFA[index] = antlr.NewDFA(ds, index)
        }</span>
}

type MySqlParser struct {
        *antlr.BaseParser
}

func NewMySqlParser(input antlr.TokenStream) *MySqlParser <span class="cov8" title="1">{
        this := new(MySqlParser)

        this.BaseParser = antlr.NewBaseParser(input)

        this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
        this.RuleNames = ruleNames
        this.LiteralNames = literalNames
        this.SymbolicNames = symbolicNames
        this.GrammarFileName = "MySqlParser.g4"

        return this
}</span>

// MySqlParser tokens.
const (
        MySqlParserEOF = antlr.TokenEOF
        MySqlParserSPACE = 1
        MySqlParserSPEC_MYSQL_COMMENT = 2
        MySqlParserCOMMENT_INPUT = 3
        MySqlParserLINE_COMMENT = 4
        MySqlParserALL = 5
        MySqlParserAND = 6
        MySqlParserAS = 7
        MySqlParserASC = 8
        MySqlParserBETWEEN = 9
        MySqlParserBY = 10
        MySqlParserCASE = 11
        MySqlParserCROSS = 12
        MySqlParserDESC = 13
        MySqlParserDISTINCT = 14
        MySqlParserELSE = 15
        MySqlParserEXISTS = 16
        MySqlParserFALSE = 17
        MySqlParserFROM = 18
        MySqlParserGROUP = 19
        MySqlParserHAVING = 20
        MySqlParserIN = 21
        MySqlParserINNER = 22
        MySqlParserINTO = 23
        MySqlParserIS = 24
        MySqlParserJOIN = 25
        MySqlParserLEFT = 26
        MySqlParserLIKE = 27
        MySqlParserLIMIT = 28
        MySqlParserNOT = 29
        MySqlParserNULL_LITERAL = 30
        MySqlParserON = 31
        MySqlParserOR = 32
        MySqlParserORDER = 33
        MySqlParserOUTER = 34
        MySqlParserREGEXP = 35
        MySqlParserRIGHT = 36
        MySqlParserRLIKE = 37
        MySqlParserSELECT = 38
        MySqlParserTHEN = 39
        MySqlParserTRUE = 40
        MySqlParserUNION = 41
        MySqlParserUSING = 42
        MySqlParserVALUES = 43
        MySqlParserWHEN = 44
        MySqlParserWHERE = 45
        MySqlParserDELETE = 46
        MySqlParserINSERT = 47
        MySqlParserSET = 48
        MySqlParserUPDATE = 49
        MySqlParserVALUE = 50
        MySqlParserDEFAULT = 51
        MySqlParserIGNORE = 52
        MySqlParserANY = 53
        MySqlParserEND = 54
        MySqlParserOFFSET = 55
        MySqlParserSOME = 56
        MySqlParserUNKNOWN = 57
        MySqlParserSTAR = 58
        MySqlParserDIVIDE = 59
        MySqlParserMODULE = 60
        MySqlParserPLUS = 61
        MySqlParserMINUSMINUS = 62
        MySqlParserMINUS = 63
        MySqlParserDIV = 64
        MySqlParserMOD = 65
        MySqlParserEQUAL_SYMBOL = 66
        MySqlParserGREATER_SYMBOL = 67
        MySqlParserLESS_SYMBOL = 68
        MySqlParserEXCLAMATION_SYMBOL = 69
        MySqlParserBIT_NOT_OP = 70
        MySqlParserBIT_OR_OP = 71
        MySqlParserBIT_AND_OP = 72
        MySqlParserBIT_XOR_OP = 73
        MySqlParserDOT = 74
        MySqlParserLR_BRACKET = 75
        MySqlParserRR_BRACKET = 76
        MySqlParserCOMMA = 77
        MySqlParserSTRING_LITERAL = 78
        MySqlParserDECIMAL_LITERAL = 79
        MySqlParserREAL_LITERAL = 80
        MySqlParserNULL_SPEC_LITERAL = 81
        MySqlParserDOT_ID = 82
        MySqlParserID = 83
        MySqlParserERROR_RECONGNIGION = 84
)

// MySqlParser rules.
const (
        MySqlParserRULE_dmlStatement = 0
        MySqlParserRULE_selectStatement = 1
        MySqlParserRULE_orderByClause = 2
        MySqlParserRULE_orderByExpression = 3
        MySqlParserRULE_tableSource = 4
        MySqlParserRULE_tableSources = 5
        MySqlParserRULE_tableSourceItem = 6
        MySqlParserRULE_joinPart = 7
        MySqlParserRULE_queryExpression = 8
        MySqlParserRULE_querySpecification = 9
        MySqlParserRULE_selectElements = 10
        MySqlParserRULE_selectElement = 11
        MySqlParserRULE_fromClause = 12
        MySqlParserRULE_groupByItem = 13
        MySqlParserRULE_limitClause = 14
        MySqlParserRULE_fullColumnName = 15
        MySqlParserRULE_booleanLiteral = 16
        MySqlParserRULE_nullNotnull = 17
        MySqlParserRULE_constant = 18
        MySqlParserRULE_uidList = 19
        MySqlParserRULE_expressions = 20
        MySqlParserRULE_functionCall = 21
        MySqlParserRULE_specificFunction = 22
        MySqlParserRULE_caseFuncAlternative = 23
        MySqlParserRULE_functionArgs = 24
        MySqlParserRULE_allFunctionArg = 25
        MySqlParserRULE_functionArg = 26
        MySqlParserRULE_expression = 27
        MySqlParserRULE_predicate = 28
        MySqlParserRULE_expressionAtom = 29
        MySqlParserRULE_unaryOperator = 30
        MySqlParserRULE_comparisonOperator = 31
        MySqlParserRULE_logicalOperator = 32
        MySqlParserRULE_mathOperator = 33
        MySqlParserRULE_insertStatement = 34
        MySqlParserRULE_insertStatementValue = 35
        MySqlParserRULE_updatedElement = 36
        MySqlParserRULE_expressionsWithDefaults = 37
        MySqlParserRULE_expressionOrDefault = 38
        MySqlParserRULE_deleteStatement = 39
        MySqlParserRULE_updateStatement = 40
)

// IDmlStatementContext is an interface to support dynamic dispatch.
type IDmlStatementContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // IsDmlStatementContext differentiates from other interfaces.
        IsDmlStatementContext()
}

type DmlStatementContext struct {
        *antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyDmlStatementContext() *DmlStatementContext <span class="cov0" title="0">{
        var p = new(DmlStatementContext)
        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
        p.RuleIndex = MySqlParserRULE_dmlStatement
        return p
}</span>

func (*DmlStatementContext) IsDmlStatementContext() {<span class="cov0" title="0">}</span>

func NewDmlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DmlStatementContext <span class="cov8" title="1">{
        var p = new(DmlStatementContext)

        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

        p.parser = parser
        p.RuleIndex = MySqlParserRULE_dmlStatement

        return p
}</span>

func (s *DmlStatementContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *DmlStatementContext) QuerySpecification() IQuerySpecificationContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuerySpecificationContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(IQuerySpecificationContext)</span>
}

func (s *DmlStatementContext) InsertStatement() IInsertStatementContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IInsertStatementContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(IInsertStatementContext)</span>
}

func (s *DmlStatementContext) UpdateStatement() IUpdateStatementContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IUpdateStatementContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(IUpdateStatementContext)</span>
}

func (s *DmlStatementContext) DeleteStatement() IDeleteStatementContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeleteStatementContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(IDeleteStatementContext)</span>
}

func (s *DmlStatementContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *DmlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>


func (s *DmlStatementContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterDmlStatement(s)
        }</span>
}

func (s *DmlStatementContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitDmlStatement(s)
        }</span>
}

func (s *DmlStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitDmlStatement(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}




func (p *MySqlParser) DmlStatement() (localctx IDmlStatementContext) <span class="cov8" title="1">{
        localctx = NewDmlStatementContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 0, MySqlParserRULE_dmlStatement)

        defer func() </span><span class="cov8" title="1">{
                p.ExitRule()
        }</span>()

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        if v, ok := err.(antlr.RecognitionException); ok </span><span class="cov0" title="0">{
                                localctx.SetException(v)
                                p.GetErrorHandler().ReportError(p, v)
                                p.GetErrorHandler().Recover(p, v)
                        }</span> else<span class="cov0" title="0"> {
                                panic(err)</span>
                        }
                }
        }()

        <span class="cov8" title="1">p.SetState(86)
        p.GetErrorHandler().Sync(p)

        switch p.GetTokenStream().LA(1) </span>{
        case MySqlParserSELECT:<span class="cov8" title="1">
                p.EnterOuterAlt(localctx, 1)
                </span><span class="cov8" title="1">{
                        p.SetState(82)
                        p.QuerySpecification()
                }</span>


        case MySqlParserINSERT:<span class="cov8" title="1">
                p.EnterOuterAlt(localctx, 2)
                </span><span class="cov8" title="1">{
                        p.SetState(83)
                        p.InsertStatement()
                }</span>


        case MySqlParserUPDATE:<span class="cov8" title="1">
                p.EnterOuterAlt(localctx, 3)
                </span><span class="cov8" title="1">{
                        p.SetState(84)
                        p.UpdateStatement()
                }</span>


        case MySqlParserDELETE:<span class="cov8" title="1">
                p.EnterOuterAlt(localctx, 4)
                </span><span class="cov8" title="1">{
                        p.SetState(85)
                        p.DeleteStatement()
                }</span>



        default:<span class="cov0" title="0">
                panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))</span>
        }


        <span class="cov8" title="1">return localctx</span>
}


// ISelectStatementContext is an interface to support dynamic dispatch.
type ISelectStatementContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // IsSelectStatementContext differentiates from other interfaces.
        IsSelectStatementContext()
}

type SelectStatementContext struct {
        *antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptySelectStatementContext() *SelectStatementContext <span class="cov8" title="1">{
        var p = new(SelectStatementContext)
        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
        p.RuleIndex = MySqlParserRULE_selectStatement
        return p
}</span>

func (*SelectStatementContext) IsSelectStatementContext() {<span class="cov0" title="0">}</span>

func NewSelectStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectStatementContext <span class="cov8" title="1">{
        var p = new(SelectStatementContext)

        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

        p.parser = parser
        p.RuleIndex = MySqlParserRULE_selectStatement

        return p
}</span>

func (s *SelectStatementContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *SelectStatementContext) CopyFrom(ctx *SelectStatementContext) <span class="cov8" title="1">{
        s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}</span>

func (s *SelectStatementContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *SelectStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>




type SimpleSelectContext struct {
        *SelectStatementContext
}

func NewSimpleSelectContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleSelectContext <span class="cov8" title="1">{
        var p = new(SimpleSelectContext)

        p.SelectStatementContext = NewEmptySelectStatementContext()
        p.parser = parser
        p.CopyFrom(ctx.(*SelectStatementContext))

        return p
}</span>

func (s *SimpleSelectContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *SimpleSelectContext) QuerySpecification() IQuerySpecificationContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuerySpecificationContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(IQuerySpecificationContext)</span>
}


func (s *SimpleSelectContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterSimpleSelect(s)
        }</span>
}

func (s *SimpleSelectContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitSimpleSelect(s)
        }</span>
}

func (s *SimpleSelectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitSimpleSelect(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}


type ParenthesisSelectContext struct {
        *SelectStatementContext
}

func NewParenthesisSelectContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesisSelectContext <span class="cov0" title="0">{
        var p = new(ParenthesisSelectContext)

        p.SelectStatementContext = NewEmptySelectStatementContext()
        p.parser = parser
        p.CopyFrom(ctx.(*SelectStatementContext))

        return p
}</span>

func (s *ParenthesisSelectContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *ParenthesisSelectContext) QueryExpression() IQueryExpressionContext <span class="cov0" title="0">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryExpressionContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IQueryExpressionContext)</span>
}


func (s *ParenthesisSelectContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterParenthesisSelect(s)
        }</span>
}

func (s *ParenthesisSelectContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitParenthesisSelect(s)
        }</span>
}

func (s *ParenthesisSelectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitParenthesisSelect(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}



func (p *MySqlParser) SelectStatement() (localctx ISelectStatementContext) <span class="cov8" title="1">{
        localctx = NewSelectStatementContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 2, MySqlParserRULE_selectStatement)

        defer func() </span><span class="cov8" title="1">{
                p.ExitRule()
        }</span>()

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        if v, ok := err.(antlr.RecognitionException); ok </span><span class="cov0" title="0">{
                                localctx.SetException(v)
                                p.GetErrorHandler().ReportError(p, v)
                                p.GetErrorHandler().Recover(p, v)
                        }</span> else<span class="cov0" title="0"> {
                                panic(err)</span>
                        }
                }
        }()

        <span class="cov8" title="1">p.SetState(90)
        p.GetErrorHandler().Sync(p)

        switch p.GetTokenStream().LA(1) </span>{
        case MySqlParserSELECT:<span class="cov8" title="1">
                localctx = NewSimpleSelectContext(p, localctx)
                p.EnterOuterAlt(localctx, 1)
                </span><span class="cov8" title="1">{
                        p.SetState(88)
                        p.QuerySpecification()
                }</span>


        case MySqlParserLR_BRACKET:<span class="cov0" title="0">
                localctx = NewParenthesisSelectContext(p, localctx)
                p.EnterOuterAlt(localctx, 2)
                </span><span class="cov0" title="0">{
                        p.SetState(89)
                        p.QueryExpression()
                }</span>



        default:<span class="cov0" title="0">
                panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))</span>
        }


        <span class="cov8" title="1">return localctx</span>
}


// IOrderByClauseContext is an interface to support dynamic dispatch.
type IOrderByClauseContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // IsOrderByClauseContext differentiates from other interfaces.
        IsOrderByClauseContext()
}

type OrderByClauseContext struct {
        *antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyOrderByClauseContext() *OrderByClauseContext <span class="cov0" title="0">{
        var p = new(OrderByClauseContext)
        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
        p.RuleIndex = MySqlParserRULE_orderByClause
        return p
}</span>

func (*OrderByClauseContext) IsOrderByClauseContext() {<span class="cov0" title="0">}</span>

func NewOrderByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderByClauseContext <span class="cov8" title="1">{
        var p = new(OrderByClauseContext)

        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

        p.parser = parser
        p.RuleIndex = MySqlParserRULE_orderByClause

        return p
}</span>

func (s *OrderByClauseContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *OrderByClauseContext) ORDER() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserORDER, 0)
}</span>

func (s *OrderByClauseContext) BY() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserBY, 0)
}</span>

func (s *OrderByClauseContext) AllOrderByExpression() []IOrderByExpressionContext <span class="cov8" title="1">{
        var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOrderByExpressionContext)(nil)).Elem())
        var tst = make([]IOrderByExpressionContext, len(ts))

        for i, t := range ts </span><span class="cov8" title="1">{
                if t != nil </span><span class="cov8" title="1">{
                        tst[i] = t.(IOrderByExpressionContext)
                }</span>
        }

        <span class="cov8" title="1">return tst</span>
}

func (s *OrderByClauseContext) OrderByExpression(i int) IOrderByExpressionContext <span class="cov0" title="0">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrderByExpressionContext)(nil)).Elem(), i)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IOrderByExpressionContext)</span>
}

func (s *OrderByClauseContext) AllCOMMA() []antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetTokens(MySqlParserCOMMA)
}</span>

func (s *OrderByClauseContext) COMMA(i int) antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserCOMMA, i)
}</span>

func (s *OrderByClauseContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *OrderByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>


func (s *OrderByClauseContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterOrderByClause(s)
        }</span>
}

func (s *OrderByClauseContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitOrderByClause(s)
        }</span>
}

func (s *OrderByClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitOrderByClause(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}




func (p *MySqlParser) OrderByClause() (localctx IOrderByClauseContext) <span class="cov8" title="1">{
        localctx = NewOrderByClauseContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 4, MySqlParserRULE_orderByClause)
        var _la int


        defer func() </span><span class="cov8" title="1">{
                p.ExitRule()
        }</span>()

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        if v, ok := err.(antlr.RecognitionException); ok </span><span class="cov0" title="0">{
                                localctx.SetException(v)
                                p.GetErrorHandler().ReportError(p, v)
                                p.GetErrorHandler().Recover(p, v)
                        }</span> else<span class="cov0" title="0"> {
                                panic(err)</span>
                        }
                }
        }()

        <span class="cov8" title="1">p.EnterOuterAlt(localctx, 1)
        </span><span class="cov8" title="1">{
                p.SetState(92)
                p.Match(MySqlParserORDER)
        }</span>
        <span class="cov8" title="1">{
                p.SetState(93)
                p.Match(MySqlParserBY)
        }</span>
        <span class="cov8" title="1">{
                p.SetState(94)
                p.OrderByExpression()
        }</span>
        <span class="cov8" title="1">p.SetState(99)
        p.GetErrorHandler().Sync(p)
        _la = p.GetTokenStream().LA(1)


        for _la == MySqlParserCOMMA </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        p.SetState(95)
                        p.Match(MySqlParserCOMMA)
                }</span>
                <span class="cov8" title="1">{
                        p.SetState(96)
                        p.OrderByExpression()
                }</span>


                <span class="cov8" title="1">p.SetState(101)
                p.GetErrorHandler().Sync(p)
                _la = p.GetTokenStream().LA(1)</span>
        }



        <span class="cov8" title="1">return localctx</span>
}


// IOrderByExpressionContext is an interface to support dynamic dispatch.
type IOrderByExpressionContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // GetOrder returns the order token.
        GetOrder() antlr.Token 


        // SetOrder sets the order token.
        SetOrder(antlr.Token) 


        // IsOrderByExpressionContext differentiates from other interfaces.
        IsOrderByExpressionContext()
}

type OrderByExpressionContext struct {
        *antlr.BaseParserRuleContext
        parser antlr.Parser
        order antlr.Token
}

func NewEmptyOrderByExpressionContext() *OrderByExpressionContext <span class="cov0" title="0">{
        var p = new(OrderByExpressionContext)
        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
        p.RuleIndex = MySqlParserRULE_orderByExpression
        return p
}</span>

func (*OrderByExpressionContext) IsOrderByExpressionContext() {<span class="cov0" title="0">}</span>

func NewOrderByExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderByExpressionContext <span class="cov8" title="1">{
        var p = new(OrderByExpressionContext)

        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

        p.parser = parser
        p.RuleIndex = MySqlParserRULE_orderByExpression

        return p
}</span>

func (s *OrderByExpressionContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *OrderByExpressionContext) GetOrder() antlr.Token <span class="cov0" title="0">{ return s.order }</span>


func (s *OrderByExpressionContext) SetOrder(v antlr.Token) <span class="cov0" title="0">{ s.order = v }</span>


func (s *OrderByExpressionContext) Expression() IExpressionContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(IExpressionContext)</span>
}

func (s *OrderByExpressionContext) ASC() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserASC, 0)
}</span>

func (s *OrderByExpressionContext) DESC() antlr.TerminalNode <span class="cov8" title="1">{
        return s.GetToken(MySqlParserDESC, 0)
}</span>

func (s *OrderByExpressionContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *OrderByExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>


func (s *OrderByExpressionContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterOrderByExpression(s)
        }</span>
}

func (s *OrderByExpressionContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitOrderByExpression(s)
        }</span>
}

func (s *OrderByExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitOrderByExpression(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}




func (p *MySqlParser) OrderByExpression() (localctx IOrderByExpressionContext) <span class="cov8" title="1">{
        localctx = NewOrderByExpressionContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 6, MySqlParserRULE_orderByExpression)
        var _la int


        defer func() </span><span class="cov8" title="1">{
                p.ExitRule()
        }</span>()

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        if v, ok := err.(antlr.RecognitionException); ok </span><span class="cov0" title="0">{
                                localctx.SetException(v)
                                p.GetErrorHandler().ReportError(p, v)
                                p.GetErrorHandler().Recover(p, v)
                        }</span> else<span class="cov0" title="0"> {
                                panic(err)</span>
                        }
                }
        }()

        <span class="cov8" title="1">p.EnterOuterAlt(localctx, 1)
        </span><span class="cov8" title="1">{
                p.SetState(102)
                p.expression(0)
        }</span>
        <span class="cov8" title="1">p.SetState(104)
        p.GetErrorHandler().Sync(p)
        _la = p.GetTokenStream().LA(1)


        if _la == MySqlParserASC || _la == MySqlParserDESC </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        p.SetState(103)

                        var _lt = p.GetTokenStream().LT(1)

                        localctx.(*OrderByExpressionContext).order = _lt

                        _la = p.GetTokenStream().LA(1)

                        if !(_la == MySqlParserASC || _la == MySqlParserDESC) </span><span class="cov0" title="0">{
                                var _ri = p.GetErrorHandler().RecoverInline(p)

                                localctx.(*OrderByExpressionContext).order = _ri
                        }</span> else<span class="cov8" title="1"> {
                                p.GetErrorHandler().ReportMatch(p)
                                p.Consume()
                        }</span>
                }

        }



        <span class="cov8" title="1">return localctx</span>
}


// ITableSourceContext is an interface to support dynamic dispatch.
type ITableSourceContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // IsTableSourceContext differentiates from other interfaces.
        IsTableSourceContext()
}

type TableSourceContext struct {
        *antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyTableSourceContext() *TableSourceContext <span class="cov8" title="1">{
        var p = new(TableSourceContext)
        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
        p.RuleIndex = MySqlParserRULE_tableSource
        return p
}</span>

func (*TableSourceContext) IsTableSourceContext() {<span class="cov0" title="0">}</span>

func NewTableSourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableSourceContext <span class="cov8" title="1">{
        var p = new(TableSourceContext)

        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

        p.parser = parser
        p.RuleIndex = MySqlParserRULE_tableSource

        return p
}</span>

func (s *TableSourceContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *TableSourceContext) CopyFrom(ctx *TableSourceContext) <span class="cov8" title="1">{
        s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}</span>

func (s *TableSourceContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *TableSourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>




type TableSourceNestedContext struct {
        *TableSourceContext
}

func NewTableSourceNestedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableSourceNestedContext <span class="cov0" title="0">{
        var p = new(TableSourceNestedContext)

        p.TableSourceContext = NewEmptyTableSourceContext()
        p.parser = parser
        p.CopyFrom(ctx.(*TableSourceContext))

        return p
}</span>

func (s *TableSourceNestedContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *TableSourceNestedContext) LR_BRACKET() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserLR_BRACKET, 0)
}</span>

func (s *TableSourceNestedContext) TableSourceItem() ITableSourceItemContext <span class="cov0" title="0">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableSourceItemContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(ITableSourceItemContext)</span>
}

func (s *TableSourceNestedContext) RR_BRACKET() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserRR_BRACKET, 0)
}</span>

func (s *TableSourceNestedContext) AllJoinPart() []IJoinPartContext <span class="cov0" title="0">{
        var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IJoinPartContext)(nil)).Elem())
        var tst = make([]IJoinPartContext, len(ts))

        for i, t := range ts </span><span class="cov0" title="0">{
                if t != nil </span><span class="cov0" title="0">{
                        tst[i] = t.(IJoinPartContext)
                }</span>
        }

        <span class="cov0" title="0">return tst</span>
}

func (s *TableSourceNestedContext) JoinPart(i int) IJoinPartContext <span class="cov0" title="0">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IJoinPartContext)(nil)).Elem(), i)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IJoinPartContext)</span>
}


func (s *TableSourceNestedContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterTableSourceNested(s)
        }</span>
}

func (s *TableSourceNestedContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitTableSourceNested(s)
        }</span>
}

func (s *TableSourceNestedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitTableSourceNested(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}


type TableSourceBaseContext struct {
        *TableSourceContext
}

func NewTableSourceBaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableSourceBaseContext <span class="cov8" title="1">{
        var p = new(TableSourceBaseContext)

        p.TableSourceContext = NewEmptyTableSourceContext()
        p.parser = parser
        p.CopyFrom(ctx.(*TableSourceContext))

        return p
}</span>

func (s *TableSourceBaseContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *TableSourceBaseContext) TableSourceItem() ITableSourceItemContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableSourceItemContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(ITableSourceItemContext)</span>
}

func (s *TableSourceBaseContext) AllJoinPart() []IJoinPartContext <span class="cov8" title="1">{
        var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IJoinPartContext)(nil)).Elem())
        var tst = make([]IJoinPartContext, len(ts))

        for i, t := range ts </span><span class="cov8" title="1">{
                if t != nil </span><span class="cov8" title="1">{
                        tst[i] = t.(IJoinPartContext)
                }</span>
        }

        <span class="cov8" title="1">return tst</span>
}

func (s *TableSourceBaseContext) JoinPart(i int) IJoinPartContext <span class="cov0" title="0">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IJoinPartContext)(nil)).Elem(), i)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IJoinPartContext)</span>
}


func (s *TableSourceBaseContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterTableSourceBase(s)
        }</span>
}

func (s *TableSourceBaseContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitTableSourceBase(s)
        }</span>
}

func (s *TableSourceBaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitTableSourceBase(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}



func (p *MySqlParser) TableSource() (localctx ITableSourceContext) <span class="cov8" title="1">{
        localctx = NewTableSourceContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 8, MySqlParserRULE_tableSource)
        var _la int


        defer func() </span><span class="cov8" title="1">{
                p.ExitRule()
        }</span>()

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        if v, ok := err.(antlr.RecognitionException); ok </span><span class="cov0" title="0">{
                                localctx.SetException(v)
                                p.GetErrorHandler().ReportError(p, v)
                                p.GetErrorHandler().Recover(p, v)
                        }</span> else<span class="cov0" title="0"> {
                                panic(err)</span>
                        }
                }
        }()

        <span class="cov8" title="1">p.SetState(123)
        p.GetErrorHandler().Sync(p)
        switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext()) </span>{
        case 1:<span class="cov8" title="1">
                localctx = NewTableSourceBaseContext(p, localctx)
                p.EnterOuterAlt(localctx, 1)
                </span><span class="cov8" title="1">{
                        p.SetState(106)
                        p.TableSourceItem()
                }</span>
                <span class="cov8" title="1">p.SetState(110)
                p.GetErrorHandler().Sync(p)
                _la = p.GetTokenStream().LA(1)


                for ((((_la - 12)) &amp; -(0x1f+1)) == 0 &amp;&amp; ((1 &lt;&lt; uint((_la - 12))) &amp; ((1 &lt;&lt; (MySqlParserCROSS - 12)) | (1 &lt;&lt; (MySqlParserINNER - 12)) | (1 &lt;&lt; (MySqlParserJOIN - 12)) | (1 &lt;&lt; (MySqlParserLEFT - 12)) | (1 &lt;&lt; (MySqlParserRIGHT - 12)))) != 0) </span><span class="cov8" title="1">{
                        </span><span class="cov8" title="1">{
                                p.SetState(107)
                                p.JoinPart()
                        }</span>


                        <span class="cov8" title="1">p.SetState(112)
                        p.GetErrorHandler().Sync(p)
                        _la = p.GetTokenStream().LA(1)</span>
                }


        case 2:<span class="cov0" title="0">
                localctx = NewTableSourceNestedContext(p, localctx)
                p.EnterOuterAlt(localctx, 2)
                </span><span class="cov0" title="0">{
                        p.SetState(113)
                        p.Match(MySqlParserLR_BRACKET)
                }</span>
                <span class="cov0" title="0">{
                        p.SetState(114)
                        p.TableSourceItem()
                }</span>
                <span class="cov0" title="0">p.SetState(118)
                p.GetErrorHandler().Sync(p)
                _la = p.GetTokenStream().LA(1)


                for ((((_la - 12)) &amp; -(0x1f+1)) == 0 &amp;&amp; ((1 &lt;&lt; uint((_la - 12))) &amp; ((1 &lt;&lt; (MySqlParserCROSS - 12)) | (1 &lt;&lt; (MySqlParserINNER - 12)) | (1 &lt;&lt; (MySqlParserJOIN - 12)) | (1 &lt;&lt; (MySqlParserLEFT - 12)) | (1 &lt;&lt; (MySqlParserRIGHT - 12)))) != 0) </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                p.SetState(115)
                                p.JoinPart()
                        }</span>


                        <span class="cov0" title="0">p.SetState(120)
                        p.GetErrorHandler().Sync(p)
                        _la = p.GetTokenStream().LA(1)</span>
                }
                <span class="cov0" title="0">{
                        p.SetState(121)
                        p.Match(MySqlParserRR_BRACKET)
                }</span>

        }


        <span class="cov8" title="1">return localctx</span>
}


// ITableSourcesContext is an interface to support dynamic dispatch.
type ITableSourcesContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // IsTableSourcesContext differentiates from other interfaces.
        IsTableSourcesContext()
}

type TableSourcesContext struct {
        *antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyTableSourcesContext() *TableSourcesContext <span class="cov0" title="0">{
        var p = new(TableSourcesContext)
        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
        p.RuleIndex = MySqlParserRULE_tableSources
        return p
}</span>

func (*TableSourcesContext) IsTableSourcesContext() {<span class="cov0" title="0">}</span>

func NewTableSourcesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableSourcesContext <span class="cov8" title="1">{
        var p = new(TableSourcesContext)

        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

        p.parser = parser
        p.RuleIndex = MySqlParserRULE_tableSources

        return p
}</span>

func (s *TableSourcesContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *TableSourcesContext) AllTableSource() []ITableSourceContext <span class="cov8" title="1">{
        var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITableSourceContext)(nil)).Elem())
        var tst = make([]ITableSourceContext, len(ts))

        for i, t := range ts </span><span class="cov8" title="1">{
                if t != nil </span><span class="cov8" title="1">{
                        tst[i] = t.(ITableSourceContext)
                }</span>
        }

        <span class="cov8" title="1">return tst</span>
}

func (s *TableSourcesContext) TableSource(i int) ITableSourceContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableSourceContext)(nil)).Elem(), i)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(ITableSourceContext)</span>
}

func (s *TableSourcesContext) AllCOMMA() []antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetTokens(MySqlParserCOMMA)
}</span>

func (s *TableSourcesContext) COMMA(i int) antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserCOMMA, i)
}</span>

func (s *TableSourcesContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *TableSourcesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>


func (s *TableSourcesContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterTableSources(s)
        }</span>
}

func (s *TableSourcesContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitTableSources(s)
        }</span>
}

func (s *TableSourcesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitTableSources(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}




func (p *MySqlParser) TableSources() (localctx ITableSourcesContext) <span class="cov8" title="1">{
        localctx = NewTableSourcesContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 10, MySqlParserRULE_tableSources)
        var _la int


        defer func() </span><span class="cov8" title="1">{
                p.ExitRule()
        }</span>()

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        if v, ok := err.(antlr.RecognitionException); ok </span><span class="cov0" title="0">{
                                localctx.SetException(v)
                                p.GetErrorHandler().ReportError(p, v)
                                p.GetErrorHandler().Recover(p, v)
                        }</span> else<span class="cov0" title="0"> {
                                panic(err)</span>
                        }
                }
        }()

        <span class="cov8" title="1">p.EnterOuterAlt(localctx, 1)
        </span><span class="cov8" title="1">{
                p.SetState(125)
                p.TableSource()
        }</span>
        <span class="cov8" title="1">p.SetState(130)
        p.GetErrorHandler().Sync(p)
        _la = p.GetTokenStream().LA(1)


        for _la == MySqlParserCOMMA </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        p.SetState(126)
                        p.Match(MySqlParserCOMMA)
                }</span>
                <span class="cov8" title="1">{
                        p.SetState(127)
                        p.TableSource()
                }</span>


                <span class="cov8" title="1">p.SetState(132)
                p.GetErrorHandler().Sync(p)
                _la = p.GetTokenStream().LA(1)</span>
        }



        <span class="cov8" title="1">return localctx</span>
}


// ITableSourceItemContext is an interface to support dynamic dispatch.
type ITableSourceItemContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // IsTableSourceItemContext differentiates from other interfaces.
        IsTableSourceItemContext()
}

type TableSourceItemContext struct {
        *antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyTableSourceItemContext() *TableSourceItemContext <span class="cov8" title="1">{
        var p = new(TableSourceItemContext)
        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
        p.RuleIndex = MySqlParserRULE_tableSourceItem
        return p
}</span>

func (*TableSourceItemContext) IsTableSourceItemContext() {<span class="cov0" title="0">}</span>

func NewTableSourceItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableSourceItemContext <span class="cov8" title="1">{
        var p = new(TableSourceItemContext)

        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

        p.parser = parser
        p.RuleIndex = MySqlParserRULE_tableSourceItem

        return p
}</span>

func (s *TableSourceItemContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *TableSourceItemContext) CopyFrom(ctx *TableSourceItemContext) <span class="cov8" title="1">{
        s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}</span>

func (s *TableSourceItemContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *TableSourceItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>




type SubqueryTableItemContext struct {
        *TableSourceItemContext
        parenthesisSubquery ISelectStatementContext 
        alias antlr.Token
}

func NewSubqueryTableItemContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryTableItemContext <span class="cov0" title="0">{
        var p = new(SubqueryTableItemContext)

        p.TableSourceItemContext = NewEmptyTableSourceItemContext()
        p.parser = parser
        p.CopyFrom(ctx.(*TableSourceItemContext))

        return p
}</span>


func (s *SubqueryTableItemContext) GetAlias() antlr.Token <span class="cov0" title="0">{ return s.alias }</span>


func (s *SubqueryTableItemContext) SetAlias(v antlr.Token) <span class="cov0" title="0">{ s.alias = v }</span>


func (s *SubqueryTableItemContext) GetParenthesisSubquery() ISelectStatementContext <span class="cov0" title="0">{ return s.parenthesisSubquery }</span>


func (s *SubqueryTableItemContext) SetParenthesisSubquery(v ISelectStatementContext) <span class="cov0" title="0">{ s.parenthesisSubquery = v }</span>

func (s *SubqueryTableItemContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *SubqueryTableItemContext) ID() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserID, 0)
}</span>

func (s *SubqueryTableItemContext) SelectStatement() ISelectStatementContext <span class="cov0" title="0">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectStatementContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(ISelectStatementContext)</span>
}

func (s *SubqueryTableItemContext) LR_BRACKET() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserLR_BRACKET, 0)
}</span>

func (s *SubqueryTableItemContext) RR_BRACKET() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserRR_BRACKET, 0)
}</span>

func (s *SubqueryTableItemContext) AS() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserAS, 0)
}</span>


func (s *SubqueryTableItemContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterSubqueryTableItem(s)
        }</span>
}

func (s *SubqueryTableItemContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitSubqueryTableItem(s)
        }</span>
}

func (s *SubqueryTableItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitSubqueryTableItem(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}


type AtomTableItemContext struct {
        *TableSourceItemContext
        alias antlr.Token
}

func NewAtomTableItemContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AtomTableItemContext <span class="cov8" title="1">{
        var p = new(AtomTableItemContext)

        p.TableSourceItemContext = NewEmptyTableSourceItemContext()
        p.parser = parser
        p.CopyFrom(ctx.(*TableSourceItemContext))

        return p
}</span>


func (s *AtomTableItemContext) GetAlias() antlr.Token <span class="cov0" title="0">{ return s.alias }</span>


func (s *AtomTableItemContext) SetAlias(v antlr.Token) <span class="cov0" title="0">{ s.alias = v }</span>

func (s *AtomTableItemContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *AtomTableItemContext) FullColumnName() IFullColumnNameContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IFullColumnNameContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(IFullColumnNameContext)</span>
}

func (s *AtomTableItemContext) ID() antlr.TerminalNode <span class="cov8" title="1">{
        return s.GetToken(MySqlParserID, 0)
}</span>

func (s *AtomTableItemContext) AS() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserAS, 0)
}</span>


func (s *AtomTableItemContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterAtomTableItem(s)
        }</span>
}

func (s *AtomTableItemContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitAtomTableItem(s)
        }</span>
}

func (s *AtomTableItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitAtomTableItem(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}


type TableSourcesItemContext struct {
        *TableSourceItemContext
}

func NewTableSourcesItemContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableSourcesItemContext <span class="cov0" title="0">{
        var p = new(TableSourcesItemContext)

        p.TableSourceItemContext = NewEmptyTableSourceItemContext()
        p.parser = parser
        p.CopyFrom(ctx.(*TableSourceItemContext))

        return p
}</span>

func (s *TableSourcesItemContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *TableSourcesItemContext) LR_BRACKET() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserLR_BRACKET, 0)
}</span>

func (s *TableSourcesItemContext) TableSources() ITableSourcesContext <span class="cov0" title="0">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableSourcesContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(ITableSourcesContext)</span>
}

func (s *TableSourcesItemContext) RR_BRACKET() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserRR_BRACKET, 0)
}</span>


func (s *TableSourcesItemContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterTableSourcesItem(s)
        }</span>
}

func (s *TableSourcesItemContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitTableSourcesItem(s)
        }</span>
}

func (s *TableSourcesItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitTableSourcesItem(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}



func (p *MySqlParser) TableSourceItem() (localctx ITableSourceItemContext) <span class="cov8" title="1">{
        localctx = NewTableSourceItemContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 12, MySqlParserRULE_tableSourceItem)
        var _la int


        defer func() </span><span class="cov8" title="1">{
                p.ExitRule()
        }</span>()

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        if v, ok := err.(antlr.RecognitionException); ok </span><span class="cov0" title="0">{
                                localctx.SetException(v)
                                p.GetErrorHandler().ReportError(p, v)
                                p.GetErrorHandler().Recover(p, v)
                        }</span> else<span class="cov0" title="0"> {
                                panic(err)</span>
                        }
                }
        }()

        <span class="cov8" title="1">p.SetState(156)
        p.GetErrorHandler().Sync(p)
        switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext()) </span>{
        case 1:<span class="cov8" title="1">
                localctx = NewAtomTableItemContext(p, localctx)
                p.EnterOuterAlt(localctx, 1)
                </span><span class="cov8" title="1">{
                        p.SetState(133)
                        p.FullColumnName()
                }</span>
                <span class="cov8" title="1">p.SetState(138)
                p.GetErrorHandler().Sync(p)


                if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 9, p.GetParserRuleContext()) == 1 </span><span class="cov8" title="1">{
                        p.SetState(135)
                        p.GetErrorHandler().Sync(p)
                        _la = p.GetTokenStream().LA(1)


                        if _la == MySqlParserAS </span><span class="cov8" title="1">{
                                </span><span class="cov8" title="1">{
                                        p.SetState(134)
                                        p.Match(MySqlParserAS)
                                }</span>

                        }
                        <span class="cov8" title="1">{
                                p.SetState(137)

                                var _m = p.Match(MySqlParserID)

                                localctx.(*AtomTableItemContext).alias = _m
                        }</span>


                }


        case 2:<span class="cov0" title="0">
                localctx = NewSubqueryTableItemContext(p, localctx)
                p.EnterOuterAlt(localctx, 2)
                p.SetState(145)
                p.GetErrorHandler().Sync(p)
                switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 10, p.GetParserRuleContext()) </span>{
                case 1:<span class="cov0" title="0">
                        </span><span class="cov0" title="0">{
                                p.SetState(140)
                                p.SelectStatement()
                        }</span>


                case 2:<span class="cov0" title="0">
                        </span><span class="cov0" title="0">{
                                p.SetState(141)
                                p.Match(MySqlParserLR_BRACKET)
                        }</span>
                        <span class="cov0" title="0">{
                                p.SetState(142)

                                var _x = p.SelectStatement()


                                localctx.(*SubqueryTableItemContext).parenthesisSubquery = _x
                        }</span>
                        <span class="cov0" title="0">{
                                p.SetState(143)
                                p.Match(MySqlParserRR_BRACKET)
                        }</span>

                }
                <span class="cov0" title="0">p.SetState(148)
                p.GetErrorHandler().Sync(p)
                _la = p.GetTokenStream().LA(1)


                if _la == MySqlParserAS </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                p.SetState(147)
                                p.Match(MySqlParserAS)
                        }</span>

                }
                <span class="cov0" title="0">{
                        p.SetState(150)

                        var _m = p.Match(MySqlParserID)

                        localctx.(*SubqueryTableItemContext).alias = _m
                }</span>


        case 3:<span class="cov0" title="0">
                localctx = NewTableSourcesItemContext(p, localctx)
                p.EnterOuterAlt(localctx, 3)
                </span><span class="cov0" title="0">{
                        p.SetState(152)
                        p.Match(MySqlParserLR_BRACKET)
                }</span>
                <span class="cov0" title="0">{
                        p.SetState(153)
                        p.TableSources()
                }</span>
                <span class="cov0" title="0">{
                        p.SetState(154)
                        p.Match(MySqlParserRR_BRACKET)
                }</span>

        }


        <span class="cov8" title="1">return localctx</span>
}


// IJoinPartContext is an interface to support dynamic dispatch.
type IJoinPartContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // IsJoinPartContext differentiates from other interfaces.
        IsJoinPartContext()
}

type JoinPartContext struct {
        *antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyJoinPartContext() *JoinPartContext <span class="cov8" title="1">{
        var p = new(JoinPartContext)
        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
        p.RuleIndex = MySqlParserRULE_joinPart
        return p
}</span>

func (*JoinPartContext) IsJoinPartContext() {<span class="cov0" title="0">}</span>

func NewJoinPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinPartContext <span class="cov8" title="1">{
        var p = new(JoinPartContext)

        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

        p.parser = parser
        p.RuleIndex = MySqlParserRULE_joinPart

        return p
}</span>

func (s *JoinPartContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *JoinPartContext) CopyFrom(ctx *JoinPartContext) <span class="cov8" title="1">{
        s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}</span>

func (s *JoinPartContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *JoinPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>




type InnerJoinContext struct {
        *JoinPartContext
}

func NewInnerJoinContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InnerJoinContext <span class="cov8" title="1">{
        var p = new(InnerJoinContext)

        p.JoinPartContext = NewEmptyJoinPartContext()
        p.parser = parser
        p.CopyFrom(ctx.(*JoinPartContext))

        return p
}</span>

func (s *InnerJoinContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *InnerJoinContext) JOIN() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserJOIN, 0)
}</span>

func (s *InnerJoinContext) TableSourceItem() ITableSourceItemContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableSourceItemContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(ITableSourceItemContext)</span>
}

func (s *InnerJoinContext) ON() antlr.TerminalNode <span class="cov8" title="1">{
        return s.GetToken(MySqlParserON, 0)
}</span>

func (s *InnerJoinContext) Expression() IExpressionContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(IExpressionContext)</span>
}

func (s *InnerJoinContext) INNER() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserINNER, 0)
}</span>

func (s *InnerJoinContext) CROSS() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserCROSS, 0)
}</span>


func (s *InnerJoinContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterInnerJoin(s)
        }</span>
}

func (s *InnerJoinContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitInnerJoin(s)
        }</span>
}

func (s *InnerJoinContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitInnerJoin(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}


type OuterJoinContext struct {
        *JoinPartContext
}

func NewOuterJoinContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *OuterJoinContext <span class="cov0" title="0">{
        var p = new(OuterJoinContext)

        p.JoinPartContext = NewEmptyJoinPartContext()
        p.parser = parser
        p.CopyFrom(ctx.(*JoinPartContext))

        return p
}</span>

func (s *OuterJoinContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *OuterJoinContext) JOIN() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserJOIN, 0)
}</span>

func (s *OuterJoinContext) TableSourceItem() ITableSourceItemContext <span class="cov0" title="0">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableSourceItemContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(ITableSourceItemContext)</span>
}

func (s *OuterJoinContext) LEFT() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserLEFT, 0)
}</span>

func (s *OuterJoinContext) RIGHT() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserRIGHT, 0)
}</span>

func (s *OuterJoinContext) ON() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserON, 0)
}</span>

func (s *OuterJoinContext) Expression() IExpressionContext <span class="cov0" title="0">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IExpressionContext)</span>
}

func (s *OuterJoinContext) USING() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserUSING, 0)
}</span>

func (s *OuterJoinContext) LR_BRACKET() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserLR_BRACKET, 0)
}</span>

func (s *OuterJoinContext) UidList() IUidListContext <span class="cov0" title="0">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IUidListContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IUidListContext)</span>
}

func (s *OuterJoinContext) RR_BRACKET() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserRR_BRACKET, 0)
}</span>

func (s *OuterJoinContext) OUTER() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserOUTER, 0)
}</span>


func (s *OuterJoinContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterOuterJoin(s)
        }</span>
}

func (s *OuterJoinContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitOuterJoin(s)
        }</span>
}

func (s *OuterJoinContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitOuterJoin(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}



func (p *MySqlParser) JoinPart() (localctx IJoinPartContext) <span class="cov8" title="1">{
        localctx = NewJoinPartContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 14, MySqlParserRULE_joinPart)
        var _la int


        defer func() </span><span class="cov8" title="1">{
                p.ExitRule()
        }</span>()

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        if v, ok := err.(antlr.RecognitionException); ok </span><span class="cov0" title="0">{
                                localctx.SetException(v)
                                p.GetErrorHandler().ReportError(p, v)
                                p.GetErrorHandler().Recover(p, v)
                        }</span> else<span class="cov0" title="0"> {
                                panic(err)</span>
                        }
                }
        }()

        <span class="cov8" title="1">p.SetState(182)
        p.GetErrorHandler().Sync(p)

        switch p.GetTokenStream().LA(1) </span>{
        case MySqlParserCROSS, MySqlParserINNER, MySqlParserJOIN:<span class="cov8" title="1">
                localctx = NewInnerJoinContext(p, localctx)
                p.EnterOuterAlt(localctx, 1)
                p.SetState(159)
                p.GetErrorHandler().Sync(p)
                _la = p.GetTokenStream().LA(1)


                if _la == MySqlParserCROSS || _la == MySqlParserINNER </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                p.SetState(158)
                                _la = p.GetTokenStream().LA(1)

                                if !(_la == MySqlParserCROSS || _la == MySqlParserINNER) </span><span class="cov0" title="0">{
                                        p.GetErrorHandler().RecoverInline(p)
                                }</span> else<span class="cov0" title="0"> {
                                        p.GetErrorHandler().ReportMatch(p)
                                        p.Consume()
                                }</span>
                        }

                }
                <span class="cov8" title="1">{
                        p.SetState(161)
                        p.Match(MySqlParserJOIN)
                }</span>
                <span class="cov8" title="1">{
                        p.SetState(162)
                        p.TableSourceItem()
                }</span>
                <span class="cov8" title="1">p.SetState(165)
                p.GetErrorHandler().Sync(p)
                _la = p.GetTokenStream().LA(1)


                if _la == MySqlParserON </span><span class="cov8" title="1">{
                        </span><span class="cov8" title="1">{
                                p.SetState(163)
                                p.Match(MySqlParserON)
                        }</span>
                        <span class="cov8" title="1">{
                                p.SetState(164)
                                p.expression(0)
                        }</span>

                }


        case MySqlParserLEFT, MySqlParserRIGHT:<span class="cov0" title="0">
                localctx = NewOuterJoinContext(p, localctx)
                p.EnterOuterAlt(localctx, 2)
                </span><span class="cov0" title="0">{
                        p.SetState(167)
                        _la = p.GetTokenStream().LA(1)

                        if !(_la == MySqlParserLEFT || _la == MySqlParserRIGHT) </span><span class="cov0" title="0">{
                                p.GetErrorHandler().RecoverInline(p)
                        }</span> else<span class="cov0" title="0"> {
                                p.GetErrorHandler().ReportMatch(p)
                                p.Consume()
                        }</span>
                }
                <span class="cov0" title="0">p.SetState(169)
                p.GetErrorHandler().Sync(p)
                _la = p.GetTokenStream().LA(1)


                if _la == MySqlParserOUTER </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                p.SetState(168)
                                p.Match(MySqlParserOUTER)
                        }</span>

                }
                <span class="cov0" title="0">{
                        p.SetState(171)
                        p.Match(MySqlParserJOIN)
                }</span>
                <span class="cov0" title="0">{
                        p.SetState(172)
                        p.TableSourceItem()
                }</span>
                <span class="cov0" title="0">p.SetState(180)
                p.GetErrorHandler().Sync(p)

                switch p.GetTokenStream().LA(1) </span>{
                case MySqlParserON:<span class="cov0" title="0">
                        </span><span class="cov0" title="0">{
                                p.SetState(173)
                                p.Match(MySqlParserON)
                        }</span>
                        <span class="cov0" title="0">{
                                p.SetState(174)
                                p.expression(0)
                        }</span>


                case MySqlParserUSING:<span class="cov0" title="0">
                        </span><span class="cov0" title="0">{
                                p.SetState(175)
                                p.Match(MySqlParserUSING)
                        }</span>
                        <span class="cov0" title="0">{
                                p.SetState(176)
                                p.Match(MySqlParserLR_BRACKET)
                        }</span>
                        <span class="cov0" title="0">{
                                p.SetState(177)
                                p.UidList()
                        }</span>
                        <span class="cov0" title="0">{
                                p.SetState(178)
                                p.Match(MySqlParserRR_BRACKET)
                        }</span>



                default:<span class="cov0" title="0">
                        panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))</span>
                }



        default:<span class="cov0" title="0">
                panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))</span>
        }


        <span class="cov8" title="1">return localctx</span>
}


// IQueryExpressionContext is an interface to support dynamic dispatch.
type IQueryExpressionContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // IsQueryExpressionContext differentiates from other interfaces.
        IsQueryExpressionContext()
}

type QueryExpressionContext struct {
        *antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyQueryExpressionContext() *QueryExpressionContext <span class="cov0" title="0">{
        var p = new(QueryExpressionContext)
        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
        p.RuleIndex = MySqlParserRULE_queryExpression
        return p
}</span>

func (*QueryExpressionContext) IsQueryExpressionContext() {<span class="cov0" title="0">}</span>

func NewQueryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryExpressionContext <span class="cov0" title="0">{
        var p = new(QueryExpressionContext)

        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

        p.parser = parser
        p.RuleIndex = MySqlParserRULE_queryExpression

        return p
}</span>

func (s *QueryExpressionContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *QueryExpressionContext) LR_BRACKET() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserLR_BRACKET, 0)
}</span>

func (s *QueryExpressionContext) QuerySpecification() IQuerySpecificationContext <span class="cov0" title="0">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuerySpecificationContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IQuerySpecificationContext)</span>
}

func (s *QueryExpressionContext) RR_BRACKET() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserRR_BRACKET, 0)
}</span>

func (s *QueryExpressionContext) QueryExpression() IQueryExpressionContext <span class="cov0" title="0">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryExpressionContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IQueryExpressionContext)</span>
}

func (s *QueryExpressionContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *QueryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>


func (s *QueryExpressionContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterQueryExpression(s)
        }</span>
}

func (s *QueryExpressionContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitQueryExpression(s)
        }</span>
}

func (s *QueryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitQueryExpression(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}




func (p *MySqlParser) QueryExpression() (localctx IQueryExpressionContext) <span class="cov0" title="0">{
        localctx = NewQueryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 16, MySqlParserRULE_queryExpression)

        defer func() </span><span class="cov0" title="0">{
                p.ExitRule()
        }</span>()

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        if v, ok := err.(antlr.RecognitionException); ok </span><span class="cov0" title="0">{
                                localctx.SetException(v)
                                p.GetErrorHandler().ReportError(p, v)
                                p.GetErrorHandler().Recover(p, v)
                        }</span> else<span class="cov0" title="0"> {
                                panic(err)</span>
                        }
                }
        }()

        <span class="cov0" title="0">p.SetState(192)
        p.GetErrorHandler().Sync(p)
        switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext()) </span>{
        case 1:<span class="cov0" title="0">
                p.EnterOuterAlt(localctx, 1)
                </span><span class="cov0" title="0">{
                        p.SetState(184)
                        p.Match(MySqlParserLR_BRACKET)
                }</span>
                <span class="cov0" title="0">{
                        p.SetState(185)
                        p.QuerySpecification()
                }</span>
                <span class="cov0" title="0">{
                        p.SetState(186)
                        p.Match(MySqlParserRR_BRACKET)
                }</span>


        case 2:<span class="cov0" title="0">
                p.EnterOuterAlt(localctx, 2)
                </span><span class="cov0" title="0">{
                        p.SetState(188)
                        p.Match(MySqlParserLR_BRACKET)
                }</span>
                <span class="cov0" title="0">{
                        p.SetState(189)
                        p.QueryExpression()
                }</span>
                <span class="cov0" title="0">{
                        p.SetState(190)
                        p.Match(MySqlParserRR_BRACKET)
                }</span>

        }


        <span class="cov0" title="0">return localctx</span>
}


// IQuerySpecificationContext is an interface to support dynamic dispatch.
type IQuerySpecificationContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // IsQuerySpecificationContext differentiates from other interfaces.
        IsQuerySpecificationContext()
}

type QuerySpecificationContext struct {
        *antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyQuerySpecificationContext() *QuerySpecificationContext <span class="cov0" title="0">{
        var p = new(QuerySpecificationContext)
        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
        p.RuleIndex = MySqlParserRULE_querySpecification
        return p
}</span>

func (*QuerySpecificationContext) IsQuerySpecificationContext() {<span class="cov0" title="0">}</span>

func NewQuerySpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuerySpecificationContext <span class="cov8" title="1">{
        var p = new(QuerySpecificationContext)

        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

        p.parser = parser
        p.RuleIndex = MySqlParserRULE_querySpecification

        return p
}</span>

func (s *QuerySpecificationContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *QuerySpecificationContext) SELECT() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserSELECT, 0)
}</span>

func (s *QuerySpecificationContext) SelectElements() ISelectElementsContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectElementsContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(ISelectElementsContext)</span>
}

func (s *QuerySpecificationContext) DISTINCT() antlr.TerminalNode <span class="cov8" title="1">{
        return s.GetToken(MySqlParserDISTINCT, 0)
}</span>

func (s *QuerySpecificationContext) FromClause() IFromClauseContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IFromClauseContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(IFromClauseContext)</span>
}

func (s *QuerySpecificationContext) OrderByClause() IOrderByClauseContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrderByClauseContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(IOrderByClauseContext)</span>
}

func (s *QuerySpecificationContext) LimitClause() ILimitClauseContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*ILimitClauseContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(ILimitClauseContext)</span>
}

func (s *QuerySpecificationContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *QuerySpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>


func (s *QuerySpecificationContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterQuerySpecification(s)
        }</span>
}

func (s *QuerySpecificationContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitQuerySpecification(s)
        }</span>
}

func (s *QuerySpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitQuerySpecification(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}




func (p *MySqlParser) QuerySpecification() (localctx IQuerySpecificationContext) <span class="cov8" title="1">{
        localctx = NewQuerySpecificationContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 18, MySqlParserRULE_querySpecification)
        var _la int


        defer func() </span><span class="cov8" title="1">{
                p.ExitRule()
        }</span>()

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        if v, ok := err.(antlr.RecognitionException); ok </span><span class="cov0" title="0">{
                                localctx.SetException(v)
                                p.GetErrorHandler().ReportError(p, v)
                                p.GetErrorHandler().Recover(p, v)
                        }</span> else<span class="cov0" title="0"> {
                                panic(err)</span>
                        }
                }
        }()

        <span class="cov8" title="1">p.EnterOuterAlt(localctx, 1)
        </span><span class="cov8" title="1">{
                p.SetState(194)
                p.Match(MySqlParserSELECT)
        }</span>
        <span class="cov8" title="1">p.SetState(196)
        p.GetErrorHandler().Sync(p)
        _la = p.GetTokenStream().LA(1)


        if _la == MySqlParserDISTINCT </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        p.SetState(195)
                        p.Match(MySqlParserDISTINCT)
                }</span>

        }
        <span class="cov8" title="1">{
                p.SetState(198)
                p.SelectElements()
        }</span>
        <span class="cov8" title="1">p.SetState(200)
        p.GetErrorHandler().Sync(p)
        _la = p.GetTokenStream().LA(1)


        if _la == MySqlParserFROM </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        p.SetState(199)
                        p.FromClause()
                }</span>

        }
        <span class="cov8" title="1">p.SetState(203)
        p.GetErrorHandler().Sync(p)
        _la = p.GetTokenStream().LA(1)


        if _la == MySqlParserORDER </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        p.SetState(202)
                        p.OrderByClause()
                }</span>

        }
        <span class="cov8" title="1">p.SetState(206)
        p.GetErrorHandler().Sync(p)
        _la = p.GetTokenStream().LA(1)


        if _la == MySqlParserLIMIT </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        p.SetState(205)
                        p.LimitClause()
                }</span>

        }



        <span class="cov8" title="1">return localctx</span>
}


// ISelectElementsContext is an interface to support dynamic dispatch.
type ISelectElementsContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // GetStar returns the star token.
        GetStar() antlr.Token 


        // SetStar sets the star token.
        SetStar(antlr.Token) 


        // IsSelectElementsContext differentiates from other interfaces.
        IsSelectElementsContext()
}

type SelectElementsContext struct {
        *antlr.BaseParserRuleContext
        parser antlr.Parser
        star antlr.Token
}

func NewEmptySelectElementsContext() *SelectElementsContext <span class="cov0" title="0">{
        var p = new(SelectElementsContext)
        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
        p.RuleIndex = MySqlParserRULE_selectElements
        return p
}</span>

func (*SelectElementsContext) IsSelectElementsContext() {<span class="cov0" title="0">}</span>

func NewSelectElementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectElementsContext <span class="cov8" title="1">{
        var p = new(SelectElementsContext)

        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

        p.parser = parser
        p.RuleIndex = MySqlParserRULE_selectElements

        return p
}</span>

func (s *SelectElementsContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *SelectElementsContext) GetStar() antlr.Token <span class="cov0" title="0">{ return s.star }</span>


func (s *SelectElementsContext) SetStar(v antlr.Token) <span class="cov0" title="0">{ s.star = v }</span>


func (s *SelectElementsContext) AllSelectElement() []ISelectElementContext <span class="cov8" title="1">{
        var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISelectElementContext)(nil)).Elem())
        var tst = make([]ISelectElementContext, len(ts))

        for i, t := range ts </span><span class="cov8" title="1">{
                if t != nil </span><span class="cov8" title="1">{
                        tst[i] = t.(ISelectElementContext)
                }</span>
        }

        <span class="cov8" title="1">return tst</span>
}

func (s *SelectElementsContext) SelectElement(i int) ISelectElementContext <span class="cov0" title="0">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectElementContext)(nil)).Elem(), i)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(ISelectElementContext)</span>
}

func (s *SelectElementsContext) STAR() antlr.TerminalNode <span class="cov8" title="1">{
        return s.GetToken(MySqlParserSTAR, 0)
}</span>

func (s *SelectElementsContext) AllCOMMA() []antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetTokens(MySqlParserCOMMA)
}</span>

func (s *SelectElementsContext) COMMA(i int) antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserCOMMA, i)
}</span>

func (s *SelectElementsContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *SelectElementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>


func (s *SelectElementsContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterSelectElements(s)
        }</span>
}

func (s *SelectElementsContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitSelectElements(s)
        }</span>
}

func (s *SelectElementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitSelectElements(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}




func (p *MySqlParser) SelectElements() (localctx ISelectElementsContext) <span class="cov8" title="1">{
        localctx = NewSelectElementsContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 20, MySqlParserRULE_selectElements)
        var _la int


        defer func() </span><span class="cov8" title="1">{
                p.ExitRule()
        }</span>()

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        if v, ok := err.(antlr.RecognitionException); ok </span><span class="cov0" title="0">{
                                localctx.SetException(v)
                                p.GetErrorHandler().ReportError(p, v)
                                p.GetErrorHandler().Recover(p, v)
                        }</span> else<span class="cov0" title="0"> {
                                panic(err)</span>
                        }
                }
        }()

        <span class="cov8" title="1">p.EnterOuterAlt(localctx, 1)
        p.SetState(210)
        p.GetErrorHandler().Sync(p)

        switch p.GetTokenStream().LA(1) </span>{
        case MySqlParserSTAR:<span class="cov8" title="1">
                </span><span class="cov8" title="1">{
                        p.SetState(208)

                        var _m = p.Match(MySqlParserSTAR)

                        localctx.(*SelectElementsContext).star = _m
                }</span>


        case MySqlParserCASE, MySqlParserEXISTS, MySqlParserFALSE, MySqlParserNOT, MySqlParserNULL_LITERAL, MySqlParserTRUE, MySqlParserPLUS, MySqlParserMINUS, MySqlParserEXCLAMATION_SYMBOL, MySqlParserBIT_NOT_OP, MySqlParserLR_BRACKET, MySqlParserSTRING_LITERAL, MySqlParserDECIMAL_LITERAL, MySqlParserREAL_LITERAL, MySqlParserNULL_SPEC_LITERAL, MySqlParserID:<span class="cov8" title="1">
                </span><span class="cov8" title="1">{
                        p.SetState(209)
                        p.SelectElement()
                }</span>



        default:<span class="cov0" title="0">
                panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))</span>
        }
        <span class="cov8" title="1">p.SetState(216)
        p.GetErrorHandler().Sync(p)
        _la = p.GetTokenStream().LA(1)


        for _la == MySqlParserCOMMA </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        p.SetState(212)
                        p.Match(MySqlParserCOMMA)
                }</span>
                <span class="cov8" title="1">{
                        p.SetState(213)
                        p.SelectElement()
                }</span>


                <span class="cov8" title="1">p.SetState(218)
                p.GetErrorHandler().Sync(p)
                _la = p.GetTokenStream().LA(1)</span>
        }



        <span class="cov8" title="1">return localctx</span>
}


// ISelectElementContext is an interface to support dynamic dispatch.
type ISelectElementContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // IsSelectElementContext differentiates from other interfaces.
        IsSelectElementContext()
}

type SelectElementContext struct {
        *antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptySelectElementContext() *SelectElementContext <span class="cov8" title="1">{
        var p = new(SelectElementContext)
        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
        p.RuleIndex = MySqlParserRULE_selectElement
        return p
}</span>

func (*SelectElementContext) IsSelectElementContext() {<span class="cov0" title="0">}</span>

func NewSelectElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectElementContext <span class="cov8" title="1">{
        var p = new(SelectElementContext)

        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

        p.parser = parser
        p.RuleIndex = MySqlParserRULE_selectElement

        return p
}</span>

func (s *SelectElementContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *SelectElementContext) CopyFrom(ctx *SelectElementContext) <span class="cov8" title="1">{
        s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}</span>

func (s *SelectElementContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *SelectElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>




type SelectExpressionElementContext struct {
        *SelectElementContext
}

func NewSelectExpressionElementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectExpressionElementContext <span class="cov8" title="1">{
        var p = new(SelectExpressionElementContext)

        p.SelectElementContext = NewEmptySelectElementContext()
        p.parser = parser
        p.CopyFrom(ctx.(*SelectElementContext))

        return p
}</span>

func (s *SelectExpressionElementContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *SelectExpressionElementContext) Expression() IExpressionContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(IExpressionContext)</span>
}

func (s *SelectExpressionElementContext) ID() antlr.TerminalNode <span class="cov8" title="1">{
        return s.GetToken(MySqlParserID, 0)
}</span>

func (s *SelectExpressionElementContext) AS() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserAS, 0)
}</span>


func (s *SelectExpressionElementContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterSelectExpressionElement(s)
        }</span>
}

func (s *SelectExpressionElementContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitSelectExpressionElement(s)
        }</span>
}

func (s *SelectExpressionElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitSelectExpressionElement(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}


type SelectFunctionElementContext struct {
        *SelectElementContext
}

func NewSelectFunctionElementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectFunctionElementContext <span class="cov8" title="1">{
        var p = new(SelectFunctionElementContext)

        p.SelectElementContext = NewEmptySelectElementContext()
        p.parser = parser
        p.CopyFrom(ctx.(*SelectElementContext))

        return p
}</span>

func (s *SelectFunctionElementContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *SelectFunctionElementContext) FunctionCall() IFunctionCallContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionCallContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(IFunctionCallContext)</span>
}

func (s *SelectFunctionElementContext) ID() antlr.TerminalNode <span class="cov8" title="1">{
        return s.GetToken(MySqlParserID, 0)
}</span>

func (s *SelectFunctionElementContext) AS() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserAS, 0)
}</span>


func (s *SelectFunctionElementContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterSelectFunctionElement(s)
        }</span>
}

func (s *SelectFunctionElementContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitSelectFunctionElement(s)
        }</span>
}

func (s *SelectFunctionElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitSelectFunctionElement(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}


type SelectColumnElementContext struct {
        *SelectElementContext
}

func NewSelectColumnElementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectColumnElementContext <span class="cov8" title="1">{
        var p = new(SelectColumnElementContext)

        p.SelectElementContext = NewEmptySelectElementContext()
        p.parser = parser
        p.CopyFrom(ctx.(*SelectElementContext))

        return p
}</span>

func (s *SelectColumnElementContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *SelectColumnElementContext) FullColumnName() IFullColumnNameContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IFullColumnNameContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(IFullColumnNameContext)</span>
}

func (s *SelectColumnElementContext) ID() antlr.TerminalNode <span class="cov8" title="1">{
        return s.GetToken(MySqlParserID, 0)
}</span>

func (s *SelectColumnElementContext) AS() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserAS, 0)
}</span>


func (s *SelectColumnElementContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterSelectColumnElement(s)
        }</span>
}

func (s *SelectColumnElementContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitSelectColumnElement(s)
        }</span>
}

func (s *SelectColumnElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitSelectColumnElement(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}



func (p *MySqlParser) SelectElement() (localctx ISelectElementContext) <span class="cov8" title="1">{
        localctx = NewSelectElementContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 22, MySqlParserRULE_selectElement)
        var _la int


        defer func() </span><span class="cov8" title="1">{
                p.ExitRule()
        }</span>()

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        if v, ok := err.(antlr.RecognitionException); ok </span><span class="cov0" title="0">{
                                localctx.SetException(v)
                                p.GetErrorHandler().ReportError(p, v)
                                p.GetErrorHandler().Recover(p, v)
                        }</span> else<span class="cov0" title="0"> {
                                panic(err)</span>
                        }
                }
        }()

        <span class="cov8" title="1">p.SetState(240)
        p.GetErrorHandler().Sync(p)
        switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 31, p.GetParserRuleContext()) </span>{
        case 1:<span class="cov8" title="1">
                localctx = NewSelectColumnElementContext(p, localctx)
                p.EnterOuterAlt(localctx, 1)
                </span><span class="cov8" title="1">{
                        p.SetState(219)
                        p.FullColumnName()
                }</span>
                <span class="cov8" title="1">p.SetState(224)
                p.GetErrorHandler().Sync(p)


                if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 26, p.GetParserRuleContext()) == 1 </span><span class="cov8" title="1">{
                        p.SetState(221)
                        p.GetErrorHandler().Sync(p)
                        _la = p.GetTokenStream().LA(1)


                        if _la == MySqlParserAS </span><span class="cov8" title="1">{
                                </span><span class="cov8" title="1">{
                                        p.SetState(220)
                                        p.Match(MySqlParserAS)
                                }</span>

                        }
                        <span class="cov8" title="1">{
                                p.SetState(223)
                                p.Match(MySqlParserID)
                        }</span>


                }


        case 2:<span class="cov8" title="1">
                localctx = NewSelectFunctionElementContext(p, localctx)
                p.EnterOuterAlt(localctx, 2)
                </span><span class="cov8" title="1">{
                        p.SetState(226)
                        p.FunctionCall()
                }</span>
                <span class="cov8" title="1">p.SetState(231)
                p.GetErrorHandler().Sync(p)


                if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext()) == 1 </span><span class="cov8" title="1">{
                        p.SetState(228)
                        p.GetErrorHandler().Sync(p)
                        _la = p.GetTokenStream().LA(1)


                        if _la == MySqlParserAS </span><span class="cov8" title="1">{
                                </span><span class="cov8" title="1">{
                                        p.SetState(227)
                                        p.Match(MySqlParserAS)
                                }</span>

                        }
                        <span class="cov8" title="1">{
                                p.SetState(230)
                                p.Match(MySqlParserID)
                        }</span>


                }


        case 3:<span class="cov8" title="1">
                localctx = NewSelectExpressionElementContext(p, localctx)
                p.EnterOuterAlt(localctx, 3)
                </span><span class="cov8" title="1">{
                        p.SetState(233)
                        p.expression(0)
                }</span>
                <span class="cov8" title="1">p.SetState(238)
                p.GetErrorHandler().Sync(p)


                if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext()) == 1 </span><span class="cov8" title="1">{
                        p.SetState(235)
                        p.GetErrorHandler().Sync(p)
                        _la = p.GetTokenStream().LA(1)


                        if _la == MySqlParserAS </span><span class="cov8" title="1">{
                                </span><span class="cov8" title="1">{
                                        p.SetState(234)
                                        p.Match(MySqlParserAS)
                                }</span>

                        }
                        <span class="cov8" title="1">{
                                p.SetState(237)
                                p.Match(MySqlParserID)
                        }</span>


                }

        }


        <span class="cov8" title="1">return localctx</span>
}


// IFromClauseContext is an interface to support dynamic dispatch.
type IFromClauseContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // GetWhereExpr returns the whereExpr rule contexts.
        GetWhereExpr() IExpressionContext

        // GetHavingExpr returns the havingExpr rule contexts.
        GetHavingExpr() IExpressionContext


        // SetWhereExpr sets the whereExpr rule contexts.
        SetWhereExpr(IExpressionContext)

        // SetHavingExpr sets the havingExpr rule contexts.
        SetHavingExpr(IExpressionContext)


        // IsFromClauseContext differentiates from other interfaces.
        IsFromClauseContext()
}

type FromClauseContext struct {
        *antlr.BaseParserRuleContext
        parser antlr.Parser
        whereExpr IExpressionContext 
        havingExpr IExpressionContext 
}

func NewEmptyFromClauseContext() *FromClauseContext <span class="cov0" title="0">{
        var p = new(FromClauseContext)
        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
        p.RuleIndex = MySqlParserRULE_fromClause
        return p
}</span>

func (*FromClauseContext) IsFromClauseContext() {<span class="cov0" title="0">}</span>

func NewFromClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FromClauseContext <span class="cov8" title="1">{
        var p = new(FromClauseContext)

        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

        p.parser = parser
        p.RuleIndex = MySqlParserRULE_fromClause

        return p
}</span>

func (s *FromClauseContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *FromClauseContext) GetWhereExpr() IExpressionContext <span class="cov0" title="0">{ return s.whereExpr }</span>

func (s *FromClauseContext) GetHavingExpr() IExpressionContext <span class="cov0" title="0">{ return s.havingExpr }</span>


func (s *FromClauseContext) SetWhereExpr(v IExpressionContext) <span class="cov0" title="0">{ s.whereExpr = v }</span>

func (s *FromClauseContext) SetHavingExpr(v IExpressionContext) <span class="cov0" title="0">{ s.havingExpr = v }</span>


func (s *FromClauseContext) FROM() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserFROM, 0)
}</span>

func (s *FromClauseContext) TableSources() ITableSourcesContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableSourcesContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(ITableSourcesContext)</span>
}

func (s *FromClauseContext) WHERE() antlr.TerminalNode <span class="cov8" title="1">{
        return s.GetToken(MySqlParserWHERE, 0)
}</span>

func (s *FromClauseContext) GROUP() antlr.TerminalNode <span class="cov8" title="1">{
        return s.GetToken(MySqlParserGROUP, 0)
}</span>

func (s *FromClauseContext) BY() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserBY, 0)
}</span>

func (s *FromClauseContext) AllGroupByItem() []IGroupByItemContext <span class="cov8" title="1">{
        var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGroupByItemContext)(nil)).Elem())
        var tst = make([]IGroupByItemContext, len(ts))

        for i, t := range ts </span><span class="cov8" title="1">{
                if t != nil </span><span class="cov8" title="1">{
                        tst[i] = t.(IGroupByItemContext)
                }</span>
        }

        <span class="cov8" title="1">return tst</span>
}

func (s *FromClauseContext) GroupByItem(i int) IGroupByItemContext <span class="cov0" title="0">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroupByItemContext)(nil)).Elem(), i)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IGroupByItemContext)</span>
}

func (s *FromClauseContext) AllExpression() []IExpressionContext <span class="cov0" title="0">{
        var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
        var tst = make([]IExpressionContext, len(ts))

        for i, t := range ts </span><span class="cov0" title="0">{
                if t != nil </span><span class="cov0" title="0">{
                        tst[i] = t.(IExpressionContext)
                }</span>
        }

        <span class="cov0" title="0">return tst</span>
}

func (s *FromClauseContext) Expression(i int) IExpressionContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(IExpressionContext)</span>
}

func (s *FromClauseContext) AllCOMMA() []antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetTokens(MySqlParserCOMMA)
}</span>

func (s *FromClauseContext) COMMA(i int) antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserCOMMA, i)
}</span>

func (s *FromClauseContext) HAVING() antlr.TerminalNode <span class="cov8" title="1">{
        return s.GetToken(MySqlParserHAVING, 0)
}</span>

func (s *FromClauseContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *FromClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>


func (s *FromClauseContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterFromClause(s)
        }</span>
}

func (s *FromClauseContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitFromClause(s)
        }</span>
}

func (s *FromClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitFromClause(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}




func (p *MySqlParser) FromClause() (localctx IFromClauseContext) <span class="cov8" title="1">{
        localctx = NewFromClauseContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 24, MySqlParserRULE_fromClause)
        var _la int


        defer func() </span><span class="cov8" title="1">{
                p.ExitRule()
        }</span>()

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        if v, ok := err.(antlr.RecognitionException); ok </span><span class="cov0" title="0">{
                                localctx.SetException(v)
                                p.GetErrorHandler().ReportError(p, v)
                                p.GetErrorHandler().Recover(p, v)
                        }</span> else<span class="cov0" title="0"> {
                                panic(err)</span>
                        }
                }
        }()

        <span class="cov8" title="1">p.EnterOuterAlt(localctx, 1)
        </span><span class="cov8" title="1">{
                p.SetState(242)
                p.Match(MySqlParserFROM)
        }</span>
        <span class="cov8" title="1">{
                p.SetState(243)
                p.TableSources()
        }</span>
        <span class="cov8" title="1">p.SetState(246)
        p.GetErrorHandler().Sync(p)
        _la = p.GetTokenStream().LA(1)


        if _la == MySqlParserWHERE </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        p.SetState(244)
                        p.Match(MySqlParserWHERE)
                }</span>
                <span class="cov8" title="1">{
                        p.SetState(245)

                        var _x = p.expression(0)

                        localctx.(*FromClauseContext).whereExpr = _x
                }</span>

        }
        <span class="cov8" title="1">p.SetState(262)
        p.GetErrorHandler().Sync(p)
        _la = p.GetTokenStream().LA(1)


        if _la == MySqlParserGROUP </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        p.SetState(248)
                        p.Match(MySqlParserGROUP)
                }</span>
                <span class="cov8" title="1">{
                        p.SetState(249)
                        p.Match(MySqlParserBY)
                }</span>
                <span class="cov8" title="1">{
                        p.SetState(250)
                        p.GroupByItem()
                }</span>
                <span class="cov8" title="1">p.SetState(255)
                p.GetErrorHandler().Sync(p)
                _la = p.GetTokenStream().LA(1)


                for _la == MySqlParserCOMMA </span><span class="cov8" title="1">{
                        </span><span class="cov8" title="1">{
                                p.SetState(251)
                                p.Match(MySqlParserCOMMA)
                        }</span>
                        <span class="cov8" title="1">{
                                p.SetState(252)
                                p.GroupByItem()
                        }</span>


                        <span class="cov8" title="1">p.SetState(257)
                        p.GetErrorHandler().Sync(p)
                        _la = p.GetTokenStream().LA(1)</span>
                }
                <span class="cov8" title="1">p.SetState(260)
                p.GetErrorHandler().Sync(p)
                _la = p.GetTokenStream().LA(1)


                if _la == MySqlParserHAVING </span><span class="cov8" title="1">{
                        </span><span class="cov8" title="1">{
                                p.SetState(258)
                                p.Match(MySqlParserHAVING)
                        }</span>
                        <span class="cov8" title="1">{
                                p.SetState(259)

                                var _x = p.expression(0)

                                localctx.(*FromClauseContext).havingExpr = _x
                        }</span>

                }

        }



        <span class="cov8" title="1">return localctx</span>
}


// IGroupByItemContext is an interface to support dynamic dispatch.
type IGroupByItemContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // GetOrder returns the order token.
        GetOrder() antlr.Token 


        // SetOrder sets the order token.
        SetOrder(antlr.Token) 


        // IsGroupByItemContext differentiates from other interfaces.
        IsGroupByItemContext()
}

type GroupByItemContext struct {
        *antlr.BaseParserRuleContext
        parser antlr.Parser
        order antlr.Token
}

func NewEmptyGroupByItemContext() *GroupByItemContext <span class="cov0" title="0">{
        var p = new(GroupByItemContext)
        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
        p.RuleIndex = MySqlParserRULE_groupByItem
        return p
}</span>

func (*GroupByItemContext) IsGroupByItemContext() {<span class="cov0" title="0">}</span>

func NewGroupByItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupByItemContext <span class="cov8" title="1">{
        var p = new(GroupByItemContext)

        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

        p.parser = parser
        p.RuleIndex = MySqlParserRULE_groupByItem

        return p
}</span>

func (s *GroupByItemContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *GroupByItemContext) GetOrder() antlr.Token <span class="cov0" title="0">{ return s.order }</span>


func (s *GroupByItemContext) SetOrder(v antlr.Token) <span class="cov0" title="0">{ s.order = v }</span>


func (s *GroupByItemContext) Expression() IExpressionContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(IExpressionContext)</span>
}

func (s *GroupByItemContext) ASC() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserASC, 0)
}</span>

func (s *GroupByItemContext) DESC() antlr.TerminalNode <span class="cov8" title="1">{
        return s.GetToken(MySqlParserDESC, 0)
}</span>

func (s *GroupByItemContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *GroupByItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>


func (s *GroupByItemContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterGroupByItem(s)
        }</span>
}

func (s *GroupByItemContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitGroupByItem(s)
        }</span>
}

func (s *GroupByItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitGroupByItem(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}




func (p *MySqlParser) GroupByItem() (localctx IGroupByItemContext) <span class="cov8" title="1">{
        localctx = NewGroupByItemContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 26, MySqlParserRULE_groupByItem)
        var _la int


        defer func() </span><span class="cov8" title="1">{
                p.ExitRule()
        }</span>()

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        if v, ok := err.(antlr.RecognitionException); ok </span><span class="cov0" title="0">{
                                localctx.SetException(v)
                                p.GetErrorHandler().ReportError(p, v)
                                p.GetErrorHandler().Recover(p, v)
                        }</span> else<span class="cov0" title="0"> {
                                panic(err)</span>
                        }
                }
        }()

        <span class="cov8" title="1">p.EnterOuterAlt(localctx, 1)
        </span><span class="cov8" title="1">{
                p.SetState(264)
                p.expression(0)
        }</span>
        <span class="cov8" title="1">p.SetState(266)
        p.GetErrorHandler().Sync(p)
        _la = p.GetTokenStream().LA(1)


        if _la == MySqlParserASC || _la == MySqlParserDESC </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        p.SetState(265)

                        var _lt = p.GetTokenStream().LT(1)

                        localctx.(*GroupByItemContext).order = _lt

                        _la = p.GetTokenStream().LA(1)

                        if !(_la == MySqlParserASC || _la == MySqlParserDESC) </span><span class="cov0" title="0">{
                                var _ri = p.GetErrorHandler().RecoverInline(p)

                                localctx.(*GroupByItemContext).order = _ri
                        }</span> else<span class="cov0" title="0"> {
                                p.GetErrorHandler().ReportMatch(p)
                                p.Consume()
                        }</span>
                }

        }



        <span class="cov8" title="1">return localctx</span>
}


// ILimitClauseContext is an interface to support dynamic dispatch.
type ILimitClauseContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // GetOffset returns the offset token.
        GetOffset() antlr.Token 

        // GetLimit returns the limit token.
        GetLimit() antlr.Token 


        // SetOffset sets the offset token.
        SetOffset(antlr.Token) 

        // SetLimit sets the limit token.
        SetLimit(antlr.Token) 


        // IsLimitClauseContext differentiates from other interfaces.
        IsLimitClauseContext()
}

type LimitClauseContext struct {
        *antlr.BaseParserRuleContext
        parser antlr.Parser
        offset antlr.Token
        limit antlr.Token
}

func NewEmptyLimitClauseContext() *LimitClauseContext <span class="cov0" title="0">{
        var p = new(LimitClauseContext)
        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
        p.RuleIndex = MySqlParserRULE_limitClause
        return p
}</span>

func (*LimitClauseContext) IsLimitClauseContext() {<span class="cov0" title="0">}</span>

func NewLimitClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitClauseContext <span class="cov8" title="1">{
        var p = new(LimitClauseContext)

        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

        p.parser = parser
        p.RuleIndex = MySqlParserRULE_limitClause

        return p
}</span>

func (s *LimitClauseContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *LimitClauseContext) GetOffset() antlr.Token <span class="cov0" title="0">{ return s.offset }</span>

func (s *LimitClauseContext) GetLimit() antlr.Token <span class="cov0" title="0">{ return s.limit }</span>


func (s *LimitClauseContext) SetOffset(v antlr.Token) <span class="cov0" title="0">{ s.offset = v }</span>

func (s *LimitClauseContext) SetLimit(v antlr.Token) <span class="cov0" title="0">{ s.limit = v }</span>


func (s *LimitClauseContext) LIMIT() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserLIMIT, 0)
}</span>

func (s *LimitClauseContext) OFFSET() antlr.TerminalNode <span class="cov8" title="1">{
        return s.GetToken(MySqlParserOFFSET, 0)
}</span>

func (s *LimitClauseContext) AllDECIMAL_LITERAL() []antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetTokens(MySqlParserDECIMAL_LITERAL)
}</span>

func (s *LimitClauseContext) DECIMAL_LITERAL(i int) antlr.TerminalNode <span class="cov8" title="1">{
        return s.GetToken(MySqlParserDECIMAL_LITERAL, i)
}</span>

func (s *LimitClauseContext) COMMA() antlr.TerminalNode <span class="cov8" title="1">{
        return s.GetToken(MySqlParserCOMMA, 0)
}</span>

func (s *LimitClauseContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *LimitClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>


func (s *LimitClauseContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterLimitClause(s)
        }</span>
}

func (s *LimitClauseContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitLimitClause(s)
        }</span>
}

func (s *LimitClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitLimitClause(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}




func (p *MySqlParser) LimitClause() (localctx ILimitClauseContext) <span class="cov8" title="1">{
        localctx = NewLimitClauseContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 28, MySqlParserRULE_limitClause)

        defer func() </span><span class="cov8" title="1">{
                p.ExitRule()
        }</span>()

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        if v, ok := err.(antlr.RecognitionException); ok </span><span class="cov0" title="0">{
                                localctx.SetException(v)
                                p.GetErrorHandler().ReportError(p, v)
                                p.GetErrorHandler().Recover(p, v)
                        }</span> else<span class="cov0" title="0"> {
                                panic(err)</span>
                        }
                }
        }()

        <span class="cov8" title="1">p.EnterOuterAlt(localctx, 1)
        </span><span class="cov8" title="1">{
                p.SetState(268)
                p.Match(MySqlParserLIMIT)
        }</span>
        <span class="cov8" title="1">p.SetState(277)
        p.GetErrorHandler().Sync(p)
        switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 38, p.GetParserRuleContext()) </span>{
        case 1:<span class="cov8" title="1">
                p.SetState(271)
                p.GetErrorHandler().Sync(p)


                if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext()) == 1 </span><span class="cov8" title="1">{
                        </span><span class="cov8" title="1">{
                                p.SetState(269)

                                var _m = p.Match(MySqlParserDECIMAL_LITERAL)

                                localctx.(*LimitClauseContext).offset = _m
                        }</span>
                        <span class="cov8" title="1">{
                                p.SetState(270)
                                p.Match(MySqlParserCOMMA)
                        }</span>


                }
                <span class="cov8" title="1">{
                        p.SetState(273)

                        var _m = p.Match(MySqlParserDECIMAL_LITERAL)

                        localctx.(*LimitClauseContext).limit = _m
                }</span>


        case 2:<span class="cov0" title="0">
                </span><span class="cov0" title="0">{
                        p.SetState(274)

                        var _m = p.Match(MySqlParserDECIMAL_LITERAL)

                        localctx.(*LimitClauseContext).limit = _m
                }</span>
                <span class="cov0" title="0">{
                        p.SetState(275)
                        p.Match(MySqlParserOFFSET)
                }</span>
                <span class="cov0" title="0">{
                        p.SetState(276)

                        var _m = p.Match(MySqlParserDECIMAL_LITERAL)

                        localctx.(*LimitClauseContext).offset = _m
                }</span>

        }



        <span class="cov8" title="1">return localctx</span>
}


// IFullColumnNameContext is an interface to support dynamic dispatch.
type IFullColumnNameContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // IsFullColumnNameContext differentiates from other interfaces.
        IsFullColumnNameContext()
}

type FullColumnNameContext struct {
        *antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyFullColumnNameContext() *FullColumnNameContext <span class="cov0" title="0">{
        var p = new(FullColumnNameContext)
        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
        p.RuleIndex = MySqlParserRULE_fullColumnName
        return p
}</span>

func (*FullColumnNameContext) IsFullColumnNameContext() {<span class="cov0" title="0">}</span>

func NewFullColumnNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FullColumnNameContext <span class="cov8" title="1">{
        var p = new(FullColumnNameContext)

        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

        p.parser = parser
        p.RuleIndex = MySqlParserRULE_fullColumnName

        return p
}</span>

func (s *FullColumnNameContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *FullColumnNameContext) ID() antlr.TerminalNode <span class="cov8" title="1">{
        return s.GetToken(MySqlParserID, 0)
}</span>

func (s *FullColumnNameContext) AllDOT_ID() []antlr.TerminalNode <span class="cov8" title="1">{
        return s.GetTokens(MySqlParserDOT_ID)
}</span>

func (s *FullColumnNameContext) DOT_ID(i int) antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserDOT_ID, i)
}</span>

func (s *FullColumnNameContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *FullColumnNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>


func (s *FullColumnNameContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterFullColumnName(s)
        }</span>
}

func (s *FullColumnNameContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitFullColumnName(s)
        }</span>
}

func (s *FullColumnNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitFullColumnName(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}




func (p *MySqlParser) FullColumnName() (localctx IFullColumnNameContext) <span class="cov8" title="1">{
        localctx = NewFullColumnNameContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 30, MySqlParserRULE_fullColumnName)

        defer func() </span><span class="cov8" title="1">{
                p.ExitRule()
        }</span>()

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        if v, ok := err.(antlr.RecognitionException); ok </span><span class="cov0" title="0">{
                                localctx.SetException(v)
                                p.GetErrorHandler().ReportError(p, v)
                                p.GetErrorHandler().Recover(p, v)
                        }</span> else<span class="cov0" title="0"> {
                                panic(err)</span>
                        }
                }
        }()

        <span class="cov8" title="1">var _alt int

        p.EnterOuterAlt(localctx, 1)
        </span><span class="cov8" title="1">{
                p.SetState(279)
                p.Match(MySqlParserID)
        }</span>
        <span class="cov8" title="1">p.SetState(283)
        p.GetErrorHandler().Sync(p)
        _alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 39, p.GetParserRuleContext())

        for _alt != 2 &amp;&amp; _alt != antlr.ATNInvalidAltNumber </span><span class="cov8" title="1">{
                if _alt == 1 </span><span class="cov8" title="1">{
                        </span><span class="cov8" title="1">{
                                p.SetState(280)
                                p.Match(MySqlParserDOT_ID)
                        }</span>


                }
                <span class="cov8" title="1">p.SetState(285)
                p.GetErrorHandler().Sync(p)
                _alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 39, p.GetParserRuleContext())</span>
        }



        <span class="cov8" title="1">return localctx</span>
}


// IBooleanLiteralContext is an interface to support dynamic dispatch.
type IBooleanLiteralContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // IsBooleanLiteralContext differentiates from other interfaces.
        IsBooleanLiteralContext()
}

type BooleanLiteralContext struct {
        *antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyBooleanLiteralContext() *BooleanLiteralContext <span class="cov0" title="0">{
        var p = new(BooleanLiteralContext)
        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
        p.RuleIndex = MySqlParserRULE_booleanLiteral
        return p
}</span>

func (*BooleanLiteralContext) IsBooleanLiteralContext() {<span class="cov0" title="0">}</span>

func NewBooleanLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanLiteralContext <span class="cov0" title="0">{
        var p = new(BooleanLiteralContext)

        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

        p.parser = parser
        p.RuleIndex = MySqlParserRULE_booleanLiteral

        return p
}</span>

func (s *BooleanLiteralContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *BooleanLiteralContext) TRUE() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserTRUE, 0)
}</span>

func (s *BooleanLiteralContext) FALSE() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserFALSE, 0)
}</span>

func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *BooleanLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>


func (s *BooleanLiteralContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterBooleanLiteral(s)
        }</span>
}

func (s *BooleanLiteralContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitBooleanLiteral(s)
        }</span>
}

func (s *BooleanLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitBooleanLiteral(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}




func (p *MySqlParser) BooleanLiteral() (localctx IBooleanLiteralContext) <span class="cov0" title="0">{
        localctx = NewBooleanLiteralContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 32, MySqlParserRULE_booleanLiteral)
        var _la int


        defer func() </span><span class="cov0" title="0">{
                p.ExitRule()
        }</span>()

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        if v, ok := err.(antlr.RecognitionException); ok </span><span class="cov0" title="0">{
                                localctx.SetException(v)
                                p.GetErrorHandler().ReportError(p, v)
                                p.GetErrorHandler().Recover(p, v)
                        }</span> else<span class="cov0" title="0"> {
                                panic(err)</span>
                        }
                }
        }()

        <span class="cov0" title="0">p.EnterOuterAlt(localctx, 1)
        </span><span class="cov0" title="0">{
                p.SetState(286)
                _la = p.GetTokenStream().LA(1)

                if !(_la == MySqlParserFALSE || _la == MySqlParserTRUE) </span><span class="cov0" title="0">{
                        p.GetErrorHandler().RecoverInline(p)
                }</span> else<span class="cov0" title="0"> {
                        p.GetErrorHandler().ReportMatch(p)
                        p.Consume()
                }</span>
        }



        <span class="cov0" title="0">return localctx</span>
}


// INullNotnullContext is an interface to support dynamic dispatch.
type INullNotnullContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // IsNullNotnullContext differentiates from other interfaces.
        IsNullNotnullContext()
}

type NullNotnullContext struct {
        *antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyNullNotnullContext() *NullNotnullContext <span class="cov0" title="0">{
        var p = new(NullNotnullContext)
        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
        p.RuleIndex = MySqlParserRULE_nullNotnull
        return p
}</span>

func (*NullNotnullContext) IsNullNotnullContext() {<span class="cov0" title="0">}</span>

func NewNullNotnullContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NullNotnullContext <span class="cov0" title="0">{
        var p = new(NullNotnullContext)

        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

        p.parser = parser
        p.RuleIndex = MySqlParserRULE_nullNotnull

        return p
}</span>

func (s *NullNotnullContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *NullNotnullContext) NULL_LITERAL() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserNULL_LITERAL, 0)
}</span>

func (s *NullNotnullContext) NULL_SPEC_LITERAL() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserNULL_SPEC_LITERAL, 0)
}</span>

func (s *NullNotnullContext) NOT() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserNOT, 0)
}</span>

func (s *NullNotnullContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *NullNotnullContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>


func (s *NullNotnullContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterNullNotnull(s)
        }</span>
}

func (s *NullNotnullContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitNullNotnull(s)
        }</span>
}

func (s *NullNotnullContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitNullNotnull(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}




func (p *MySqlParser) NullNotnull() (localctx INullNotnullContext) <span class="cov0" title="0">{
        localctx = NewNullNotnullContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 34, MySqlParserRULE_nullNotnull)
        var _la int


        defer func() </span><span class="cov0" title="0">{
                p.ExitRule()
        }</span>()

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        if v, ok := err.(antlr.RecognitionException); ok </span><span class="cov0" title="0">{
                                localctx.SetException(v)
                                p.GetErrorHandler().ReportError(p, v)
                                p.GetErrorHandler().Recover(p, v)
                        }</span> else<span class="cov0" title="0"> {
                                panic(err)</span>
                        }
                }
        }()

        <span class="cov0" title="0">p.EnterOuterAlt(localctx, 1)
        p.SetState(289)
        p.GetErrorHandler().Sync(p)
        _la = p.GetTokenStream().LA(1)


        if _la == MySqlParserNOT </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        p.SetState(288)
                        p.Match(MySqlParserNOT)
                }</span>

        }
        <span class="cov0" title="0">{
                p.SetState(291)
                _la = p.GetTokenStream().LA(1)

                if !(_la == MySqlParserNULL_LITERAL || _la == MySqlParserNULL_SPEC_LITERAL) </span><span class="cov0" title="0">{
                        p.GetErrorHandler().RecoverInline(p)
                }</span> else<span class="cov0" title="0"> {
                        p.GetErrorHandler().ReportMatch(p)
                        p.Consume()
                }</span>
        }



        <span class="cov0" title="0">return localctx</span>
}


// IConstantContext is an interface to support dynamic dispatch.
type IConstantContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // GetNullLiteral returns the nullLiteral token.
        GetNullLiteral() antlr.Token 


        // SetNullLiteral sets the nullLiteral token.
        SetNullLiteral(antlr.Token) 


        // IsConstantContext differentiates from other interfaces.
        IsConstantContext()
}

type ConstantContext struct {
        *antlr.BaseParserRuleContext
        parser antlr.Parser
        nullLiteral antlr.Token
}

func NewEmptyConstantContext() *ConstantContext <span class="cov0" title="0">{
        var p = new(ConstantContext)
        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
        p.RuleIndex = MySqlParserRULE_constant
        return p
}</span>

func (*ConstantContext) IsConstantContext() {<span class="cov0" title="0">}</span>

func NewConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantContext <span class="cov8" title="1">{
        var p = new(ConstantContext)

        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

        p.parser = parser
        p.RuleIndex = MySqlParserRULE_constant

        return p
}</span>

func (s *ConstantContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *ConstantContext) GetNullLiteral() antlr.Token <span class="cov0" title="0">{ return s.nullLiteral }</span>


func (s *ConstantContext) SetNullLiteral(v antlr.Token) <span class="cov0" title="0">{ s.nullLiteral = v }</span>


func (s *ConstantContext) STRING_LITERAL() antlr.TerminalNode <span class="cov8" title="1">{
        return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}</span>

func (s *ConstantContext) DECIMAL_LITERAL() antlr.TerminalNode <span class="cov8" title="1">{
        return s.GetToken(MySqlParserDECIMAL_LITERAL, 0)
}</span>

func (s *ConstantContext) MINUS() antlr.TerminalNode <span class="cov8" title="1">{
        return s.GetToken(MySqlParserMINUS, 0)
}</span>

func (s *ConstantContext) BooleanLiteral() IBooleanLiteralContext <span class="cov0" title="0">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanLiteralContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IBooleanLiteralContext)</span>
}

func (s *ConstantContext) REAL_LITERAL() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserREAL_LITERAL, 0)
}</span>

func (s *ConstantContext) NULL_LITERAL() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserNULL_LITERAL, 0)
}</span>

func (s *ConstantContext) NULL_SPEC_LITERAL() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserNULL_SPEC_LITERAL, 0)
}</span>

func (s *ConstantContext) NOT() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserNOT, 0)
}</span>

func (s *ConstantContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *ConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>


func (s *ConstantContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterConstant(s)
        }</span>
}

func (s *ConstantContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitConstant(s)
        }</span>
}

func (s *ConstantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitConstant(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}




func (p *MySqlParser) Constant() (localctx IConstantContext) <span class="cov8" title="1">{
        localctx = NewConstantContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 36, MySqlParserRULE_constant)
        var _la int


        defer func() </span><span class="cov8" title="1">{
                p.ExitRule()
        }</span>()

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        if v, ok := err.(antlr.RecognitionException); ok </span><span class="cov0" title="0">{
                                localctx.SetException(v)
                                p.GetErrorHandler().ReportError(p, v)
                                p.GetErrorHandler().Recover(p, v)
                        }</span> else<span class="cov0" title="0"> {
                                panic(err)</span>
                        }
                }
        }()

        <span class="cov8" title="1">p.SetState(303)
        p.GetErrorHandler().Sync(p)

        switch p.GetTokenStream().LA(1) </span>{
        case MySqlParserSTRING_LITERAL:<span class="cov8" title="1">
                p.EnterOuterAlt(localctx, 1)
                </span><span class="cov8" title="1">{
                        p.SetState(293)
                        p.Match(MySqlParserSTRING_LITERAL)
                }</span>


        case MySqlParserDECIMAL_LITERAL:<span class="cov8" title="1">
                p.EnterOuterAlt(localctx, 2)
                </span><span class="cov8" title="1">{
                        p.SetState(294)
                        p.Match(MySqlParserDECIMAL_LITERAL)
                }</span>


        case MySqlParserMINUS:<span class="cov0" title="0">
                p.EnterOuterAlt(localctx, 3)
                </span><span class="cov0" title="0">{
                        p.SetState(295)
                        p.Match(MySqlParserMINUS)
                }</span>
                <span class="cov0" title="0">{
                        p.SetState(296)
                        p.Match(MySqlParserDECIMAL_LITERAL)
                }</span>


        case MySqlParserFALSE, MySqlParserTRUE:<span class="cov0" title="0">
                p.EnterOuterAlt(localctx, 4)
                </span><span class="cov0" title="0">{
                        p.SetState(297)
                        p.BooleanLiteral()
                }</span>


        case MySqlParserREAL_LITERAL:<span class="cov0" title="0">
                p.EnterOuterAlt(localctx, 5)
                </span><span class="cov0" title="0">{
                        p.SetState(298)
                        p.Match(MySqlParserREAL_LITERAL)
                }</span>


        case MySqlParserNOT, MySqlParserNULL_LITERAL, MySqlParserNULL_SPEC_LITERAL:<span class="cov0" title="0">
                p.EnterOuterAlt(localctx, 6)
                p.SetState(300)
                p.GetErrorHandler().Sync(p)
                _la = p.GetTokenStream().LA(1)


                if _la == MySqlParserNOT </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                p.SetState(299)
                                p.Match(MySqlParserNOT)
                        }</span>

                }
                <span class="cov0" title="0">{
                        p.SetState(302)

                        var _lt = p.GetTokenStream().LT(1)

                        localctx.(*ConstantContext).nullLiteral = _lt

                        _la = p.GetTokenStream().LA(1)

                        if !(_la == MySqlParserNULL_LITERAL || _la == MySqlParserNULL_SPEC_LITERAL) </span><span class="cov0" title="0">{
                                var _ri = p.GetErrorHandler().RecoverInline(p)

                                localctx.(*ConstantContext).nullLiteral = _ri
                        }</span> else<span class="cov0" title="0"> {
                                p.GetErrorHandler().ReportMatch(p)
                                p.Consume()
                        }</span>
                }



        default:<span class="cov0" title="0">
                panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))</span>
        }


        <span class="cov8" title="1">return localctx</span>
}


// IUidListContext is an interface to support dynamic dispatch.
type IUidListContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // IsUidListContext differentiates from other interfaces.
        IsUidListContext()
}

type UidListContext struct {
        *antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyUidListContext() *UidListContext <span class="cov0" title="0">{
        var p = new(UidListContext)
        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
        p.RuleIndex = MySqlParserRULE_uidList
        return p
}</span>

func (*UidListContext) IsUidListContext() {<span class="cov0" title="0">}</span>

func NewUidListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UidListContext <span class="cov8" title="1">{
        var p = new(UidListContext)

        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

        p.parser = parser
        p.RuleIndex = MySqlParserRULE_uidList

        return p
}</span>

func (s *UidListContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *UidListContext) AllID() []antlr.TerminalNode <span class="cov8" title="1">{
        return s.GetTokens(MySqlParserID)
}</span>

func (s *UidListContext) ID(i int) antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserID, i)
}</span>

func (s *UidListContext) AllCOMMA() []antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetTokens(MySqlParserCOMMA)
}</span>

func (s *UidListContext) COMMA(i int) antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserCOMMA, i)
}</span>

func (s *UidListContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *UidListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>


func (s *UidListContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterUidList(s)
        }</span>
}

func (s *UidListContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitUidList(s)
        }</span>
}

func (s *UidListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitUidList(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}




func (p *MySqlParser) UidList() (localctx IUidListContext) <span class="cov8" title="1">{
        localctx = NewUidListContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 38, MySqlParserRULE_uidList)
        var _la int


        defer func() </span><span class="cov8" title="1">{
                p.ExitRule()
        }</span>()

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        if v, ok := err.(antlr.RecognitionException); ok </span><span class="cov0" title="0">{
                                localctx.SetException(v)
                                p.GetErrorHandler().ReportError(p, v)
                                p.GetErrorHandler().Recover(p, v)
                        }</span> else<span class="cov0" title="0"> {
                                panic(err)</span>
                        }
                }
        }()

        <span class="cov8" title="1">p.EnterOuterAlt(localctx, 1)
        </span><span class="cov8" title="1">{
                p.SetState(305)
                p.Match(MySqlParserID)
        }</span>
        <span class="cov8" title="1">p.SetState(310)
        p.GetErrorHandler().Sync(p)
        _la = p.GetTokenStream().LA(1)


        for _la == MySqlParserCOMMA </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        p.SetState(306)
                        p.Match(MySqlParserCOMMA)
                }</span>
                <span class="cov8" title="1">{
                        p.SetState(307)
                        p.Match(MySqlParserID)
                }</span>


                <span class="cov8" title="1">p.SetState(312)
                p.GetErrorHandler().Sync(p)
                _la = p.GetTokenStream().LA(1)</span>
        }



        <span class="cov8" title="1">return localctx</span>
}


// IExpressionsContext is an interface to support dynamic dispatch.
type IExpressionsContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // IsExpressionsContext differentiates from other interfaces.
        IsExpressionsContext()
}

type ExpressionsContext struct {
        *antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyExpressionsContext() *ExpressionsContext <span class="cov0" title="0">{
        var p = new(ExpressionsContext)
        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
        p.RuleIndex = MySqlParserRULE_expressions
        return p
}</span>

func (*ExpressionsContext) IsExpressionsContext() {<span class="cov0" title="0">}</span>

func NewExpressionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionsContext <span class="cov8" title="1">{
        var p = new(ExpressionsContext)

        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

        p.parser = parser
        p.RuleIndex = MySqlParserRULE_expressions

        return p
}</span>

func (s *ExpressionsContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *ExpressionsContext) AllExpression() []IExpressionContext <span class="cov8" title="1">{
        var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
        var tst = make([]IExpressionContext, len(ts))

        for i, t := range ts </span><span class="cov8" title="1">{
                if t != nil </span><span class="cov8" title="1">{
                        tst[i] = t.(IExpressionContext)
                }</span>
        }

        <span class="cov8" title="1">return tst</span>
}

func (s *ExpressionsContext) Expression(i int) IExpressionContext <span class="cov0" title="0">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IExpressionContext)</span>
}

func (s *ExpressionsContext) AllCOMMA() []antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetTokens(MySqlParserCOMMA)
}</span>

func (s *ExpressionsContext) COMMA(i int) antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserCOMMA, i)
}</span>

func (s *ExpressionsContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *ExpressionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>


func (s *ExpressionsContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterExpressions(s)
        }</span>
}

func (s *ExpressionsContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitExpressions(s)
        }</span>
}

func (s *ExpressionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitExpressions(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}




func (p *MySqlParser) Expressions() (localctx IExpressionsContext) <span class="cov8" title="1">{
        localctx = NewExpressionsContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 40, MySqlParserRULE_expressions)
        var _la int


        defer func() </span><span class="cov8" title="1">{
                p.ExitRule()
        }</span>()

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        if v, ok := err.(antlr.RecognitionException); ok </span><span class="cov0" title="0">{
                                localctx.SetException(v)
                                p.GetErrorHandler().ReportError(p, v)
                                p.GetErrorHandler().Recover(p, v)
                        }</span> else<span class="cov0" title="0"> {
                                panic(err)</span>
                        }
                }
        }()

        <span class="cov8" title="1">p.EnterOuterAlt(localctx, 1)
        </span><span class="cov8" title="1">{
                p.SetState(313)
                p.expression(0)
        }</span>
        <span class="cov8" title="1">p.SetState(318)
        p.GetErrorHandler().Sync(p)
        _la = p.GetTokenStream().LA(1)


        for _la == MySqlParserCOMMA </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        p.SetState(314)
                        p.Match(MySqlParserCOMMA)
                }</span>
                <span class="cov8" title="1">{
                        p.SetState(315)
                        p.expression(0)
                }</span>


                <span class="cov8" title="1">p.SetState(320)
                p.GetErrorHandler().Sync(p)
                _la = p.GetTokenStream().LA(1)</span>
        }



        <span class="cov8" title="1">return localctx</span>
}


// IFunctionCallContext is an interface to support dynamic dispatch.
type IFunctionCallContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // IsFunctionCallContext differentiates from other interfaces.
        IsFunctionCallContext()
}

type FunctionCallContext struct {
        *antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyFunctionCallContext() *FunctionCallContext <span class="cov8" title="1">{
        var p = new(FunctionCallContext)
        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
        p.RuleIndex = MySqlParserRULE_functionCall
        return p
}</span>

func (*FunctionCallContext) IsFunctionCallContext() {<span class="cov0" title="0">}</span>

func NewFunctionCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionCallContext <span class="cov8" title="1">{
        var p = new(FunctionCallContext)

        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

        p.parser = parser
        p.RuleIndex = MySqlParserRULE_functionCall

        return p
}</span>

func (s *FunctionCallContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *FunctionCallContext) CopyFrom(ctx *FunctionCallContext) <span class="cov8" title="1">{
        s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}</span>

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *FunctionCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>




type SpecificFunctionCallContext struct {
        *FunctionCallContext
}

func NewSpecificFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SpecificFunctionCallContext <span class="cov8" title="1">{
        var p = new(SpecificFunctionCallContext)

        p.FunctionCallContext = NewEmptyFunctionCallContext()
        p.parser = parser
        p.CopyFrom(ctx.(*FunctionCallContext))

        return p
}</span>

func (s *SpecificFunctionCallContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *SpecificFunctionCallContext) SpecificFunction() ISpecificFunctionContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecificFunctionContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(ISpecificFunctionContext)</span>
}


func (s *SpecificFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterSpecificFunctionCall(s)
        }</span>
}

func (s *SpecificFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitSpecificFunctionCall(s)
        }</span>
}

func (s *SpecificFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitSpecificFunctionCall(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}


type ScalarFunctionCallContext struct {
        *FunctionCallContext
}

func NewScalarFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ScalarFunctionCallContext <span class="cov8" title="1">{
        var p = new(ScalarFunctionCallContext)

        p.FunctionCallContext = NewEmptyFunctionCallContext()
        p.parser = parser
        p.CopyFrom(ctx.(*FunctionCallContext))

        return p
}</span>

func (s *ScalarFunctionCallContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *ScalarFunctionCallContext) ID() antlr.TerminalNode <span class="cov8" title="1">{
        return s.GetToken(MySqlParserID, 0)
}</span>

func (s *ScalarFunctionCallContext) LR_BRACKET() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserLR_BRACKET, 0)
}</span>

func (s *ScalarFunctionCallContext) RR_BRACKET() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserRR_BRACKET, 0)
}</span>

func (s *ScalarFunctionCallContext) FunctionArgs() IFunctionArgsContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionArgsContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(IFunctionArgsContext)</span>
}


func (s *ScalarFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterScalarFunctionCall(s)
        }</span>
}

func (s *ScalarFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitScalarFunctionCall(s)
        }</span>
}

func (s *ScalarFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitScalarFunctionCall(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}



func (p *MySqlParser) FunctionCall() (localctx IFunctionCallContext) <span class="cov8" title="1">{
        localctx = NewFunctionCallContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 42, MySqlParserRULE_functionCall)
        var _la int


        defer func() </span><span class="cov8" title="1">{
                p.ExitRule()
        }</span>()

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        if v, ok := err.(antlr.RecognitionException); ok </span><span class="cov0" title="0">{
                                localctx.SetException(v)
                                p.GetErrorHandler().ReportError(p, v)
                                p.GetErrorHandler().Recover(p, v)
                        }</span> else<span class="cov0" title="0"> {
                                panic(err)</span>
                        }
                }
        }()

        <span class="cov8" title="1">p.SetState(328)
        p.GetErrorHandler().Sync(p)

        switch p.GetTokenStream().LA(1) </span>{
        case MySqlParserCASE:<span class="cov8" title="1">
                localctx = NewSpecificFunctionCallContext(p, localctx)
                p.EnterOuterAlt(localctx, 1)
                </span><span class="cov8" title="1">{
                        p.SetState(321)
                        p.SpecificFunction()
                }</span>


        case MySqlParserID:<span class="cov8" title="1">
                localctx = NewScalarFunctionCallContext(p, localctx)
                p.EnterOuterAlt(localctx, 2)
                </span><span class="cov8" title="1">{
                        p.SetState(322)
                        p.Match(MySqlParserID)
                }</span>
                <span class="cov8" title="1">{
                        p.SetState(323)
                        p.Match(MySqlParserLR_BRACKET)
                }</span>
                <span class="cov8" title="1">p.SetState(325)
                p.GetErrorHandler().Sync(p)
                _la = p.GetTokenStream().LA(1)


                if (((_la) &amp; -(0x1f+1)) == 0 &amp;&amp; ((1 &lt;&lt; uint(_la)) &amp; ((1 &lt;&lt; MySqlParserALL) | (1 &lt;&lt; MySqlParserCASE) | (1 &lt;&lt; MySqlParserEXISTS) | (1 &lt;&lt; MySqlParserFALSE) | (1 &lt;&lt; MySqlParserNOT) | (1 &lt;&lt; MySqlParserNULL_LITERAL))) != 0) || ((((_la - 40)) &amp; -(0x1f+1)) == 0 &amp;&amp; ((1 &lt;&lt; uint((_la - 40))) &amp; ((1 &lt;&lt; (MySqlParserTRUE - 40)) | (1 &lt;&lt; (MySqlParserSTAR - 40)) | (1 &lt;&lt; (MySqlParserPLUS - 40)) | (1 &lt;&lt; (MySqlParserMINUS - 40)) | (1 &lt;&lt; (MySqlParserEXCLAMATION_SYMBOL - 40)) | (1 &lt;&lt; (MySqlParserBIT_NOT_OP - 40)))) != 0) || ((((_la - 75)) &amp; -(0x1f+1)) == 0 &amp;&amp; ((1 &lt;&lt; uint((_la - 75))) &amp; ((1 &lt;&lt; (MySqlParserLR_BRACKET - 75)) | (1 &lt;&lt; (MySqlParserSTRING_LITERAL - 75)) | (1 &lt;&lt; (MySqlParserDECIMAL_LITERAL - 75)) | (1 &lt;&lt; (MySqlParserREAL_LITERAL - 75)) | (1 &lt;&lt; (MySqlParserNULL_SPEC_LITERAL - 75)) | (1 &lt;&lt; (MySqlParserID - 75)))) != 0) </span><span class="cov8" title="1">{
                        </span><span class="cov8" title="1">{
                                p.SetState(324)
                                p.FunctionArgs()
                        }</span>

                }
                <span class="cov8" title="1">{
                        p.SetState(327)
                        p.Match(MySqlParserRR_BRACKET)
                }</span>



        default:<span class="cov0" title="0">
                panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))</span>
        }


        <span class="cov8" title="1">return localctx</span>
}


// ISpecificFunctionContext is an interface to support dynamic dispatch.
type ISpecificFunctionContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // IsSpecificFunctionContext differentiates from other interfaces.
        IsSpecificFunctionContext()
}

type SpecificFunctionContext struct {
        *antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptySpecificFunctionContext() *SpecificFunctionContext <span class="cov8" title="1">{
        var p = new(SpecificFunctionContext)
        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
        p.RuleIndex = MySqlParserRULE_specificFunction
        return p
}</span>

func (*SpecificFunctionContext) IsSpecificFunctionContext() {<span class="cov0" title="0">}</span>

func NewSpecificFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpecificFunctionContext <span class="cov8" title="1">{
        var p = new(SpecificFunctionContext)

        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

        p.parser = parser
        p.RuleIndex = MySqlParserRULE_specificFunction

        return p
}</span>

func (s *SpecificFunctionContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *SpecificFunctionContext) CopyFrom(ctx *SpecificFunctionContext) <span class="cov8" title="1">{
        s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}</span>

func (s *SpecificFunctionContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *SpecificFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>




type CaseVarFunctionCallContext struct {
        *SpecificFunctionContext
        elseArg IFunctionArgContext 
}

func NewCaseVarFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CaseVarFunctionCallContext <span class="cov8" title="1">{
        var p = new(CaseVarFunctionCallContext)

        p.SpecificFunctionContext = NewEmptySpecificFunctionContext()
        p.parser = parser
        p.CopyFrom(ctx.(*SpecificFunctionContext))

        return p
}</span>


func (s *CaseVarFunctionCallContext) GetElseArg() IFunctionArgContext <span class="cov0" title="0">{ return s.elseArg }</span>


func (s *CaseVarFunctionCallContext) SetElseArg(v IFunctionArgContext) <span class="cov0" title="0">{ s.elseArg = v }</span>

func (s *CaseVarFunctionCallContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *CaseVarFunctionCallContext) CASE() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserCASE, 0)
}</span>

func (s *CaseVarFunctionCallContext) FullColumnName() IFullColumnNameContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IFullColumnNameContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(IFullColumnNameContext)</span>
}

func (s *CaseVarFunctionCallContext) END() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserEND, 0)
}</span>

func (s *CaseVarFunctionCallContext) AllCaseFuncAlternative() []ICaseFuncAlternativeContext <span class="cov8" title="1">{
        var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICaseFuncAlternativeContext)(nil)).Elem())
        var tst = make([]ICaseFuncAlternativeContext, len(ts))

        for i, t := range ts </span><span class="cov8" title="1">{
                if t != nil </span><span class="cov8" title="1">{
                        tst[i] = t.(ICaseFuncAlternativeContext)
                }</span>
        }

        <span class="cov8" title="1">return tst</span>
}

func (s *CaseVarFunctionCallContext) CaseFuncAlternative(i int) ICaseFuncAlternativeContext <span class="cov0" title="0">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*ICaseFuncAlternativeContext)(nil)).Elem(), i)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(ICaseFuncAlternativeContext)</span>
}

func (s *CaseVarFunctionCallContext) ELSE() antlr.TerminalNode <span class="cov8" title="1">{
        return s.GetToken(MySqlParserELSE, 0)
}</span>

func (s *CaseVarFunctionCallContext) FunctionArg() IFunctionArgContext <span class="cov0" title="0">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionArgContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IFunctionArgContext)</span>
}


func (s *CaseVarFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterCaseVarFunctionCall(s)
        }</span>
}

func (s *CaseVarFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitCaseVarFunctionCall(s)
        }</span>
}

func (s *CaseVarFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitCaseVarFunctionCall(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}


type CaseFunctionCallContext struct {
        *SpecificFunctionContext
        elseArg IFunctionArgContext 
}

func NewCaseFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CaseFunctionCallContext <span class="cov8" title="1">{
        var p = new(CaseFunctionCallContext)

        p.SpecificFunctionContext = NewEmptySpecificFunctionContext()
        p.parser = parser
        p.CopyFrom(ctx.(*SpecificFunctionContext))

        return p
}</span>


func (s *CaseFunctionCallContext) GetElseArg() IFunctionArgContext <span class="cov0" title="0">{ return s.elseArg }</span>


func (s *CaseFunctionCallContext) SetElseArg(v IFunctionArgContext) <span class="cov0" title="0">{ s.elseArg = v }</span>

func (s *CaseFunctionCallContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *CaseFunctionCallContext) CASE() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserCASE, 0)
}</span>

func (s *CaseFunctionCallContext) END() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserEND, 0)
}</span>

func (s *CaseFunctionCallContext) AllCaseFuncAlternative() []ICaseFuncAlternativeContext <span class="cov8" title="1">{
        var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICaseFuncAlternativeContext)(nil)).Elem())
        var tst = make([]ICaseFuncAlternativeContext, len(ts))

        for i, t := range ts </span><span class="cov8" title="1">{
                if t != nil </span><span class="cov8" title="1">{
                        tst[i] = t.(ICaseFuncAlternativeContext)
                }</span>
        }

        <span class="cov8" title="1">return tst</span>
}

func (s *CaseFunctionCallContext) CaseFuncAlternative(i int) ICaseFuncAlternativeContext <span class="cov0" title="0">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*ICaseFuncAlternativeContext)(nil)).Elem(), i)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(ICaseFuncAlternativeContext)</span>
}

func (s *CaseFunctionCallContext) ELSE() antlr.TerminalNode <span class="cov8" title="1">{
        return s.GetToken(MySqlParserELSE, 0)
}</span>

func (s *CaseFunctionCallContext) FunctionArg() IFunctionArgContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionArgContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(IFunctionArgContext)</span>
}


func (s *CaseFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterCaseFunctionCall(s)
        }</span>
}

func (s *CaseFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitCaseFunctionCall(s)
        }</span>
}

func (s *CaseFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitCaseFunctionCall(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}



func (p *MySqlParser) SpecificFunction() (localctx ISpecificFunctionContext) <span class="cov8" title="1">{
        localctx = NewSpecificFunctionContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 44, MySqlParserRULE_specificFunction)
        var _la int


        defer func() </span><span class="cov8" title="1">{
                p.ExitRule()
        }</span>()

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        if v, ok := err.(antlr.RecognitionException); ok </span><span class="cov0" title="0">{
                                localctx.SetException(v)
                                p.GetErrorHandler().ReportError(p, v)
                                p.GetErrorHandler().Recover(p, v)
                        }</span> else<span class="cov0" title="0"> {
                                panic(err)</span>
                        }
                }
        }()

        <span class="cov8" title="1">p.SetState(355)
        p.GetErrorHandler().Sync(p)
        switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 51, p.GetParserRuleContext()) </span>{
        case 1:<span class="cov8" title="1">
                localctx = NewCaseVarFunctionCallContext(p, localctx)
                p.EnterOuterAlt(localctx, 1)
                </span><span class="cov8" title="1">{
                        p.SetState(330)
                        p.Match(MySqlParserCASE)
                }</span>
                <span class="cov8" title="1">{
                        p.SetState(331)
                        p.FullColumnName()
                }</span>
                <span class="cov8" title="1">p.SetState(333)
                p.GetErrorHandler().Sync(p)
                _la = p.GetTokenStream().LA(1)


                for ok := true; ok; ok = _la == MySqlParserWHEN </span><span class="cov8" title="1">{
                        </span><span class="cov8" title="1">{
                                p.SetState(332)
                                p.CaseFuncAlternative()
                        }</span>


                        <span class="cov8" title="1">p.SetState(335)
                        p.GetErrorHandler().Sync(p)
                        _la = p.GetTokenStream().LA(1)</span>
                }
                <span class="cov8" title="1">p.SetState(339)
                p.GetErrorHandler().Sync(p)
                _la = p.GetTokenStream().LA(1)


                if _la == MySqlParserELSE </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                p.SetState(337)
                                p.Match(MySqlParserELSE)
                        }</span>
                        <span class="cov0" title="0">{
                                p.SetState(338)

                                var _x = p.FunctionArg()


                                localctx.(*CaseVarFunctionCallContext).elseArg = _x
                        }</span>

                }
                <span class="cov8" title="1">{
                        p.SetState(341)
                        p.Match(MySqlParserEND)
                }</span>


        case 2:<span class="cov8" title="1">
                localctx = NewCaseFunctionCallContext(p, localctx)
                p.EnterOuterAlt(localctx, 2)
                </span><span class="cov8" title="1">{
                        p.SetState(343)
                        p.Match(MySqlParserCASE)
                }</span>
                <span class="cov8" title="1">p.SetState(345)
                p.GetErrorHandler().Sync(p)
                _la = p.GetTokenStream().LA(1)


                for ok := true; ok; ok = _la == MySqlParserWHEN </span><span class="cov8" title="1">{
                        </span><span class="cov8" title="1">{
                                p.SetState(344)
                                p.CaseFuncAlternative()
                        }</span>


                        <span class="cov8" title="1">p.SetState(347)
                        p.GetErrorHandler().Sync(p)
                        _la = p.GetTokenStream().LA(1)</span>
                }
                <span class="cov8" title="1">p.SetState(351)
                p.GetErrorHandler().Sync(p)
                _la = p.GetTokenStream().LA(1)


                if _la == MySqlParserELSE </span><span class="cov8" title="1">{
                        </span><span class="cov8" title="1">{
                                p.SetState(349)
                                p.Match(MySqlParserELSE)
                        }</span>
                        <span class="cov8" title="1">{
                                p.SetState(350)

                                var _x = p.FunctionArg()


                                localctx.(*CaseFunctionCallContext).elseArg = _x
                        }</span>

                }
                <span class="cov8" title="1">{
                        p.SetState(353)
                        p.Match(MySqlParserEND)
                }</span>

        }


        <span class="cov8" title="1">return localctx</span>
}


// ICaseFuncAlternativeContext is an interface to support dynamic dispatch.
type ICaseFuncAlternativeContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // GetCondition returns the condition rule contexts.
        GetCondition() IFunctionArgContext

        // GetConsequent returns the consequent rule contexts.
        GetConsequent() IFunctionArgContext


        // SetCondition sets the condition rule contexts.
        SetCondition(IFunctionArgContext)

        // SetConsequent sets the consequent rule contexts.
        SetConsequent(IFunctionArgContext)


        // IsCaseFuncAlternativeContext differentiates from other interfaces.
        IsCaseFuncAlternativeContext()
}

type CaseFuncAlternativeContext struct {
        *antlr.BaseParserRuleContext
        parser antlr.Parser
        condition IFunctionArgContext 
        consequent IFunctionArgContext 
}

func NewEmptyCaseFuncAlternativeContext() *CaseFuncAlternativeContext <span class="cov0" title="0">{
        var p = new(CaseFuncAlternativeContext)
        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
        p.RuleIndex = MySqlParserRULE_caseFuncAlternative
        return p
}</span>

func (*CaseFuncAlternativeContext) IsCaseFuncAlternativeContext() {<span class="cov0" title="0">}</span>

func NewCaseFuncAlternativeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseFuncAlternativeContext <span class="cov8" title="1">{
        var p = new(CaseFuncAlternativeContext)

        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

        p.parser = parser
        p.RuleIndex = MySqlParserRULE_caseFuncAlternative

        return p
}</span>

func (s *CaseFuncAlternativeContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *CaseFuncAlternativeContext) GetCondition() IFunctionArgContext <span class="cov0" title="0">{ return s.condition }</span>

func (s *CaseFuncAlternativeContext) GetConsequent() IFunctionArgContext <span class="cov0" title="0">{ return s.consequent }</span>


func (s *CaseFuncAlternativeContext) SetCondition(v IFunctionArgContext) <span class="cov0" title="0">{ s.condition = v }</span>

func (s *CaseFuncAlternativeContext) SetConsequent(v IFunctionArgContext) <span class="cov0" title="0">{ s.consequent = v }</span>


func (s *CaseFuncAlternativeContext) WHEN() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserWHEN, 0)
}</span>

func (s *CaseFuncAlternativeContext) THEN() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserTHEN, 0)
}</span>

func (s *CaseFuncAlternativeContext) AllFunctionArg() []IFunctionArgContext <span class="cov0" title="0">{
        var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunctionArgContext)(nil)).Elem())
        var tst = make([]IFunctionArgContext, len(ts))

        for i, t := range ts </span><span class="cov0" title="0">{
                if t != nil </span><span class="cov0" title="0">{
                        tst[i] = t.(IFunctionArgContext)
                }</span>
        }

        <span class="cov0" title="0">return tst</span>
}

func (s *CaseFuncAlternativeContext) FunctionArg(i int) IFunctionArgContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionArgContext)(nil)).Elem(), i)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(IFunctionArgContext)</span>
}

func (s *CaseFuncAlternativeContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *CaseFuncAlternativeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>


func (s *CaseFuncAlternativeContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterCaseFuncAlternative(s)
        }</span>
}

func (s *CaseFuncAlternativeContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitCaseFuncAlternative(s)
        }</span>
}

func (s *CaseFuncAlternativeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitCaseFuncAlternative(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}




func (p *MySqlParser) CaseFuncAlternative() (localctx ICaseFuncAlternativeContext) <span class="cov8" title="1">{
        localctx = NewCaseFuncAlternativeContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 46, MySqlParserRULE_caseFuncAlternative)

        defer func() </span><span class="cov8" title="1">{
                p.ExitRule()
        }</span>()

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        if v, ok := err.(antlr.RecognitionException); ok </span><span class="cov0" title="0">{
                                localctx.SetException(v)
                                p.GetErrorHandler().ReportError(p, v)
                                p.GetErrorHandler().Recover(p, v)
                        }</span> else<span class="cov0" title="0"> {
                                panic(err)</span>
                        }
                }
        }()

        <span class="cov8" title="1">p.EnterOuterAlt(localctx, 1)
        </span><span class="cov8" title="1">{
                p.SetState(357)
                p.Match(MySqlParserWHEN)
        }</span>
        <span class="cov8" title="1">{
                p.SetState(358)

                var _x = p.FunctionArg()


                localctx.(*CaseFuncAlternativeContext).condition = _x
        }</span>
        <span class="cov8" title="1">{
                p.SetState(359)
                p.Match(MySqlParserTHEN)
        }</span>
        <span class="cov8" title="1">{
                p.SetState(360)

                var _x = p.FunctionArg()


                localctx.(*CaseFuncAlternativeContext).consequent = _x
        }</span>



        <span class="cov8" title="1">return localctx</span>
}


// IFunctionArgsContext is an interface to support dynamic dispatch.
type IFunctionArgsContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // IsFunctionArgsContext differentiates from other interfaces.
        IsFunctionArgsContext()
}

type FunctionArgsContext struct {
        *antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyFunctionArgsContext() *FunctionArgsContext <span class="cov0" title="0">{
        var p = new(FunctionArgsContext)
        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
        p.RuleIndex = MySqlParserRULE_functionArgs
        return p
}</span>

func (*FunctionArgsContext) IsFunctionArgsContext() {<span class="cov0" title="0">}</span>

func NewFunctionArgsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionArgsContext <span class="cov8" title="1">{
        var p = new(FunctionArgsContext)

        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

        p.parser = parser
        p.RuleIndex = MySqlParserRULE_functionArgs

        return p
}</span>

func (s *FunctionArgsContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *FunctionArgsContext) AllAllFunctionArg() []IAllFunctionArgContext <span class="cov8" title="1">{
        var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAllFunctionArgContext)(nil)).Elem())
        var tst = make([]IAllFunctionArgContext, len(ts))

        for i, t := range ts </span><span class="cov8" title="1">{
                if t != nil </span><span class="cov8" title="1">{
                        tst[i] = t.(IAllFunctionArgContext)
                }</span>
        }

        <span class="cov8" title="1">return tst</span>
}

func (s *FunctionArgsContext) AllFunctionArg(i int) IAllFunctionArgContext <span class="cov0" title="0">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IAllFunctionArgContext)(nil)).Elem(), i)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IAllFunctionArgContext)</span>
}

func (s *FunctionArgsContext) AllCOMMA() []antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetTokens(MySqlParserCOMMA)
}</span>

func (s *FunctionArgsContext) COMMA(i int) antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserCOMMA, i)
}</span>

func (s *FunctionArgsContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *FunctionArgsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>


func (s *FunctionArgsContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterFunctionArgs(s)
        }</span>
}

func (s *FunctionArgsContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitFunctionArgs(s)
        }</span>
}

func (s *FunctionArgsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitFunctionArgs(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}




func (p *MySqlParser) FunctionArgs() (localctx IFunctionArgsContext) <span class="cov8" title="1">{
        localctx = NewFunctionArgsContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 48, MySqlParserRULE_functionArgs)
        var _la int


        defer func() </span><span class="cov8" title="1">{
                p.ExitRule()
        }</span>()

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        if v, ok := err.(antlr.RecognitionException); ok </span><span class="cov0" title="0">{
                                localctx.SetException(v)
                                p.GetErrorHandler().ReportError(p, v)
                                p.GetErrorHandler().Recover(p, v)
                        }</span> else<span class="cov0" title="0"> {
                                panic(err)</span>
                        }
                }
        }()

        <span class="cov8" title="1">p.EnterOuterAlt(localctx, 1)
        </span><span class="cov8" title="1">{
                p.SetState(362)
                p.AllFunctionArg()
        }</span>

        <span class="cov8" title="1">p.SetState(367)
        p.GetErrorHandler().Sync(p)
        _la = p.GetTokenStream().LA(1)


        for _la == MySqlParserCOMMA </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        p.SetState(363)
                        p.Match(MySqlParserCOMMA)
                }</span>

                <span class="cov8" title="1">{
                        p.SetState(364)
                        p.AllFunctionArg()
                }</span>



                <span class="cov8" title="1">p.SetState(369)
                p.GetErrorHandler().Sync(p)
                _la = p.GetTokenStream().LA(1)</span>
        }



        <span class="cov8" title="1">return localctx</span>
}


// IAllFunctionArgContext is an interface to support dynamic dispatch.
type IAllFunctionArgContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // IsAllFunctionArgContext differentiates from other interfaces.
        IsAllFunctionArgContext()
}

type AllFunctionArgContext struct {
        *antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyAllFunctionArgContext() *AllFunctionArgContext <span class="cov0" title="0">{
        var p = new(AllFunctionArgContext)
        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
        p.RuleIndex = MySqlParserRULE_allFunctionArg
        return p
}</span>

func (*AllFunctionArgContext) IsAllFunctionArgContext() {<span class="cov0" title="0">}</span>

func NewAllFunctionArgContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AllFunctionArgContext <span class="cov8" title="1">{
        var p = new(AllFunctionArgContext)

        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

        p.parser = parser
        p.RuleIndex = MySqlParserRULE_allFunctionArg

        return p
}</span>

func (s *AllFunctionArgContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *AllFunctionArgContext) STAR() antlr.TerminalNode <span class="cov8" title="1">{
        return s.GetToken(MySqlParserSTAR, 0)
}</span>

func (s *AllFunctionArgContext) ALL() antlr.TerminalNode <span class="cov8" title="1">{
        return s.GetToken(MySqlParserALL, 0)
}</span>

func (s *AllFunctionArgContext) Constant() IConstantContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(IConstantContext)</span>
}

func (s *AllFunctionArgContext) FullColumnName() IFullColumnNameContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IFullColumnNameContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(IFullColumnNameContext)</span>
}

func (s *AllFunctionArgContext) FunctionCall() IFunctionCallContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionCallContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(IFunctionCallContext)</span>
}

func (s *AllFunctionArgContext) Expression() IExpressionContext <span class="cov0" title="0">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IExpressionContext)</span>
}

func (s *AllFunctionArgContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *AllFunctionArgContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>


func (s *AllFunctionArgContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterAllFunctionArg(s)
        }</span>
}

func (s *AllFunctionArgContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitAllFunctionArg(s)
        }</span>
}

func (s *AllFunctionArgContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitAllFunctionArg(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}




func (p *MySqlParser) AllFunctionArg() (localctx IAllFunctionArgContext) <span class="cov8" title="1">{
        localctx = NewAllFunctionArgContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 50, MySqlParserRULE_allFunctionArg)

        defer func() </span><span class="cov8" title="1">{
                p.ExitRule()
        }</span>()

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        if v, ok := err.(antlr.RecognitionException); ok </span><span class="cov0" title="0">{
                                localctx.SetException(v)
                                p.GetErrorHandler().ReportError(p, v)
                                p.GetErrorHandler().Recover(p, v)
                        }</span> else<span class="cov0" title="0"> {
                                panic(err)</span>
                        }
                }
        }()

        <span class="cov8" title="1">p.SetState(376)
        p.GetErrorHandler().Sync(p)
        switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 53, p.GetParserRuleContext()) </span>{
        case 1:<span class="cov8" title="1">
                p.EnterOuterAlt(localctx, 1)
                </span><span class="cov8" title="1">{
                        p.SetState(370)
                        p.Match(MySqlParserSTAR)
                }</span>


        case 2:<span class="cov0" title="0">
                p.EnterOuterAlt(localctx, 2)
                </span><span class="cov0" title="0">{
                        p.SetState(371)
                        p.Match(MySqlParserALL)
                }</span>


        case 3:<span class="cov8" title="1">
                p.EnterOuterAlt(localctx, 3)
                </span><span class="cov8" title="1">{
                        p.SetState(372)
                        p.Constant()
                }</span>


        case 4:<span class="cov8" title="1">
                p.EnterOuterAlt(localctx, 4)
                </span><span class="cov8" title="1">{
                        p.SetState(373)
                        p.FullColumnName()
                }</span>


        case 5:<span class="cov8" title="1">
                p.EnterOuterAlt(localctx, 5)
                </span><span class="cov8" title="1">{
                        p.SetState(374)
                        p.FunctionCall()
                }</span>


        case 6:<span class="cov0" title="0">
                p.EnterOuterAlt(localctx, 6)
                </span><span class="cov0" title="0">{
                        p.SetState(375)
                        p.expression(0)
                }</span>

        }


        <span class="cov8" title="1">return localctx</span>
}


// IFunctionArgContext is an interface to support dynamic dispatch.
type IFunctionArgContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // IsFunctionArgContext differentiates from other interfaces.
        IsFunctionArgContext()
}

type FunctionArgContext struct {
        *antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyFunctionArgContext() *FunctionArgContext <span class="cov0" title="0">{
        var p = new(FunctionArgContext)
        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
        p.RuleIndex = MySqlParserRULE_functionArg
        return p
}</span>

func (*FunctionArgContext) IsFunctionArgContext() {<span class="cov0" title="0">}</span>

func NewFunctionArgContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionArgContext <span class="cov8" title="1">{
        var p = new(FunctionArgContext)

        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

        p.parser = parser
        p.RuleIndex = MySqlParserRULE_functionArg

        return p
}</span>

func (s *FunctionArgContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *FunctionArgContext) Constant() IConstantContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(IConstantContext)</span>
}

func (s *FunctionArgContext) FullColumnName() IFullColumnNameContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IFullColumnNameContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(IFullColumnNameContext)</span>
}

func (s *FunctionArgContext) FunctionCall() IFunctionCallContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionCallContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IFunctionCallContext)</span>
}

func (s *FunctionArgContext) Expression() IExpressionContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(IExpressionContext)</span>
}

func (s *FunctionArgContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *FunctionArgContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>


func (s *FunctionArgContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterFunctionArg(s)
        }</span>
}

func (s *FunctionArgContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitFunctionArg(s)
        }</span>
}

func (s *FunctionArgContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitFunctionArg(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}




func (p *MySqlParser) FunctionArg() (localctx IFunctionArgContext) <span class="cov8" title="1">{
        localctx = NewFunctionArgContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 52, MySqlParserRULE_functionArg)

        defer func() </span><span class="cov8" title="1">{
                p.ExitRule()
        }</span>()

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        if v, ok := err.(antlr.RecognitionException); ok </span><span class="cov0" title="0">{
                                localctx.SetException(v)
                                p.GetErrorHandler().ReportError(p, v)
                                p.GetErrorHandler().Recover(p, v)
                        }</span> else<span class="cov0" title="0"> {
                                panic(err)</span>
                        }
                }
        }()

        <span class="cov8" title="1">p.SetState(382)
        p.GetErrorHandler().Sync(p)
        switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 54, p.GetParserRuleContext()) </span>{
        case 1:<span class="cov8" title="1">
                p.EnterOuterAlt(localctx, 1)
                </span><span class="cov8" title="1">{
                        p.SetState(378)
                        p.Constant()
                }</span>


        case 2:<span class="cov8" title="1">
                p.EnterOuterAlt(localctx, 2)
                </span><span class="cov8" title="1">{
                        p.SetState(379)
                        p.FullColumnName()
                }</span>


        case 3:<span class="cov0" title="0">
                p.EnterOuterAlt(localctx, 3)
                </span><span class="cov0" title="0">{
                        p.SetState(380)
                        p.FunctionCall()
                }</span>


        case 4:<span class="cov8" title="1">
                p.EnterOuterAlt(localctx, 4)
                </span><span class="cov8" title="1">{
                        p.SetState(381)
                        p.expression(0)
                }</span>

        }


        <span class="cov8" title="1">return localctx</span>
}


// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // IsExpressionContext differentiates from other interfaces.
        IsExpressionContext()
}

type ExpressionContext struct {
        *antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext <span class="cov8" title="1">{
        var p = new(ExpressionContext)
        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
        p.RuleIndex = MySqlParserRULE_expression
        return p
}</span>

func (*ExpressionContext) IsExpressionContext() {<span class="cov0" title="0">}</span>

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext <span class="cov8" title="1">{
        var p = new(ExpressionContext)

        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

        p.parser = parser
        p.RuleIndex = MySqlParserRULE_expression

        return p
}</span>

func (s *ExpressionContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *ExpressionContext) CopyFrom(ctx *ExpressionContext) <span class="cov8" title="1">{
        s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}</span>

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>





type IsExpressionContext struct {
        *ExpressionContext
        testValue antlr.Token
}

func NewIsExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IsExpressionContext <span class="cov0" title="0">{
        var p = new(IsExpressionContext)

        p.ExpressionContext = NewEmptyExpressionContext()
        p.parser = parser
        p.CopyFrom(ctx.(*ExpressionContext))

        return p
}</span>


func (s *IsExpressionContext) GetTestValue() antlr.Token <span class="cov0" title="0">{ return s.testValue }</span>


func (s *IsExpressionContext) SetTestValue(v antlr.Token) <span class="cov0" title="0">{ s.testValue = v }</span>

func (s *IsExpressionContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *IsExpressionContext) Predicate() IPredicateContext <span class="cov0" title="0">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IPredicateContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IPredicateContext)</span>
}

func (s *IsExpressionContext) IS() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserIS, 0)
}</span>

func (s *IsExpressionContext) TRUE() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserTRUE, 0)
}</span>

func (s *IsExpressionContext) FALSE() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserFALSE, 0)
}</span>

func (s *IsExpressionContext) UNKNOWN() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserUNKNOWN, 0)
}</span>

func (s *IsExpressionContext) NOT() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserNOT, 0)
}</span>


func (s *IsExpressionContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterIsExpression(s)
        }</span>
}

func (s *IsExpressionContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitIsExpression(s)
        }</span>
}

func (s *IsExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitIsExpression(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}


type NotExpressionContext struct {
        *ExpressionContext
        notOperator antlr.Token
}

func NewNotExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NotExpressionContext <span class="cov0" title="0">{
        var p = new(NotExpressionContext)

        p.ExpressionContext = NewEmptyExpressionContext()
        p.parser = parser
        p.CopyFrom(ctx.(*ExpressionContext))

        return p
}</span>


func (s *NotExpressionContext) GetNotOperator() antlr.Token <span class="cov0" title="0">{ return s.notOperator }</span>


func (s *NotExpressionContext) SetNotOperator(v antlr.Token) <span class="cov0" title="0">{ s.notOperator = v }</span>

func (s *NotExpressionContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *NotExpressionContext) Expression() IExpressionContext <span class="cov0" title="0">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IExpressionContext)</span>
}

func (s *NotExpressionContext) NOT() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserNOT, 0)
}</span>

func (s *NotExpressionContext) EXCLAMATION_SYMBOL() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserEXCLAMATION_SYMBOL, 0)
}</span>


func (s *NotExpressionContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterNotExpression(s)
        }</span>
}

func (s *NotExpressionContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitNotExpression(s)
        }</span>
}

func (s *NotExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitNotExpression(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}


type LogicalExpressionContext struct {
        *ExpressionContext
}

func NewLogicalExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalExpressionContext <span class="cov8" title="1">{
        var p = new(LogicalExpressionContext)

        p.ExpressionContext = NewEmptyExpressionContext()
        p.parser = parser
        p.CopyFrom(ctx.(*ExpressionContext))

        return p
}</span>

func (s *LogicalExpressionContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *LogicalExpressionContext) AllExpression() []IExpressionContext <span class="cov0" title="0">{
        var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
        var tst = make([]IExpressionContext, len(ts))

        for i, t := range ts </span><span class="cov0" title="0">{
                if t != nil </span><span class="cov0" title="0">{
                        tst[i] = t.(IExpressionContext)
                }</span>
        }

        <span class="cov0" title="0">return tst</span>
}

func (s *LogicalExpressionContext) Expression(i int) IExpressionContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(IExpressionContext)</span>
}

func (s *LogicalExpressionContext) LogicalOperator() ILogicalOperatorContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*ILogicalOperatorContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(ILogicalOperatorContext)</span>
}


func (s *LogicalExpressionContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterLogicalExpression(s)
        }</span>
}

func (s *LogicalExpressionContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitLogicalExpression(s)
        }</span>
}

func (s *LogicalExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitLogicalExpression(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}


type PredicateExpressionContext struct {
        *ExpressionContext
}

func NewPredicateExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PredicateExpressionContext <span class="cov8" title="1">{
        var p = new(PredicateExpressionContext)

        p.ExpressionContext = NewEmptyExpressionContext()
        p.parser = parser
        p.CopyFrom(ctx.(*ExpressionContext))

        return p
}</span>

func (s *PredicateExpressionContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *PredicateExpressionContext) Predicate() IPredicateContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IPredicateContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(IPredicateContext)</span>
}


func (s *PredicateExpressionContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterPredicateExpression(s)
        }</span>
}

func (s *PredicateExpressionContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitPredicateExpression(s)
        }</span>
}

func (s *PredicateExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitPredicateExpression(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}



func (p *MySqlParser) Expression() (localctx IExpressionContext) <span class="cov0" title="0">{
        return p.expression(0)
}</span>

func (p *MySqlParser) expression(_p int) (localctx IExpressionContext) <span class="cov8" title="1">{
        var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
        _parentState := p.GetState()
        localctx = NewExpressionContext(p, p.GetParserRuleContext(), _parentState)
        var _prevctx IExpressionContext = localctx
        var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
        _startState := 54
        p.EnterRecursionRule(localctx, 54, MySqlParserRULE_expression, _p)
        var _la int


        defer func() </span><span class="cov8" title="1">{
                p.UnrollRecursionContexts(_parentctx)
        }</span>()

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        if v, ok := err.(antlr.RecognitionException); ok </span><span class="cov0" title="0">{
                                localctx.SetException(v)
                                p.GetErrorHandler().ReportError(p, v)
                                p.GetErrorHandler().Recover(p, v)
                        }</span> else<span class="cov0" title="0"> {
                                panic(err)</span>
                        }
                }
        }()

        <span class="cov8" title="1">var _alt int

        p.EnterOuterAlt(localctx, 1)
        p.SetState(395)
        p.GetErrorHandler().Sync(p)
        switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 56, p.GetParserRuleContext()) </span>{
        case 1:<span class="cov0" title="0">
                localctx = NewNotExpressionContext(p, localctx)
                p.SetParserRuleContext(localctx)
                _prevctx = localctx

                </span><span class="cov0" title="0">{
                        p.SetState(385)

                        var _lt = p.GetTokenStream().LT(1)

                        localctx.(*NotExpressionContext).notOperator = _lt

                        _la = p.GetTokenStream().LA(1)

                        if !(_la == MySqlParserNOT || _la == MySqlParserEXCLAMATION_SYMBOL) </span><span class="cov0" title="0">{
                                var _ri = p.GetErrorHandler().RecoverInline(p)

                                localctx.(*NotExpressionContext).notOperator = _ri
                        }</span> else<span class="cov0" title="0"> {
                                p.GetErrorHandler().ReportMatch(p)
                                p.Consume()
                        }</span>
                }
                <span class="cov0" title="0">{
                        p.SetState(386)
                        p.expression(4)
                }</span>


        case 2:<span class="cov0" title="0">
                localctx = NewIsExpressionContext(p, localctx)
                p.SetParserRuleContext(localctx)
                _prevctx = localctx
                </span><span class="cov0" title="0">{
                        p.SetState(387)
                        p.predicate(0)
                }</span>
                <span class="cov0" title="0">{
                        p.SetState(388)
                        p.Match(MySqlParserIS)
                }</span>
                <span class="cov0" title="0">p.SetState(390)
                p.GetErrorHandler().Sync(p)
                _la = p.GetTokenStream().LA(1)


                if _la == MySqlParserNOT </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                p.SetState(389)
                                p.Match(MySqlParserNOT)
                        }</span>

                }
                <span class="cov0" title="0">{
                        p.SetState(392)

                        var _lt = p.GetTokenStream().LT(1)

                        localctx.(*IsExpressionContext).testValue = _lt

                        _la = p.GetTokenStream().LA(1)

                        if !(_la == MySqlParserFALSE || _la == MySqlParserTRUE || _la == MySqlParserUNKNOWN) </span><span class="cov0" title="0">{
                                var _ri = p.GetErrorHandler().RecoverInline(p)

                                localctx.(*IsExpressionContext).testValue = _ri
                        }</span> else<span class="cov0" title="0"> {
                                p.GetErrorHandler().ReportMatch(p)
                                p.Consume()
                        }</span>
                }


        case 3:<span class="cov8" title="1">
                localctx = NewPredicateExpressionContext(p, localctx)
                p.SetParserRuleContext(localctx)
                _prevctx = localctx
                </span><span class="cov8" title="1">{
                        p.SetState(394)
                        p.predicate(0)
                }</span>

        }
        <span class="cov8" title="1">p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
        p.SetState(403)
        p.GetErrorHandler().Sync(p)
        _alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 57, p.GetParserRuleContext())

        for _alt != 2 &amp;&amp; _alt != antlr.ATNInvalidAltNumber </span><span class="cov8" title="1">{
                if _alt == 1 </span><span class="cov8" title="1">{
                        if p.GetParseListeners() != nil </span><span class="cov8" title="1">{
                                p.TriggerExitRuleEvent()
                        }</span>
                        <span class="cov8" title="1">_prevctx = localctx
                        localctx = NewLogicalExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
                        p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_expression)
                        p.SetState(397)

                        if !(p.Precpred(p.GetParserRuleContext(), 3)) </span><span class="cov0" title="0">{
                                panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))</span>
                        }
                        <span class="cov8" title="1">{
                                p.SetState(398)
                                p.LogicalOperator()
                        }</span>
                        <span class="cov8" title="1">{
                                p.SetState(399)
                                p.expression(4)
                        }</span>


                }
                <span class="cov8" title="1">p.SetState(405)
                p.GetErrorHandler().Sync(p)
                _alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 57, p.GetParserRuleContext())</span>
        }



        <span class="cov8" title="1">return localctx</span>
}


// IPredicateContext is an interface to support dynamic dispatch.
type IPredicateContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // IsPredicateContext differentiates from other interfaces.
        IsPredicateContext()
}

type PredicateContext struct {
        *antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyPredicateContext() *PredicateContext <span class="cov8" title="1">{
        var p = new(PredicateContext)
        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
        p.RuleIndex = MySqlParserRULE_predicate
        return p
}</span>

func (*PredicateContext) IsPredicateContext() {<span class="cov0" title="0">}</span>

func NewPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredicateContext <span class="cov8" title="1">{
        var p = new(PredicateContext)

        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

        p.parser = parser
        p.RuleIndex = MySqlParserRULE_predicate

        return p
}</span>

func (s *PredicateContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *PredicateContext) CopyFrom(ctx *PredicateContext) <span class="cov8" title="1">{
        s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}</span>

func (s *PredicateContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *PredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>





type ExpressionAtomPredicateContext struct {
        *PredicateContext
}

func NewExpressionAtomPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExpressionAtomPredicateContext <span class="cov8" title="1">{
        var p = new(ExpressionAtomPredicateContext)

        p.PredicateContext = NewEmptyPredicateContext()
        p.parser = parser
        p.CopyFrom(ctx.(*PredicateContext))

        return p
}</span>

func (s *ExpressionAtomPredicateContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *ExpressionAtomPredicateContext) ExpressionAtom() IExpressionAtomContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionAtomContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(IExpressionAtomContext)</span>
}


func (s *ExpressionAtomPredicateContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterExpressionAtomPredicate(s)
        }</span>
}

func (s *ExpressionAtomPredicateContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitExpressionAtomPredicate(s)
        }</span>
}

func (s *ExpressionAtomPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitExpressionAtomPredicate(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}


type InPredicateContext struct {
        *PredicateContext
}

func NewInPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InPredicateContext <span class="cov8" title="1">{
        var p = new(InPredicateContext)

        p.PredicateContext = NewEmptyPredicateContext()
        p.parser = parser
        p.CopyFrom(ctx.(*PredicateContext))

        return p
}</span>

func (s *InPredicateContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *InPredicateContext) Predicate() IPredicateContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IPredicateContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(IPredicateContext)</span>
}

func (s *InPredicateContext) IN() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserIN, 0)
}</span>

func (s *InPredicateContext) LR_BRACKET() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserLR_BRACKET, 0)
}</span>

func (s *InPredicateContext) RR_BRACKET() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserRR_BRACKET, 0)
}</span>

func (s *InPredicateContext) SelectStatement() ISelectStatementContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectStatementContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(ISelectStatementContext)</span>
}

func (s *InPredicateContext) Expressions() IExpressionsContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionsContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(IExpressionsContext)</span>
}

func (s *InPredicateContext) NOT() antlr.TerminalNode <span class="cov8" title="1">{
        return s.GetToken(MySqlParserNOT, 0)
}</span>


func (s *InPredicateContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterInPredicate(s)
        }</span>
}

func (s *InPredicateContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitInPredicate(s)
        }</span>
}

func (s *InPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitInPredicate(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}


type SubqueryComparasionPredicateContext struct {
        *PredicateContext
        quantifier antlr.Token
}

func NewSubqueryComparasionPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryComparasionPredicateContext <span class="cov0" title="0">{
        var p = new(SubqueryComparasionPredicateContext)

        p.PredicateContext = NewEmptyPredicateContext()
        p.parser = parser
        p.CopyFrom(ctx.(*PredicateContext))

        return p
}</span>


func (s *SubqueryComparasionPredicateContext) GetQuantifier() antlr.Token <span class="cov0" title="0">{ return s.quantifier }</span>


func (s *SubqueryComparasionPredicateContext) SetQuantifier(v antlr.Token) <span class="cov0" title="0">{ s.quantifier = v }</span>

func (s *SubqueryComparasionPredicateContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *SubqueryComparasionPredicateContext) Predicate() IPredicateContext <span class="cov0" title="0">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IPredicateContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IPredicateContext)</span>
}

func (s *SubqueryComparasionPredicateContext) ComparisonOperator() IComparisonOperatorContext <span class="cov0" title="0">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IComparisonOperatorContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IComparisonOperatorContext)</span>
}

func (s *SubqueryComparasionPredicateContext) LR_BRACKET() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserLR_BRACKET, 0)
}</span>

func (s *SubqueryComparasionPredicateContext) SelectStatement() ISelectStatementContext <span class="cov0" title="0">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectStatementContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(ISelectStatementContext)</span>
}

func (s *SubqueryComparasionPredicateContext) RR_BRACKET() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserRR_BRACKET, 0)
}</span>

func (s *SubqueryComparasionPredicateContext) ALL() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserALL, 0)
}</span>

func (s *SubqueryComparasionPredicateContext) ANY() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserANY, 0)
}</span>

func (s *SubqueryComparasionPredicateContext) SOME() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserSOME, 0)
}</span>


func (s *SubqueryComparasionPredicateContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterSubqueryComparasionPredicate(s)
        }</span>
}

func (s *SubqueryComparasionPredicateContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitSubqueryComparasionPredicate(s)
        }</span>
}

func (s *SubqueryComparasionPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitSubqueryComparasionPredicate(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}


type BetweenPredicateContext struct {
        *PredicateContext
}

func NewBetweenPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BetweenPredicateContext <span class="cov0" title="0">{
        var p = new(BetweenPredicateContext)

        p.PredicateContext = NewEmptyPredicateContext()
        p.parser = parser
        p.CopyFrom(ctx.(*PredicateContext))

        return p
}</span>

func (s *BetweenPredicateContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *BetweenPredicateContext) AllPredicate() []IPredicateContext <span class="cov0" title="0">{
        var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPredicateContext)(nil)).Elem())
        var tst = make([]IPredicateContext, len(ts))

        for i, t := range ts </span><span class="cov0" title="0">{
                if t != nil </span><span class="cov0" title="0">{
                        tst[i] = t.(IPredicateContext)
                }</span>
        }

        <span class="cov0" title="0">return tst</span>
}

func (s *BetweenPredicateContext) Predicate(i int) IPredicateContext <span class="cov0" title="0">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IPredicateContext)(nil)).Elem(), i)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IPredicateContext)</span>
}

func (s *BetweenPredicateContext) BETWEEN() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserBETWEEN, 0)
}</span>

func (s *BetweenPredicateContext) AND() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserAND, 0)
}</span>

func (s *BetweenPredicateContext) NOT() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserNOT, 0)
}</span>


func (s *BetweenPredicateContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterBetweenPredicate(s)
        }</span>
}

func (s *BetweenPredicateContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitBetweenPredicate(s)
        }</span>
}

func (s *BetweenPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitBetweenPredicate(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}


type BinaryComparasionPredicateContext struct {
        *PredicateContext
        left IPredicateContext 
        right IPredicateContext 
}

func NewBinaryComparasionPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BinaryComparasionPredicateContext <span class="cov8" title="1">{
        var p = new(BinaryComparasionPredicateContext)

        p.PredicateContext = NewEmptyPredicateContext()
        p.parser = parser
        p.CopyFrom(ctx.(*PredicateContext))

        return p
}</span>


func (s *BinaryComparasionPredicateContext) GetLeft() IPredicateContext <span class="cov0" title="0">{ return s.left }</span>

func (s *BinaryComparasionPredicateContext) GetRight() IPredicateContext <span class="cov0" title="0">{ return s.right }</span>


func (s *BinaryComparasionPredicateContext) SetLeft(v IPredicateContext) <span class="cov0" title="0">{ s.left = v }</span>

func (s *BinaryComparasionPredicateContext) SetRight(v IPredicateContext) <span class="cov0" title="0">{ s.right = v }</span>

func (s *BinaryComparasionPredicateContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *BinaryComparasionPredicateContext) ComparisonOperator() IComparisonOperatorContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IComparisonOperatorContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(IComparisonOperatorContext)</span>
}

func (s *BinaryComparasionPredicateContext) AllPredicate() []IPredicateContext <span class="cov0" title="0">{
        var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPredicateContext)(nil)).Elem())
        var tst = make([]IPredicateContext, len(ts))

        for i, t := range ts </span><span class="cov0" title="0">{
                if t != nil </span><span class="cov0" title="0">{
                        tst[i] = t.(IPredicateContext)
                }</span>
        }

        <span class="cov0" title="0">return tst</span>
}

func (s *BinaryComparasionPredicateContext) Predicate(i int) IPredicateContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IPredicateContext)(nil)).Elem(), i)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(IPredicateContext)</span>
}


func (s *BinaryComparasionPredicateContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterBinaryComparasionPredicate(s)
        }</span>
}

func (s *BinaryComparasionPredicateContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitBinaryComparasionPredicate(s)
        }</span>
}

func (s *BinaryComparasionPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitBinaryComparasionPredicate(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}


type IsNullPredicateContext struct {
        *PredicateContext
}

func NewIsNullPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IsNullPredicateContext <span class="cov0" title="0">{
        var p = new(IsNullPredicateContext)

        p.PredicateContext = NewEmptyPredicateContext()
        p.parser = parser
        p.CopyFrom(ctx.(*PredicateContext))

        return p
}</span>

func (s *IsNullPredicateContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *IsNullPredicateContext) Predicate() IPredicateContext <span class="cov0" title="0">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IPredicateContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IPredicateContext)</span>
}

func (s *IsNullPredicateContext) IS() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserIS, 0)
}</span>

func (s *IsNullPredicateContext) NullNotnull() INullNotnullContext <span class="cov0" title="0">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*INullNotnullContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(INullNotnullContext)</span>
}


func (s *IsNullPredicateContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterIsNullPredicate(s)
        }</span>
}

func (s *IsNullPredicateContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitIsNullPredicate(s)
        }</span>
}

func (s *IsNullPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitIsNullPredicate(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}


type LikePredicateContext struct {
        *PredicateContext
}

func NewLikePredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LikePredicateContext <span class="cov0" title="0">{
        var p = new(LikePredicateContext)

        p.PredicateContext = NewEmptyPredicateContext()
        p.parser = parser
        p.CopyFrom(ctx.(*PredicateContext))

        return p
}</span>

func (s *LikePredicateContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *LikePredicateContext) AllPredicate() []IPredicateContext <span class="cov0" title="0">{
        var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPredicateContext)(nil)).Elem())
        var tst = make([]IPredicateContext, len(ts))

        for i, t := range ts </span><span class="cov0" title="0">{
                if t != nil </span><span class="cov0" title="0">{
                        tst[i] = t.(IPredicateContext)
                }</span>
        }

        <span class="cov0" title="0">return tst</span>
}

func (s *LikePredicateContext) Predicate(i int) IPredicateContext <span class="cov0" title="0">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IPredicateContext)(nil)).Elem(), i)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IPredicateContext)</span>
}

func (s *LikePredicateContext) LIKE() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserLIKE, 0)
}</span>

func (s *LikePredicateContext) NOT() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserNOT, 0)
}</span>


func (s *LikePredicateContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterLikePredicate(s)
        }</span>
}

func (s *LikePredicateContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitLikePredicate(s)
        }</span>
}

func (s *LikePredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitLikePredicate(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}


type RegexpPredicateContext struct {
        *PredicateContext
        regex antlr.Token
}

func NewRegexpPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RegexpPredicateContext <span class="cov0" title="0">{
        var p = new(RegexpPredicateContext)

        p.PredicateContext = NewEmptyPredicateContext()
        p.parser = parser
        p.CopyFrom(ctx.(*PredicateContext))

        return p
}</span>


func (s *RegexpPredicateContext) GetRegex() antlr.Token <span class="cov0" title="0">{ return s.regex }</span>


func (s *RegexpPredicateContext) SetRegex(v antlr.Token) <span class="cov0" title="0">{ s.regex = v }</span>

func (s *RegexpPredicateContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *RegexpPredicateContext) AllPredicate() []IPredicateContext <span class="cov0" title="0">{
        var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPredicateContext)(nil)).Elem())
        var tst = make([]IPredicateContext, len(ts))

        for i, t := range ts </span><span class="cov0" title="0">{
                if t != nil </span><span class="cov0" title="0">{
                        tst[i] = t.(IPredicateContext)
                }</span>
        }

        <span class="cov0" title="0">return tst</span>
}

func (s *RegexpPredicateContext) Predicate(i int) IPredicateContext <span class="cov0" title="0">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IPredicateContext)(nil)).Elem(), i)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IPredicateContext)</span>
}

func (s *RegexpPredicateContext) REGEXP() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserREGEXP, 0)
}</span>

func (s *RegexpPredicateContext) RLIKE() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserRLIKE, 0)
}</span>

func (s *RegexpPredicateContext) NOT() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserNOT, 0)
}</span>


func (s *RegexpPredicateContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterRegexpPredicate(s)
        }</span>
}

func (s *RegexpPredicateContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitRegexpPredicate(s)
        }</span>
}

func (s *RegexpPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitRegexpPredicate(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}



func (p *MySqlParser) Predicate() (localctx IPredicateContext) <span class="cov0" title="0">{
        return p.predicate(0)
}</span>

func (p *MySqlParser) predicate(_p int) (localctx IPredicateContext) <span class="cov8" title="1">{
        var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
        _parentState := p.GetState()
        localctx = NewPredicateContext(p, p.GetParserRuleContext(), _parentState)
        var _prevctx IPredicateContext = localctx
        var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
        _startState := 56
        p.EnterRecursionRule(localctx, 56, MySqlParserRULE_predicate, _p)
        var _la int


        defer func() </span><span class="cov8" title="1">{
                p.UnrollRecursionContexts(_parentctx)
        }</span>()

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        if v, ok := err.(antlr.RecognitionException); ok </span><span class="cov0" title="0">{
                                localctx.SetException(v)
                                p.GetErrorHandler().ReportError(p, v)
                                p.GetErrorHandler().Recover(p, v)
                        }</span> else<span class="cov0" title="0"> {
                                panic(err)</span>
                        }
                }
        }()

        <span class="cov8" title="1">var _alt int

        p.EnterOuterAlt(localctx, 1)
        localctx = NewExpressionAtomPredicateContext(p, localctx)
        p.SetParserRuleContext(localctx)
        _prevctx = localctx

        </span><span class="cov8" title="1">{
                p.SetState(407)
                p.expressionAtom(0)
        }</span>

        <span class="cov8" title="1">p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
        p.SetState(458)
        p.GetErrorHandler().Sync(p)
        _alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext())

        for _alt != 2 &amp;&amp; _alt != antlr.ATNInvalidAltNumber </span><span class="cov8" title="1">{
                if _alt == 1 </span><span class="cov8" title="1">{
                        if p.GetParseListeners() != nil </span><span class="cov8" title="1">{
                                p.TriggerExitRuleEvent()
                        }</span>
                        <span class="cov8" title="1">_prevctx = localctx
                        p.SetState(456)
                        p.GetErrorHandler().Sync(p)
                        switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 63, p.GetParserRuleContext()) </span>{
                        case 1:<span class="cov8" title="1">
                                localctx = NewBinaryComparasionPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
                                localctx.(*BinaryComparasionPredicateContext).left = _prevctx


                                p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_predicate)
                                p.SetState(409)

                                if !(p.Precpred(p.GetParserRuleContext(), 6)) </span><span class="cov0" title="0">{
                                        panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))</span>
                                }
                                <span class="cov8" title="1">{
                                        p.SetState(410)
                                        p.ComparisonOperator()
                                }</span>
                                <span class="cov8" title="1">{
                                        p.SetState(411)

                                        var _x = p.predicate(7)

                                        localctx.(*BinaryComparasionPredicateContext).right = _x
                                }</span>


                        case 2:<span class="cov0" title="0">
                                localctx = NewBetweenPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
                                p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_predicate)
                                p.SetState(413)

                                if !(p.Precpred(p.GetParserRuleContext(), 4)) </span><span class="cov0" title="0">{
                                        panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))</span>
                                }
                                <span class="cov0" title="0">p.SetState(415)
                                p.GetErrorHandler().Sync(p)
                                _la = p.GetTokenStream().LA(1)


                                if _la == MySqlParserNOT </span><span class="cov0" title="0">{
                                        </span><span class="cov0" title="0">{
                                                p.SetState(414)
                                                p.Match(MySqlParserNOT)
                                        }</span>

                                }
                                <span class="cov0" title="0">{
                                        p.SetState(417)
                                        p.Match(MySqlParserBETWEEN)
                                }</span>
                                <span class="cov0" title="0">{
                                        p.SetState(418)
                                        p.predicate(0)
                                }</span>
                                <span class="cov0" title="0">{
                                        p.SetState(419)
                                        p.Match(MySqlParserAND)
                                }</span>
                                <span class="cov0" title="0">{
                                        p.SetState(420)
                                        p.predicate(5)
                                }</span>


                        case 3:<span class="cov0" title="0">
                                localctx = NewLikePredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
                                p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_predicate)
                                p.SetState(422)

                                if !(p.Precpred(p.GetParserRuleContext(), 3)) </span><span class="cov0" title="0">{
                                        panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))</span>
                                }
                                <span class="cov0" title="0">p.SetState(424)
                                p.GetErrorHandler().Sync(p)
                                _la = p.GetTokenStream().LA(1)


                                if _la == MySqlParserNOT </span><span class="cov0" title="0">{
                                        </span><span class="cov0" title="0">{
                                                p.SetState(423)
                                                p.Match(MySqlParserNOT)
                                        }</span>

                                }
                                <span class="cov0" title="0">{
                                        p.SetState(426)
                                        p.Match(MySqlParserLIKE)
                                }</span>
                                <span class="cov0" title="0">{
                                        p.SetState(427)
                                        p.predicate(4)
                                }</span>


                        case 4:<span class="cov0" title="0">
                                localctx = NewRegexpPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
                                p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_predicate)
                                p.SetState(428)

                                if !(p.Precpred(p.GetParserRuleContext(), 2)) </span><span class="cov0" title="0">{
                                        panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))</span>
                                }
                                <span class="cov0" title="0">p.SetState(430)
                                p.GetErrorHandler().Sync(p)
                                _la = p.GetTokenStream().LA(1)


                                if _la == MySqlParserNOT </span><span class="cov0" title="0">{
                                        </span><span class="cov0" title="0">{
                                                p.SetState(429)
                                                p.Match(MySqlParserNOT)
                                        }</span>

                                }
                                <span class="cov0" title="0">{
                                        p.SetState(432)

                                        var _lt = p.GetTokenStream().LT(1)

                                        localctx.(*RegexpPredicateContext).regex = _lt

                                        _la = p.GetTokenStream().LA(1)

                                        if !(_la == MySqlParserREGEXP || _la == MySqlParserRLIKE) </span><span class="cov0" title="0">{
                                                var _ri = p.GetErrorHandler().RecoverInline(p)

                                                localctx.(*RegexpPredicateContext).regex = _ri
                                        }</span> else<span class="cov0" title="0"> {
                                                p.GetErrorHandler().ReportMatch(p)
                                                p.Consume()
                                        }</span>
                                }
                                <span class="cov0" title="0">{
                                        p.SetState(433)
                                        p.predicate(3)
                                }</span>


                        case 5:<span class="cov8" title="1">
                                localctx = NewInPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
                                p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_predicate)
                                p.SetState(434)

                                if !(p.Precpred(p.GetParserRuleContext(), 8)) </span><span class="cov0" title="0">{
                                        panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))</span>
                                }
                                <span class="cov8" title="1">p.SetState(436)
                                p.GetErrorHandler().Sync(p)
                                _la = p.GetTokenStream().LA(1)


                                if _la == MySqlParserNOT </span><span class="cov8" title="1">{
                                        </span><span class="cov8" title="1">{
                                                p.SetState(435)
                                                p.Match(MySqlParserNOT)
                                        }</span>

                                }
                                <span class="cov8" title="1">{
                                        p.SetState(438)
                                        p.Match(MySqlParserIN)
                                }</span>
                                <span class="cov8" title="1">{
                                        p.SetState(439)
                                        p.Match(MySqlParserLR_BRACKET)
                                }</span>
                                <span class="cov8" title="1">p.SetState(442)
                                p.GetErrorHandler().Sync(p)
                                switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 62, p.GetParserRuleContext()) </span>{
                                case 1:<span class="cov8" title="1">
                                        </span><span class="cov8" title="1">{
                                                p.SetState(440)
                                                p.SelectStatement()
                                        }</span>


                                case 2:<span class="cov8" title="1">
                                        </span><span class="cov8" title="1">{
                                                p.SetState(441)
                                                p.Expressions()
                                        }</span>

                                }
                                <span class="cov8" title="1">{
                                        p.SetState(444)
                                        p.Match(MySqlParserRR_BRACKET)
                                }</span>


                        case 6:<span class="cov0" title="0">
                                localctx = NewIsNullPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
                                p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_predicate)
                                p.SetState(446)

                                if !(p.Precpred(p.GetParserRuleContext(), 7)) </span><span class="cov0" title="0">{
                                        panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))</span>
                                }
                                <span class="cov0" title="0">{
                                        p.SetState(447)
                                        p.Match(MySqlParserIS)
                                }</span>
                                <span class="cov0" title="0">{
                                        p.SetState(448)
                                        p.NullNotnull()
                                }</span>


                        case 7:<span class="cov0" title="0">
                                localctx = NewSubqueryComparasionPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
                                p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_predicate)
                                p.SetState(449)

                                if !(p.Precpred(p.GetParserRuleContext(), 5)) </span><span class="cov0" title="0">{
                                        panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))</span>
                                }
                                <span class="cov0" title="0">{
                                        p.SetState(450)
                                        p.ComparisonOperator()
                                }</span>
                                <span class="cov0" title="0">{
                                        p.SetState(451)

                                        var _lt = p.GetTokenStream().LT(1)

                                        localctx.(*SubqueryComparasionPredicateContext).quantifier = _lt

                                        _la = p.GetTokenStream().LA(1)

                                        if !(_la == MySqlParserALL || _la == MySqlParserANY || _la == MySqlParserSOME) </span><span class="cov0" title="0">{
                                                var _ri = p.GetErrorHandler().RecoverInline(p)

                                                localctx.(*SubqueryComparasionPredicateContext).quantifier = _ri
                                        }</span> else<span class="cov0" title="0"> {
                                                p.GetErrorHandler().ReportMatch(p)
                                                p.Consume()
                                        }</span>
                                }
                                <span class="cov0" title="0">{
                                        p.SetState(452)
                                        p.Match(MySqlParserLR_BRACKET)
                                }</span>
                                <span class="cov0" title="0">{
                                        p.SetState(453)
                                        p.SelectStatement()
                                }</span>
                                <span class="cov0" title="0">{
                                        p.SetState(454)
                                        p.Match(MySqlParserRR_BRACKET)
                                }</span>

                        }

                }
                <span class="cov8" title="1">p.SetState(460)
                p.GetErrorHandler().Sync(p)
                _alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext())</span>
        }



        <span class="cov8" title="1">return localctx</span>
}


// IExpressionAtomContext is an interface to support dynamic dispatch.
type IExpressionAtomContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // IsExpressionAtomContext differentiates from other interfaces.
        IsExpressionAtomContext()
}

type ExpressionAtomContext struct {
        *antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyExpressionAtomContext() *ExpressionAtomContext <span class="cov8" title="1">{
        var p = new(ExpressionAtomContext)
        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
        p.RuleIndex = MySqlParserRULE_expressionAtom
        return p
}</span>

func (*ExpressionAtomContext) IsExpressionAtomContext() {<span class="cov0" title="0">}</span>

func NewExpressionAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionAtomContext <span class="cov8" title="1">{
        var p = new(ExpressionAtomContext)

        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

        p.parser = parser
        p.RuleIndex = MySqlParserRULE_expressionAtom

        return p
}</span>

func (s *ExpressionAtomContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *ExpressionAtomContext) CopyFrom(ctx *ExpressionAtomContext) <span class="cov8" title="1">{
        s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}</span>

func (s *ExpressionAtomContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *ExpressionAtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>





type UnaryExpressionAtomContext struct {
        *ExpressionAtomContext
}

func NewUnaryExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnaryExpressionAtomContext <span class="cov0" title="0">{
        var p = new(UnaryExpressionAtomContext)

        p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
        p.parser = parser
        p.CopyFrom(ctx.(*ExpressionAtomContext))

        return p
}</span>

func (s *UnaryExpressionAtomContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *UnaryExpressionAtomContext) UnaryOperator() IUnaryOperatorContext <span class="cov0" title="0">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnaryOperatorContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IUnaryOperatorContext)</span>
}

func (s *UnaryExpressionAtomContext) ExpressionAtom() IExpressionAtomContext <span class="cov0" title="0">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionAtomContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IExpressionAtomContext)</span>
}


func (s *UnaryExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterUnaryExpressionAtom(s)
        }</span>
}

func (s *UnaryExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitUnaryExpressionAtom(s)
        }</span>
}

func (s *UnaryExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitUnaryExpressionAtom(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}


type SubqueryExpressionAtomContext struct {
        *ExpressionAtomContext
}

func NewSubqueryExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryExpressionAtomContext <span class="cov0" title="0">{
        var p = new(SubqueryExpressionAtomContext)

        p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
        p.parser = parser
        p.CopyFrom(ctx.(*ExpressionAtomContext))

        return p
}</span>

func (s *SubqueryExpressionAtomContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *SubqueryExpressionAtomContext) LR_BRACKET() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserLR_BRACKET, 0)
}</span>

func (s *SubqueryExpressionAtomContext) SelectStatement() ISelectStatementContext <span class="cov0" title="0">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectStatementContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(ISelectStatementContext)</span>
}

func (s *SubqueryExpressionAtomContext) RR_BRACKET() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserRR_BRACKET, 0)
}</span>


func (s *SubqueryExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterSubqueryExpressionAtom(s)
        }</span>
}

func (s *SubqueryExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitSubqueryExpressionAtom(s)
        }</span>
}

func (s *SubqueryExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitSubqueryExpressionAtom(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}


type PriorityMathExpressionAtomContext struct {
        *ExpressionAtomContext
        left IExpressionAtomContext 
        op antlr.Token
        right IExpressionAtomContext 
}

func NewPriorityMathExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PriorityMathExpressionAtomContext <span class="cov8" title="1">{
        var p = new(PriorityMathExpressionAtomContext)

        p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
        p.parser = parser
        p.CopyFrom(ctx.(*ExpressionAtomContext))

        return p
}</span>


func (s *PriorityMathExpressionAtomContext) GetOp() antlr.Token <span class="cov8" title="1">{ return s.op }</span>


func (s *PriorityMathExpressionAtomContext) SetOp(v antlr.Token) <span class="cov0" title="0">{ s.op = v }</span>


func (s *PriorityMathExpressionAtomContext) GetLeft() IExpressionAtomContext <span class="cov0" title="0">{ return s.left }</span>

func (s *PriorityMathExpressionAtomContext) GetRight() IExpressionAtomContext <span class="cov0" title="0">{ return s.right }</span>


func (s *PriorityMathExpressionAtomContext) SetLeft(v IExpressionAtomContext) <span class="cov0" title="0">{ s.left = v }</span>

func (s *PriorityMathExpressionAtomContext) SetRight(v IExpressionAtomContext) <span class="cov0" title="0">{ s.right = v }</span>

func (s *PriorityMathExpressionAtomContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *PriorityMathExpressionAtomContext) AllExpressionAtom() []IExpressionAtomContext <span class="cov0" title="0">{
        var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionAtomContext)(nil)).Elem())
        var tst = make([]IExpressionAtomContext, len(ts))

        for i, t := range ts </span><span class="cov0" title="0">{
                if t != nil </span><span class="cov0" title="0">{
                        tst[i] = t.(IExpressionAtomContext)
                }</span>
        }

        <span class="cov0" title="0">return tst</span>
}

func (s *PriorityMathExpressionAtomContext) ExpressionAtom(i int) IExpressionAtomContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionAtomContext)(nil)).Elem(), i)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(IExpressionAtomContext)</span>
}

func (s *PriorityMathExpressionAtomContext) STAR() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserSTAR, 0)
}</span>

func (s *PriorityMathExpressionAtomContext) DIVIDE() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserDIVIDE, 0)
}</span>

func (s *PriorityMathExpressionAtomContext) MODULE() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserMODULE, 0)
}</span>

func (s *PriorityMathExpressionAtomContext) DIV() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserDIV, 0)
}</span>

func (s *PriorityMathExpressionAtomContext) MOD() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserMOD, 0)
}</span>


func (s *PriorityMathExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterPriorityMathExpressionAtom(s)
        }</span>
}

func (s *PriorityMathExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitPriorityMathExpressionAtom(s)
        }</span>
}

func (s *PriorityMathExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitPriorityMathExpressionAtom(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}


type ConstantExpressionAtomContext struct {
        *ExpressionAtomContext
}

func NewConstantExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConstantExpressionAtomContext <span class="cov8" title="1">{
        var p = new(ConstantExpressionAtomContext)

        p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
        p.parser = parser
        p.CopyFrom(ctx.(*ExpressionAtomContext))

        return p
}</span>

func (s *ConstantExpressionAtomContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *ConstantExpressionAtomContext) Constant() IConstantContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(IConstantContext)</span>
}


func (s *ConstantExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterConstantExpressionAtom(s)
        }</span>
}

func (s *ConstantExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitConstantExpressionAtom(s)
        }</span>
}

func (s *ConstantExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitConstantExpressionAtom(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}


type FunctionCallExpressionAtomContext struct {
        *ExpressionAtomContext
}

func NewFunctionCallExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FunctionCallExpressionAtomContext <span class="cov8" title="1">{
        var p = new(FunctionCallExpressionAtomContext)

        p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
        p.parser = parser
        p.CopyFrom(ctx.(*ExpressionAtomContext))

        return p
}</span>

func (s *FunctionCallExpressionAtomContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *FunctionCallExpressionAtomContext) FunctionCall() IFunctionCallContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionCallContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(IFunctionCallContext)</span>
}


func (s *FunctionCallExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterFunctionCallExpressionAtom(s)
        }</span>
}

func (s *FunctionCallExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitFunctionCallExpressionAtom(s)
        }</span>
}

func (s *FunctionCallExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitFunctionCallExpressionAtom(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}


type FullColumnNameExpressionAtomContext struct {
        *ExpressionAtomContext
}

func NewFullColumnNameExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FullColumnNameExpressionAtomContext <span class="cov8" title="1">{
        var p = new(FullColumnNameExpressionAtomContext)

        p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
        p.parser = parser
        p.CopyFrom(ctx.(*ExpressionAtomContext))

        return p
}</span>

func (s *FullColumnNameExpressionAtomContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *FullColumnNameExpressionAtomContext) FullColumnName() IFullColumnNameContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IFullColumnNameContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(IFullColumnNameContext)</span>
}


func (s *FullColumnNameExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterFullColumnNameExpressionAtom(s)
        }</span>
}

func (s *FullColumnNameExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitFullColumnNameExpressionAtom(s)
        }</span>
}

func (s *FullColumnNameExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitFullColumnNameExpressionAtom(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}


type NestedExpressionAtomContext struct {
        *ExpressionAtomContext
}

func NewNestedExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NestedExpressionAtomContext <span class="cov8" title="1">{
        var p = new(NestedExpressionAtomContext)

        p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
        p.parser = parser
        p.CopyFrom(ctx.(*ExpressionAtomContext))

        return p
}</span>

func (s *NestedExpressionAtomContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *NestedExpressionAtomContext) LR_BRACKET() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserLR_BRACKET, 0)
}</span>

func (s *NestedExpressionAtomContext) AllExpression() []IExpressionContext <span class="cov8" title="1">{
        var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
        var tst = make([]IExpressionContext, len(ts))

        for i, t := range ts </span><span class="cov8" title="1">{
                if t != nil </span><span class="cov8" title="1">{
                        tst[i] = t.(IExpressionContext)
                }</span>
        }

        <span class="cov8" title="1">return tst</span>
}

func (s *NestedExpressionAtomContext) Expression(i int) IExpressionContext <span class="cov0" title="0">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IExpressionContext)</span>
}

func (s *NestedExpressionAtomContext) RR_BRACKET() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserRR_BRACKET, 0)
}</span>

func (s *NestedExpressionAtomContext) AllCOMMA() []antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetTokens(MySqlParserCOMMA)
}</span>

func (s *NestedExpressionAtomContext) COMMA(i int) antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserCOMMA, i)
}</span>


func (s *NestedExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterNestedExpressionAtom(s)
        }</span>
}

func (s *NestedExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitNestedExpressionAtom(s)
        }</span>
}

func (s *NestedExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitNestedExpressionAtom(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}


type MathExpressionAtomContext struct {
        *ExpressionAtomContext
        left IExpressionAtomContext 
        right IExpressionAtomContext 
}

func NewMathExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MathExpressionAtomContext <span class="cov8" title="1">{
        var p = new(MathExpressionAtomContext)

        p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
        p.parser = parser
        p.CopyFrom(ctx.(*ExpressionAtomContext))

        return p
}</span>


func (s *MathExpressionAtomContext) GetLeft() IExpressionAtomContext <span class="cov0" title="0">{ return s.left }</span>

func (s *MathExpressionAtomContext) GetRight() IExpressionAtomContext <span class="cov0" title="0">{ return s.right }</span>


func (s *MathExpressionAtomContext) SetLeft(v IExpressionAtomContext) <span class="cov0" title="0">{ s.left = v }</span>

func (s *MathExpressionAtomContext) SetRight(v IExpressionAtomContext) <span class="cov0" title="0">{ s.right = v }</span>

func (s *MathExpressionAtomContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *MathExpressionAtomContext) MathOperator() IMathOperatorContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IMathOperatorContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(IMathOperatorContext)</span>
}

func (s *MathExpressionAtomContext) AllExpressionAtom() []IExpressionAtomContext <span class="cov0" title="0">{
        var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionAtomContext)(nil)).Elem())
        var tst = make([]IExpressionAtomContext, len(ts))

        for i, t := range ts </span><span class="cov0" title="0">{
                if t != nil </span><span class="cov0" title="0">{
                        tst[i] = t.(IExpressionAtomContext)
                }</span>
        }

        <span class="cov0" title="0">return tst</span>
}

func (s *MathExpressionAtomContext) ExpressionAtom(i int) IExpressionAtomContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionAtomContext)(nil)).Elem(), i)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(IExpressionAtomContext)</span>
}


func (s *MathExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterMathExpressionAtom(s)
        }</span>
}

func (s *MathExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitMathExpressionAtom(s)
        }</span>
}

func (s *MathExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitMathExpressionAtom(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}


type ExistsExpressionAtomContext struct {
        *ExpressionAtomContext
}

func NewExistsExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExistsExpressionAtomContext <span class="cov0" title="0">{
        var p = new(ExistsExpressionAtomContext)

        p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
        p.parser = parser
        p.CopyFrom(ctx.(*ExpressionAtomContext))

        return p
}</span>

func (s *ExistsExpressionAtomContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *ExistsExpressionAtomContext) EXISTS() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserEXISTS, 0)
}</span>

func (s *ExistsExpressionAtomContext) LR_BRACKET() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserLR_BRACKET, 0)
}</span>

func (s *ExistsExpressionAtomContext) SelectStatement() ISelectStatementContext <span class="cov0" title="0">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectStatementContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(ISelectStatementContext)</span>
}

func (s *ExistsExpressionAtomContext) RR_BRACKET() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserRR_BRACKET, 0)
}</span>


func (s *ExistsExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterExistsExpressionAtom(s)
        }</span>
}

func (s *ExistsExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitExistsExpressionAtom(s)
        }</span>
}

func (s *ExistsExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitExistsExpressionAtom(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}



func (p *MySqlParser) ExpressionAtom() (localctx IExpressionAtomContext) <span class="cov0" title="0">{
        return p.expressionAtom(0)
}</span>

func (p *MySqlParser) expressionAtom(_p int) (localctx IExpressionAtomContext) <span class="cov8" title="1">{
        var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
        _parentState := p.GetState()
        localctx = NewExpressionAtomContext(p, p.GetParserRuleContext(), _parentState)
        var _prevctx IExpressionAtomContext = localctx
        var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
        _startState := 58
        p.EnterRecursionRule(localctx, 58, MySqlParserRULE_expressionAtom, _p)
        var _la int


        defer func() </span><span class="cov8" title="1">{
                p.UnrollRecursionContexts(_parentctx)
        }</span>()

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        if v, ok := err.(antlr.RecognitionException); ok </span><span class="cov0" title="0">{
                                localctx.SetException(v)
                                p.GetErrorHandler().ReportError(p, v)
                                p.GetErrorHandler().Recover(p, v)
                        }</span> else<span class="cov0" title="0"> {
                                panic(err)</span>
                        }
                }
        }()

        <span class="cov8" title="1">var _alt int

        p.EnterOuterAlt(localctx, 1)
        p.SetState(488)
        p.GetErrorHandler().Sync(p)
        switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 66, p.GetParserRuleContext()) </span>{
        case 1:<span class="cov8" title="1">
                localctx = NewConstantExpressionAtomContext(p, localctx)
                p.SetParserRuleContext(localctx)
                _prevctx = localctx

                </span><span class="cov8" title="1">{
                        p.SetState(462)
                        p.Constant()
                }</span>


        case 2:<span class="cov8" title="1">
                localctx = NewFullColumnNameExpressionAtomContext(p, localctx)
                p.SetParserRuleContext(localctx)
                _prevctx = localctx
                </span><span class="cov8" title="1">{
                        p.SetState(463)
                        p.FullColumnName()
                }</span>


        case 3:<span class="cov8" title="1">
                localctx = NewFunctionCallExpressionAtomContext(p, localctx)
                p.SetParserRuleContext(localctx)
                _prevctx = localctx
                </span><span class="cov8" title="1">{
                        p.SetState(464)
                        p.FunctionCall()
                }</span>


        case 4:<span class="cov0" title="0">
                localctx = NewUnaryExpressionAtomContext(p, localctx)
                p.SetParserRuleContext(localctx)
                _prevctx = localctx
                </span><span class="cov0" title="0">{
                        p.SetState(465)
                        p.UnaryOperator()
                }</span>
                <span class="cov0" title="0">{
                        p.SetState(466)
                        p.expressionAtom(6)
                }</span>


        case 5:<span class="cov8" title="1">
                localctx = NewNestedExpressionAtomContext(p, localctx)
                p.SetParserRuleContext(localctx)
                _prevctx = localctx
                </span><span class="cov8" title="1">{
                        p.SetState(468)
                        p.Match(MySqlParserLR_BRACKET)
                }</span>
                <span class="cov8" title="1">{
                        p.SetState(469)
                        p.expression(0)
                }</span>
                <span class="cov8" title="1">p.SetState(474)
                p.GetErrorHandler().Sync(p)
                _la = p.GetTokenStream().LA(1)


                for _la == MySqlParserCOMMA </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                p.SetState(470)
                                p.Match(MySqlParserCOMMA)
                        }</span>
                        <span class="cov0" title="0">{
                                p.SetState(471)
                                p.expression(0)
                        }</span>


                        <span class="cov0" title="0">p.SetState(476)
                        p.GetErrorHandler().Sync(p)
                        _la = p.GetTokenStream().LA(1)</span>
                }
                <span class="cov8" title="1">{
                        p.SetState(477)
                        p.Match(MySqlParserRR_BRACKET)
                }</span>


        case 6:<span class="cov0" title="0">
                localctx = NewExistsExpressionAtomContext(p, localctx)
                p.SetParserRuleContext(localctx)
                _prevctx = localctx
                </span><span class="cov0" title="0">{
                        p.SetState(479)
                        p.Match(MySqlParserEXISTS)
                }</span>
                <span class="cov0" title="0">{
                        p.SetState(480)
                        p.Match(MySqlParserLR_BRACKET)
                }</span>
                <span class="cov0" title="0">{
                        p.SetState(481)
                        p.SelectStatement()
                }</span>
                <span class="cov0" title="0">{
                        p.SetState(482)
                        p.Match(MySqlParserRR_BRACKET)
                }</span>


        case 7:<span class="cov0" title="0">
                localctx = NewSubqueryExpressionAtomContext(p, localctx)
                p.SetParserRuleContext(localctx)
                _prevctx = localctx
                </span><span class="cov0" title="0">{
                        p.SetState(484)
                        p.Match(MySqlParserLR_BRACKET)
                }</span>
                <span class="cov0" title="0">{
                        p.SetState(485)
                        p.SelectStatement()
                }</span>
                <span class="cov0" title="0">{
                        p.SetState(486)
                        p.Match(MySqlParserRR_BRACKET)
                }</span>

        }
        <span class="cov8" title="1">p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
        p.SetState(499)
        p.GetErrorHandler().Sync(p)
        _alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 68, p.GetParserRuleContext())

        for _alt != 2 &amp;&amp; _alt != antlr.ATNInvalidAltNumber </span><span class="cov8" title="1">{
                if _alt == 1 </span><span class="cov8" title="1">{
                        if p.GetParseListeners() != nil </span><span class="cov8" title="1">{
                                p.TriggerExitRuleEvent()
                        }</span>
                        <span class="cov8" title="1">_prevctx = localctx
                        p.SetState(497)
                        p.GetErrorHandler().Sync(p)
                        switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 67, p.GetParserRuleContext()) </span>{
                        case 1:<span class="cov8" title="1">
                                localctx = NewPriorityMathExpressionAtomContext(p, NewExpressionAtomContext(p, _parentctx, _parentState))
                                localctx.(*PriorityMathExpressionAtomContext).left = _prevctx


                                p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_expressionAtom)
                                p.SetState(490)

                                if !(p.Precpred(p.GetParserRuleContext(), 2)) </span><span class="cov0" title="0">{
                                        panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))</span>
                                }
                                <span class="cov8" title="1">{
                                        p.SetState(491)

                                        var _lt = p.GetTokenStream().LT(1)

                                        localctx.(*PriorityMathExpressionAtomContext).op = _lt

                                        _la = p.GetTokenStream().LA(1)

                                        if !(((((_la - 58)) &amp; -(0x1f+1)) == 0 &amp;&amp; ((1 &lt;&lt; uint((_la - 58))) &amp; ((1 &lt;&lt; (MySqlParserSTAR - 58)) | (1 &lt;&lt; (MySqlParserDIVIDE - 58)) | (1 &lt;&lt; (MySqlParserMODULE - 58)) | (1 &lt;&lt; (MySqlParserDIV - 58)) | (1 &lt;&lt; (MySqlParserMOD - 58)))) != 0)) </span><span class="cov0" title="0">{
                                                var _ri = p.GetErrorHandler().RecoverInline(p)

                                                localctx.(*PriorityMathExpressionAtomContext).op = _ri
                                        }</span> else<span class="cov8" title="1"> {
                                                p.GetErrorHandler().ReportMatch(p)
                                                p.Consume()
                                        }</span>
                                }
                                <span class="cov8" title="1">{
                                        p.SetState(492)

                                        var _x = p.expressionAtom(3)

                                        localctx.(*PriorityMathExpressionAtomContext).right = _x
                                }</span>


                        case 2:<span class="cov8" title="1">
                                localctx = NewMathExpressionAtomContext(p, NewExpressionAtomContext(p, _parentctx, _parentState))
                                localctx.(*MathExpressionAtomContext).left = _prevctx


                                p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_expressionAtom)
                                p.SetState(493)

                                if !(p.Precpred(p.GetParserRuleContext(), 1)) </span><span class="cov0" title="0">{
                                        panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))</span>
                                }
                                <span class="cov8" title="1">{
                                        p.SetState(494)
                                        p.MathOperator()
                                }</span>
                                <span class="cov8" title="1">{
                                        p.SetState(495)

                                        var _x = p.expressionAtom(2)

                                        localctx.(*MathExpressionAtomContext).right = _x
                                }</span>

                        }

                }
                <span class="cov8" title="1">p.SetState(501)
                p.GetErrorHandler().Sync(p)
                _alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 68, p.GetParserRuleContext())</span>
        }



        <span class="cov8" title="1">return localctx</span>
}


// IUnaryOperatorContext is an interface to support dynamic dispatch.
type IUnaryOperatorContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // IsUnaryOperatorContext differentiates from other interfaces.
        IsUnaryOperatorContext()
}

type UnaryOperatorContext struct {
        *antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyUnaryOperatorContext() *UnaryOperatorContext <span class="cov0" title="0">{
        var p = new(UnaryOperatorContext)
        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
        p.RuleIndex = MySqlParserRULE_unaryOperator
        return p
}</span>

func (*UnaryOperatorContext) IsUnaryOperatorContext() {<span class="cov0" title="0">}</span>

func NewUnaryOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaryOperatorContext <span class="cov0" title="0">{
        var p = new(UnaryOperatorContext)

        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

        p.parser = parser
        p.RuleIndex = MySqlParserRULE_unaryOperator

        return p
}</span>

func (s *UnaryOperatorContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *UnaryOperatorContext) EXCLAMATION_SYMBOL() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserEXCLAMATION_SYMBOL, 0)
}</span>

func (s *UnaryOperatorContext) BIT_NOT_OP() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserBIT_NOT_OP, 0)
}</span>

func (s *UnaryOperatorContext) PLUS() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserPLUS, 0)
}</span>

func (s *UnaryOperatorContext) MINUS() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserMINUS, 0)
}</span>

func (s *UnaryOperatorContext) NOT() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserNOT, 0)
}</span>

func (s *UnaryOperatorContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *UnaryOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>


func (s *UnaryOperatorContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterUnaryOperator(s)
        }</span>
}

func (s *UnaryOperatorContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitUnaryOperator(s)
        }</span>
}

func (s *UnaryOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitUnaryOperator(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}




func (p *MySqlParser) UnaryOperator() (localctx IUnaryOperatorContext) <span class="cov0" title="0">{
        localctx = NewUnaryOperatorContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 60, MySqlParserRULE_unaryOperator)
        var _la int


        defer func() </span><span class="cov0" title="0">{
                p.ExitRule()
        }</span>()

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        if v, ok := err.(antlr.RecognitionException); ok </span><span class="cov0" title="0">{
                                localctx.SetException(v)
                                p.GetErrorHandler().ReportError(p, v)
                                p.GetErrorHandler().Recover(p, v)
                        }</span> else<span class="cov0" title="0"> {
                                panic(err)</span>
                        }
                }
        }()

        <span class="cov0" title="0">p.EnterOuterAlt(localctx, 1)
        </span><span class="cov0" title="0">{
                p.SetState(502)
                _la = p.GetTokenStream().LA(1)

                if !(_la == MySqlParserNOT || ((((_la - 61)) &amp; -(0x1f+1)) == 0 &amp;&amp; ((1 &lt;&lt; uint((_la - 61))) &amp; ((1 &lt;&lt; (MySqlParserPLUS - 61)) | (1 &lt;&lt; (MySqlParserMINUS - 61)) | (1 &lt;&lt; (MySqlParserEXCLAMATION_SYMBOL - 61)) | (1 &lt;&lt; (MySqlParserBIT_NOT_OP - 61)))) != 0)) </span><span class="cov0" title="0">{
                        p.GetErrorHandler().RecoverInline(p)
                }</span> else<span class="cov0" title="0"> {
                        p.GetErrorHandler().ReportMatch(p)
                        p.Consume()
                }</span>
        }



        <span class="cov0" title="0">return localctx</span>
}


// IComparisonOperatorContext is an interface to support dynamic dispatch.
type IComparisonOperatorContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // IsComparisonOperatorContext differentiates from other interfaces.
        IsComparisonOperatorContext()
}

type ComparisonOperatorContext struct {
        *antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyComparisonOperatorContext() *ComparisonOperatorContext <span class="cov0" title="0">{
        var p = new(ComparisonOperatorContext)
        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
        p.RuleIndex = MySqlParserRULE_comparisonOperator
        return p
}</span>

func (*ComparisonOperatorContext) IsComparisonOperatorContext() {<span class="cov0" title="0">}</span>

func NewComparisonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonOperatorContext <span class="cov8" title="1">{
        var p = new(ComparisonOperatorContext)

        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

        p.parser = parser
        p.RuleIndex = MySqlParserRULE_comparisonOperator

        return p
}</span>

func (s *ComparisonOperatorContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *ComparisonOperatorContext) EQUAL_SYMBOL() antlr.TerminalNode <span class="cov8" title="1">{
        return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}</span>

func (s *ComparisonOperatorContext) GREATER_SYMBOL() antlr.TerminalNode <span class="cov8" title="1">{
        return s.GetToken(MySqlParserGREATER_SYMBOL, 0)
}</span>

func (s *ComparisonOperatorContext) LESS_SYMBOL() antlr.TerminalNode <span class="cov8" title="1">{
        return s.GetToken(MySqlParserLESS_SYMBOL, 0)
}</span>

func (s *ComparisonOperatorContext) EXCLAMATION_SYMBOL() antlr.TerminalNode <span class="cov8" title="1">{
        return s.GetToken(MySqlParserEXCLAMATION_SYMBOL, 0)
}</span>

func (s *ComparisonOperatorContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *ComparisonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>


func (s *ComparisonOperatorContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterComparisonOperator(s)
        }</span>
}

func (s *ComparisonOperatorContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitComparisonOperator(s)
        }</span>
}

func (s *ComparisonOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitComparisonOperator(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}




func (p *MySqlParser) ComparisonOperator() (localctx IComparisonOperatorContext) <span class="cov8" title="1">{
        localctx = NewComparisonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 62, MySqlParserRULE_comparisonOperator)

        defer func() </span><span class="cov8" title="1">{
                p.ExitRule()
        }</span>()

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        if v, ok := err.(antlr.RecognitionException); ok </span><span class="cov0" title="0">{
                                localctx.SetException(v)
                                p.GetErrorHandler().ReportError(p, v)
                                p.GetErrorHandler().Recover(p, v)
                        }</span> else<span class="cov0" title="0"> {
                                panic(err)</span>
                        }
                }
        }()

        <span class="cov8" title="1">p.SetState(518)
        p.GetErrorHandler().Sync(p)
        switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 69, p.GetParserRuleContext()) </span>{
        case 1:<span class="cov8" title="1">
                p.EnterOuterAlt(localctx, 1)
                </span><span class="cov8" title="1">{
                        p.SetState(504)
                        p.Match(MySqlParserEQUAL_SYMBOL)
                }</span>


        case 2:<span class="cov8" title="1">
                p.EnterOuterAlt(localctx, 2)
                </span><span class="cov8" title="1">{
                        p.SetState(505)
                        p.Match(MySqlParserGREATER_SYMBOL)
                }</span>


        case 3:<span class="cov8" title="1">
                p.EnterOuterAlt(localctx, 3)
                </span><span class="cov8" title="1">{
                        p.SetState(506)
                        p.Match(MySqlParserLESS_SYMBOL)
                }</span>


        case 4:<span class="cov0" title="0">
                p.EnterOuterAlt(localctx, 4)
                </span><span class="cov0" title="0">{
                        p.SetState(507)
                        p.Match(MySqlParserLESS_SYMBOL)
                }</span>
                <span class="cov0" title="0">{
                        p.SetState(508)
                        p.Match(MySqlParserEQUAL_SYMBOL)
                }</span>


        case 5:<span class="cov8" title="1">
                p.EnterOuterAlt(localctx, 5)
                </span><span class="cov8" title="1">{
                        p.SetState(509)
                        p.Match(MySqlParserGREATER_SYMBOL)
                }</span>
                <span class="cov8" title="1">{
                        p.SetState(510)
                        p.Match(MySqlParserEQUAL_SYMBOL)
                }</span>


        case 6:<span class="cov0" title="0">
                p.EnterOuterAlt(localctx, 6)
                </span><span class="cov0" title="0">{
                        p.SetState(511)
                        p.Match(MySqlParserLESS_SYMBOL)
                }</span>
                <span class="cov0" title="0">{
                        p.SetState(512)
                        p.Match(MySqlParserGREATER_SYMBOL)
                }</span>


        case 7:<span class="cov8" title="1">
                p.EnterOuterAlt(localctx, 7)
                </span><span class="cov8" title="1">{
                        p.SetState(513)
                        p.Match(MySqlParserEXCLAMATION_SYMBOL)
                }</span>
                <span class="cov8" title="1">{
                        p.SetState(514)
                        p.Match(MySqlParserEQUAL_SYMBOL)
                }</span>


        case 8:<span class="cov0" title="0">
                p.EnterOuterAlt(localctx, 8)
                </span><span class="cov0" title="0">{
                        p.SetState(515)
                        p.Match(MySqlParserLESS_SYMBOL)
                }</span>
                <span class="cov0" title="0">{
                        p.SetState(516)
                        p.Match(MySqlParserEQUAL_SYMBOL)
                }</span>
                <span class="cov0" title="0">{
                        p.SetState(517)
                        p.Match(MySqlParserGREATER_SYMBOL)
                }</span>

        }


        <span class="cov8" title="1">return localctx</span>
}


// ILogicalOperatorContext is an interface to support dynamic dispatch.
type ILogicalOperatorContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // IsLogicalOperatorContext differentiates from other interfaces.
        IsLogicalOperatorContext()
}

type LogicalOperatorContext struct {
        *antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyLogicalOperatorContext() *LogicalOperatorContext <span class="cov0" title="0">{
        var p = new(LogicalOperatorContext)
        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
        p.RuleIndex = MySqlParserRULE_logicalOperator
        return p
}</span>

func (*LogicalOperatorContext) IsLogicalOperatorContext() {<span class="cov0" title="0">}</span>

func NewLogicalOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LogicalOperatorContext <span class="cov8" title="1">{
        var p = new(LogicalOperatorContext)

        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

        p.parser = parser
        p.RuleIndex = MySqlParserRULE_logicalOperator

        return p
}</span>

func (s *LogicalOperatorContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *LogicalOperatorContext) AND() antlr.TerminalNode <span class="cov8" title="1">{
        return s.GetToken(MySqlParserAND, 0)
}</span>

func (s *LogicalOperatorContext) OR() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserOR, 0)
}</span>

func (s *LogicalOperatorContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *LogicalOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>


func (s *LogicalOperatorContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterLogicalOperator(s)
        }</span>
}

func (s *LogicalOperatorContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitLogicalOperator(s)
        }</span>
}

func (s *LogicalOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitLogicalOperator(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}




func (p *MySqlParser) LogicalOperator() (localctx ILogicalOperatorContext) <span class="cov8" title="1">{
        localctx = NewLogicalOperatorContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 64, MySqlParserRULE_logicalOperator)
        var _la int


        defer func() </span><span class="cov8" title="1">{
                p.ExitRule()
        }</span>()

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        if v, ok := err.(antlr.RecognitionException); ok </span><span class="cov0" title="0">{
                                localctx.SetException(v)
                                p.GetErrorHandler().ReportError(p, v)
                                p.GetErrorHandler().Recover(p, v)
                        }</span> else<span class="cov0" title="0"> {
                                panic(err)</span>
                        }
                }
        }()

        <span class="cov8" title="1">p.EnterOuterAlt(localctx, 1)
        </span><span class="cov8" title="1">{
                p.SetState(520)
                _la = p.GetTokenStream().LA(1)

                if !(_la == MySqlParserAND || _la == MySqlParserOR) </span><span class="cov0" title="0">{
                        p.GetErrorHandler().RecoverInline(p)
                }</span> else<span class="cov8" title="1"> {
                        p.GetErrorHandler().ReportMatch(p)
                        p.Consume()
                }</span>
        }



        <span class="cov8" title="1">return localctx</span>
}


// IMathOperatorContext is an interface to support dynamic dispatch.
type IMathOperatorContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // IsMathOperatorContext differentiates from other interfaces.
        IsMathOperatorContext()
}

type MathOperatorContext struct {
        *antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyMathOperatorContext() *MathOperatorContext <span class="cov0" title="0">{
        var p = new(MathOperatorContext)
        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
        p.RuleIndex = MySqlParserRULE_mathOperator
        return p
}</span>

func (*MathOperatorContext) IsMathOperatorContext() {<span class="cov0" title="0">}</span>

func NewMathOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MathOperatorContext <span class="cov8" title="1">{
        var p = new(MathOperatorContext)

        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

        p.parser = parser
        p.RuleIndex = MySqlParserRULE_mathOperator

        return p
}</span>

func (s *MathOperatorContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *MathOperatorContext) PLUS() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserPLUS, 0)
}</span>

func (s *MathOperatorContext) MINUS() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserMINUS, 0)
}</span>

func (s *MathOperatorContext) MINUSMINUS() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserMINUSMINUS, 0)
}</span>

func (s *MathOperatorContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *MathOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>


func (s *MathOperatorContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterMathOperator(s)
        }</span>
}

func (s *MathOperatorContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitMathOperator(s)
        }</span>
}

func (s *MathOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitMathOperator(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}




func (p *MySqlParser) MathOperator() (localctx IMathOperatorContext) <span class="cov8" title="1">{
        localctx = NewMathOperatorContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 66, MySqlParserRULE_mathOperator)
        var _la int


        defer func() </span><span class="cov8" title="1">{
                p.ExitRule()
        }</span>()

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        if v, ok := err.(antlr.RecognitionException); ok </span><span class="cov0" title="0">{
                                localctx.SetException(v)
                                p.GetErrorHandler().ReportError(p, v)
                                p.GetErrorHandler().Recover(p, v)
                        }</span> else<span class="cov0" title="0"> {
                                panic(err)</span>
                        }
                }
        }()

        <span class="cov8" title="1">p.EnterOuterAlt(localctx, 1)
        </span><span class="cov8" title="1">{
                p.SetState(522)
                _la = p.GetTokenStream().LA(1)

                if !(((((_la - 61)) &amp; -(0x1f+1)) == 0 &amp;&amp; ((1 &lt;&lt; uint((_la - 61))) &amp; ((1 &lt;&lt; (MySqlParserPLUS - 61)) | (1 &lt;&lt; (MySqlParserMINUSMINUS - 61)) | (1 &lt;&lt; (MySqlParserMINUS - 61)))) != 0)) </span><span class="cov0" title="0">{
                        p.GetErrorHandler().RecoverInline(p)
                }</span> else<span class="cov8" title="1"> {
                        p.GetErrorHandler().ReportMatch(p)
                        p.Consume()
                }</span>
        }



        <span class="cov8" title="1">return localctx</span>
}


// IInsertStatementContext is an interface to support dynamic dispatch.
type IInsertStatementContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // GetColumns returns the columns rule contexts.
        GetColumns() IUidListContext


        // SetColumns sets the columns rule contexts.
        SetColumns(IUidListContext)


        // IsInsertStatementContext differentiates from other interfaces.
        IsInsertStatementContext()
}

type InsertStatementContext struct {
        *antlr.BaseParserRuleContext
        parser antlr.Parser
        columns IUidListContext 
}

func NewEmptyInsertStatementContext() *InsertStatementContext <span class="cov0" title="0">{
        var p = new(InsertStatementContext)
        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
        p.RuleIndex = MySqlParserRULE_insertStatement
        return p
}</span>

func (*InsertStatementContext) IsInsertStatementContext() {<span class="cov0" title="0">}</span>

func NewInsertStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertStatementContext <span class="cov8" title="1">{
        var p = new(InsertStatementContext)

        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

        p.parser = parser
        p.RuleIndex = MySqlParserRULE_insertStatement

        return p
}</span>

func (s *InsertStatementContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *InsertStatementContext) GetColumns() IUidListContext <span class="cov0" title="0">{ return s.columns }</span>


func (s *InsertStatementContext) SetColumns(v IUidListContext) <span class="cov0" title="0">{ s.columns = v }</span>


func (s *InsertStatementContext) INSERT() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserINSERT, 0)
}</span>

func (s *InsertStatementContext) ID() antlr.TerminalNode <span class="cov8" title="1">{
        return s.GetToken(MySqlParserID, 0)
}</span>

func (s *InsertStatementContext) InsertStatementValue() IInsertStatementValueContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IInsertStatementValueContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(IInsertStatementValueContext)</span>
}

func (s *InsertStatementContext) IGNORE() antlr.TerminalNode <span class="cov8" title="1">{
        return s.GetToken(MySqlParserIGNORE, 0)
}</span>

func (s *InsertStatementContext) INTO() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserINTO, 0)
}</span>

func (s *InsertStatementContext) LR_BRACKET() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserLR_BRACKET, 0)
}</span>

func (s *InsertStatementContext) RR_BRACKET() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserRR_BRACKET, 0)
}</span>

func (s *InsertStatementContext) UidList() IUidListContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IUidListContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(IUidListContext)</span>
}

func (s *InsertStatementContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *InsertStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>


func (s *InsertStatementContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterInsertStatement(s)
        }</span>
}

func (s *InsertStatementContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitInsertStatement(s)
        }</span>
}

func (s *InsertStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitInsertStatement(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}




func (p *MySqlParser) InsertStatement() (localctx IInsertStatementContext) <span class="cov8" title="1">{
        localctx = NewInsertStatementContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 68, MySqlParserRULE_insertStatement)
        var _la int


        defer func() </span><span class="cov8" title="1">{
                p.ExitRule()
        }</span>()

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        if v, ok := err.(antlr.RecognitionException); ok </span><span class="cov0" title="0">{
                                localctx.SetException(v)
                                p.GetErrorHandler().ReportError(p, v)
                                p.GetErrorHandler().Recover(p, v)
                        }</span> else<span class="cov0" title="0"> {
                                panic(err)</span>
                        }
                }
        }()

        <span class="cov8" title="1">p.EnterOuterAlt(localctx, 1)
        </span><span class="cov8" title="1">{
                p.SetState(524)
                p.Match(MySqlParserINSERT)
        }</span>
        <span class="cov8" title="1">p.SetState(526)
        p.GetErrorHandler().Sync(p)
        _la = p.GetTokenStream().LA(1)


        if _la == MySqlParserIGNORE </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        p.SetState(525)
                        p.Match(MySqlParserIGNORE)
                }</span>

        }
        <span class="cov8" title="1">p.SetState(529)
        p.GetErrorHandler().Sync(p)
        _la = p.GetTokenStream().LA(1)


        if _la == MySqlParserINTO </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        p.SetState(528)
                        p.Match(MySqlParserINTO)
                }</span>

        }
        <span class="cov8" title="1">{
                p.SetState(531)
                p.Match(MySqlParserID)
        }</span>
        <span class="cov8" title="1">p.SetState(536)
        p.GetErrorHandler().Sync(p)


        if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 72, p.GetParserRuleContext()) == 1 </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        p.SetState(532)
                        p.Match(MySqlParserLR_BRACKET)
                }</span>
                <span class="cov8" title="1">{
                        p.SetState(533)

                        var _x = p.UidList()


                        localctx.(*InsertStatementContext).columns = _x
                }</span>
                <span class="cov8" title="1">{
                        p.SetState(534)
                        p.Match(MySqlParserRR_BRACKET)
                }</span>


        }
        <span class="cov8" title="1">{
                p.SetState(538)
                p.InsertStatementValue()
        }</span>



        <span class="cov8" title="1">return localctx</span>
}


// IInsertStatementValueContext is an interface to support dynamic dispatch.
type IInsertStatementValueContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // GetInsertFormat returns the insertFormat token.
        GetInsertFormat() antlr.Token 


        // SetInsertFormat sets the insertFormat token.
        SetInsertFormat(antlr.Token) 


        // IsInsertStatementValueContext differentiates from other interfaces.
        IsInsertStatementValueContext()
}

type InsertStatementValueContext struct {
        *antlr.BaseParserRuleContext
        parser antlr.Parser
        insertFormat antlr.Token
}

func NewEmptyInsertStatementValueContext() *InsertStatementValueContext <span class="cov0" title="0">{
        var p = new(InsertStatementValueContext)
        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
        p.RuleIndex = MySqlParserRULE_insertStatementValue
        return p
}</span>

func (*InsertStatementValueContext) IsInsertStatementValueContext() {<span class="cov0" title="0">}</span>

func NewInsertStatementValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertStatementValueContext <span class="cov8" title="1">{
        var p = new(InsertStatementValueContext)

        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

        p.parser = parser
        p.RuleIndex = MySqlParserRULE_insertStatementValue

        return p
}</span>

func (s *InsertStatementValueContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *InsertStatementValueContext) GetInsertFormat() antlr.Token <span class="cov0" title="0">{ return s.insertFormat }</span>


func (s *InsertStatementValueContext) SetInsertFormat(v antlr.Token) <span class="cov0" title="0">{ s.insertFormat = v }</span>


func (s *InsertStatementValueContext) SelectStatement() ISelectStatementContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectStatementContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(ISelectStatementContext)</span>
}

func (s *InsertStatementValueContext) AllLR_BRACKET() []antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetTokens(MySqlParserLR_BRACKET)
}</span>

func (s *InsertStatementValueContext) LR_BRACKET(i int) antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserLR_BRACKET, i)
}</span>

func (s *InsertStatementValueContext) AllExpressionsWithDefaults() []IExpressionsWithDefaultsContext <span class="cov8" title="1">{
        var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionsWithDefaultsContext)(nil)).Elem())
        var tst = make([]IExpressionsWithDefaultsContext, len(ts))

        for i, t := range ts </span><span class="cov8" title="1">{
                if t != nil </span><span class="cov8" title="1">{
                        tst[i] = t.(IExpressionsWithDefaultsContext)
                }</span>
        }

        <span class="cov8" title="1">return tst</span>
}

func (s *InsertStatementValueContext) ExpressionsWithDefaults(i int) IExpressionsWithDefaultsContext <span class="cov0" title="0">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionsWithDefaultsContext)(nil)).Elem(), i)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IExpressionsWithDefaultsContext)</span>
}

func (s *InsertStatementValueContext) AllRR_BRACKET() []antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetTokens(MySqlParserRR_BRACKET)
}</span>

func (s *InsertStatementValueContext) RR_BRACKET(i int) antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserRR_BRACKET, i)
}</span>

func (s *InsertStatementValueContext) VALUES() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserVALUES, 0)
}</span>

func (s *InsertStatementValueContext) VALUE() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserVALUE, 0)
}</span>

func (s *InsertStatementValueContext) AllCOMMA() []antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetTokens(MySqlParserCOMMA)
}</span>

func (s *InsertStatementValueContext) COMMA(i int) antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserCOMMA, i)
}</span>

func (s *InsertStatementValueContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *InsertStatementValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>


func (s *InsertStatementValueContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterInsertStatementValue(s)
        }</span>
}

func (s *InsertStatementValueContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitInsertStatementValue(s)
        }</span>
}

func (s *InsertStatementValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitInsertStatementValue(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}




func (p *MySqlParser) InsertStatementValue() (localctx IInsertStatementValueContext) <span class="cov8" title="1">{
        localctx = NewInsertStatementValueContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 70, MySqlParserRULE_insertStatementValue)
        var _la int


        defer func() </span><span class="cov8" title="1">{
                p.ExitRule()
        }</span>()

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        if v, ok := err.(antlr.RecognitionException); ok </span><span class="cov0" title="0">{
                                localctx.SetException(v)
                                p.GetErrorHandler().ReportError(p, v)
                                p.GetErrorHandler().Recover(p, v)
                        }</span> else<span class="cov0" title="0"> {
                                panic(err)</span>
                        }
                }
        }()

        <span class="cov8" title="1">p.SetState(555)
        p.GetErrorHandler().Sync(p)

        switch p.GetTokenStream().LA(1) </span>{
        case MySqlParserSELECT, MySqlParserLR_BRACKET:<span class="cov8" title="1">
                p.EnterOuterAlt(localctx, 1)
                </span><span class="cov8" title="1">{
                        p.SetState(540)
                        p.SelectStatement()
                }</span>


        case MySqlParserVALUES, MySqlParserVALUE:<span class="cov8" title="1">
                p.EnterOuterAlt(localctx, 2)
                </span><span class="cov8" title="1">{
                        p.SetState(541)

                        var _lt = p.GetTokenStream().LT(1)

                        localctx.(*InsertStatementValueContext).insertFormat = _lt

                        _la = p.GetTokenStream().LA(1)

                        if !(_la == MySqlParserVALUES || _la == MySqlParserVALUE) </span><span class="cov0" title="0">{
                                var _ri = p.GetErrorHandler().RecoverInline(p)

                                localctx.(*InsertStatementValueContext).insertFormat = _ri
                        }</span> else<span class="cov8" title="1"> {
                                p.GetErrorHandler().ReportMatch(p)
                                p.Consume()
                        }</span>
                }
                <span class="cov8" title="1">{
                        p.SetState(542)
                        p.Match(MySqlParserLR_BRACKET)
                }</span>
                <span class="cov8" title="1">{
                        p.SetState(543)
                        p.ExpressionsWithDefaults()
                }</span>
                <span class="cov8" title="1">{
                        p.SetState(544)
                        p.Match(MySqlParserRR_BRACKET)
                }</span>
                <span class="cov8" title="1">p.SetState(552)
                p.GetErrorHandler().Sync(p)
                _la = p.GetTokenStream().LA(1)


                for _la == MySqlParserCOMMA </span><span class="cov8" title="1">{
                        </span><span class="cov8" title="1">{
                                p.SetState(545)
                                p.Match(MySqlParserCOMMA)
                        }</span>
                        <span class="cov8" title="1">{
                                p.SetState(546)
                                p.Match(MySqlParserLR_BRACKET)
                        }</span>
                        <span class="cov8" title="1">{
                                p.SetState(547)
                                p.ExpressionsWithDefaults()
                        }</span>
                        <span class="cov8" title="1">{
                                p.SetState(548)
                                p.Match(MySqlParserRR_BRACKET)
                        }</span>


                        <span class="cov8" title="1">p.SetState(554)
                        p.GetErrorHandler().Sync(p)
                        _la = p.GetTokenStream().LA(1)</span>
                }



        default:<span class="cov0" title="0">
                panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))</span>
        }


        <span class="cov8" title="1">return localctx</span>
}


// IUpdatedElementContext is an interface to support dynamic dispatch.
type IUpdatedElementContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // IsUpdatedElementContext differentiates from other interfaces.
        IsUpdatedElementContext()
}

type UpdatedElementContext struct {
        *antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyUpdatedElementContext() *UpdatedElementContext <span class="cov0" title="0">{
        var p = new(UpdatedElementContext)
        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
        p.RuleIndex = MySqlParserRULE_updatedElement
        return p
}</span>

func (*UpdatedElementContext) IsUpdatedElementContext() {<span class="cov0" title="0">}</span>

func NewUpdatedElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdatedElementContext <span class="cov8" title="1">{
        var p = new(UpdatedElementContext)

        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

        p.parser = parser
        p.RuleIndex = MySqlParserRULE_updatedElement

        return p
}</span>

func (s *UpdatedElementContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *UpdatedElementContext) FullColumnName() IFullColumnNameContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IFullColumnNameContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(IFullColumnNameContext)</span>
}

func (s *UpdatedElementContext) EQUAL_SYMBOL() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}</span>

func (s *UpdatedElementContext) ExpressionOrDefault() IExpressionOrDefaultContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionOrDefaultContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(IExpressionOrDefaultContext)</span>
}

func (s *UpdatedElementContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *UpdatedElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>


func (s *UpdatedElementContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterUpdatedElement(s)
        }</span>
}

func (s *UpdatedElementContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitUpdatedElement(s)
        }</span>
}

func (s *UpdatedElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitUpdatedElement(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}




func (p *MySqlParser) UpdatedElement() (localctx IUpdatedElementContext) <span class="cov8" title="1">{
        localctx = NewUpdatedElementContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 72, MySqlParserRULE_updatedElement)

        defer func() </span><span class="cov8" title="1">{
                p.ExitRule()
        }</span>()

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        if v, ok := err.(antlr.RecognitionException); ok </span><span class="cov0" title="0">{
                                localctx.SetException(v)
                                p.GetErrorHandler().ReportError(p, v)
                                p.GetErrorHandler().Recover(p, v)
                        }</span> else<span class="cov0" title="0"> {
                                panic(err)</span>
                        }
                }
        }()

        <span class="cov8" title="1">p.EnterOuterAlt(localctx, 1)
        </span><span class="cov8" title="1">{
                p.SetState(557)
                p.FullColumnName()
        }</span>
        <span class="cov8" title="1">{
                p.SetState(558)
                p.Match(MySqlParserEQUAL_SYMBOL)
        }</span>
        <span class="cov8" title="1">{
                p.SetState(559)
                p.ExpressionOrDefault()
        }</span>



        <span class="cov8" title="1">return localctx</span>
}


// IExpressionsWithDefaultsContext is an interface to support dynamic dispatch.
type IExpressionsWithDefaultsContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // IsExpressionsWithDefaultsContext differentiates from other interfaces.
        IsExpressionsWithDefaultsContext()
}

type ExpressionsWithDefaultsContext struct {
        *antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyExpressionsWithDefaultsContext() *ExpressionsWithDefaultsContext <span class="cov0" title="0">{
        var p = new(ExpressionsWithDefaultsContext)
        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
        p.RuleIndex = MySqlParserRULE_expressionsWithDefaults
        return p
}</span>

func (*ExpressionsWithDefaultsContext) IsExpressionsWithDefaultsContext() {<span class="cov0" title="0">}</span>

func NewExpressionsWithDefaultsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionsWithDefaultsContext <span class="cov8" title="1">{
        var p = new(ExpressionsWithDefaultsContext)

        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

        p.parser = parser
        p.RuleIndex = MySqlParserRULE_expressionsWithDefaults

        return p
}</span>

func (s *ExpressionsWithDefaultsContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *ExpressionsWithDefaultsContext) AllExpressionOrDefault() []IExpressionOrDefaultContext <span class="cov8" title="1">{
        var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionOrDefaultContext)(nil)).Elem())
        var tst = make([]IExpressionOrDefaultContext, len(ts))

        for i, t := range ts </span><span class="cov8" title="1">{
                if t != nil </span><span class="cov8" title="1">{
                        tst[i] = t.(IExpressionOrDefaultContext)
                }</span>
        }

        <span class="cov8" title="1">return tst</span>
}

func (s *ExpressionsWithDefaultsContext) ExpressionOrDefault(i int) IExpressionOrDefaultContext <span class="cov0" title="0">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionOrDefaultContext)(nil)).Elem(), i)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IExpressionOrDefaultContext)</span>
}

func (s *ExpressionsWithDefaultsContext) AllCOMMA() []antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetTokens(MySqlParserCOMMA)
}</span>

func (s *ExpressionsWithDefaultsContext) COMMA(i int) antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserCOMMA, i)
}</span>

func (s *ExpressionsWithDefaultsContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *ExpressionsWithDefaultsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>


func (s *ExpressionsWithDefaultsContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterExpressionsWithDefaults(s)
        }</span>
}

func (s *ExpressionsWithDefaultsContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitExpressionsWithDefaults(s)
        }</span>
}

func (s *ExpressionsWithDefaultsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitExpressionsWithDefaults(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}




func (p *MySqlParser) ExpressionsWithDefaults() (localctx IExpressionsWithDefaultsContext) <span class="cov8" title="1">{
        localctx = NewExpressionsWithDefaultsContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 74, MySqlParserRULE_expressionsWithDefaults)
        var _la int


        defer func() </span><span class="cov8" title="1">{
                p.ExitRule()
        }</span>()

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        if v, ok := err.(antlr.RecognitionException); ok </span><span class="cov0" title="0">{
                                localctx.SetException(v)
                                p.GetErrorHandler().ReportError(p, v)
                                p.GetErrorHandler().Recover(p, v)
                        }</span> else<span class="cov0" title="0"> {
                                panic(err)</span>
                        }
                }
        }()

        <span class="cov8" title="1">p.EnterOuterAlt(localctx, 1)
        </span><span class="cov8" title="1">{
                p.SetState(561)
                p.ExpressionOrDefault()
        }</span>
        <span class="cov8" title="1">p.SetState(566)
        p.GetErrorHandler().Sync(p)
        _la = p.GetTokenStream().LA(1)


        for _la == MySqlParserCOMMA </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        p.SetState(562)
                        p.Match(MySqlParserCOMMA)
                }</span>
                <span class="cov8" title="1">{
                        p.SetState(563)
                        p.ExpressionOrDefault()
                }</span>


                <span class="cov8" title="1">p.SetState(568)
                p.GetErrorHandler().Sync(p)
                _la = p.GetTokenStream().LA(1)</span>
        }



        <span class="cov8" title="1">return localctx</span>
}


// IExpressionOrDefaultContext is an interface to support dynamic dispatch.
type IExpressionOrDefaultContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // IsExpressionOrDefaultContext differentiates from other interfaces.
        IsExpressionOrDefaultContext()
}

type ExpressionOrDefaultContext struct {
        *antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyExpressionOrDefaultContext() *ExpressionOrDefaultContext <span class="cov0" title="0">{
        var p = new(ExpressionOrDefaultContext)
        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
        p.RuleIndex = MySqlParserRULE_expressionOrDefault
        return p
}</span>

func (*ExpressionOrDefaultContext) IsExpressionOrDefaultContext() {<span class="cov0" title="0">}</span>

func NewExpressionOrDefaultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionOrDefaultContext <span class="cov8" title="1">{
        var p = new(ExpressionOrDefaultContext)

        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

        p.parser = parser
        p.RuleIndex = MySqlParserRULE_expressionOrDefault

        return p
}</span>

func (s *ExpressionOrDefaultContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *ExpressionOrDefaultContext) Expression() IExpressionContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(IExpressionContext)</span>
}

func (s *ExpressionOrDefaultContext) DEFAULT() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserDEFAULT, 0)
}</span>

func (s *ExpressionOrDefaultContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *ExpressionOrDefaultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>


func (s *ExpressionOrDefaultContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterExpressionOrDefault(s)
        }</span>
}

func (s *ExpressionOrDefaultContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitExpressionOrDefault(s)
        }</span>
}

func (s *ExpressionOrDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitExpressionOrDefault(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}




func (p *MySqlParser) ExpressionOrDefault() (localctx IExpressionOrDefaultContext) <span class="cov8" title="1">{
        localctx = NewExpressionOrDefaultContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 76, MySqlParserRULE_expressionOrDefault)

        defer func() </span><span class="cov8" title="1">{
                p.ExitRule()
        }</span>()

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        if v, ok := err.(antlr.RecognitionException); ok </span><span class="cov0" title="0">{
                                localctx.SetException(v)
                                p.GetErrorHandler().ReportError(p, v)
                                p.GetErrorHandler().Recover(p, v)
                        }</span> else<span class="cov0" title="0"> {
                                panic(err)</span>
                        }
                }
        }()

        <span class="cov8" title="1">p.SetState(571)
        p.GetErrorHandler().Sync(p)

        switch p.GetTokenStream().LA(1) </span>{
        case MySqlParserCASE, MySqlParserEXISTS, MySqlParserFALSE, MySqlParserNOT, MySqlParserNULL_LITERAL, MySqlParserTRUE, MySqlParserPLUS, MySqlParserMINUS, MySqlParserEXCLAMATION_SYMBOL, MySqlParserBIT_NOT_OP, MySqlParserLR_BRACKET, MySqlParserSTRING_LITERAL, MySqlParserDECIMAL_LITERAL, MySqlParserREAL_LITERAL, MySqlParserNULL_SPEC_LITERAL, MySqlParserID:<span class="cov8" title="1">
                p.EnterOuterAlt(localctx, 1)
                </span><span class="cov8" title="1">{
                        p.SetState(569)
                        p.expression(0)
                }</span>


        case MySqlParserDEFAULT:<span class="cov0" title="0">
                p.EnterOuterAlt(localctx, 2)
                </span><span class="cov0" title="0">{
                        p.SetState(570)
                        p.Match(MySqlParserDEFAULT)
                }</span>



        default:<span class="cov0" title="0">
                panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))</span>
        }


        <span class="cov8" title="1">return localctx</span>
}


// IDeleteStatementContext is an interface to support dynamic dispatch.
type IDeleteStatementContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // IsDeleteStatementContext differentiates from other interfaces.
        IsDeleteStatementContext()
}

type DeleteStatementContext struct {
        *antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyDeleteStatementContext() *DeleteStatementContext <span class="cov0" title="0">{
        var p = new(DeleteStatementContext)
        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
        p.RuleIndex = MySqlParserRULE_deleteStatement
        return p
}</span>

func (*DeleteStatementContext) IsDeleteStatementContext() {<span class="cov0" title="0">}</span>

func NewDeleteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeleteStatementContext <span class="cov8" title="1">{
        var p = new(DeleteStatementContext)

        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

        p.parser = parser
        p.RuleIndex = MySqlParserRULE_deleteStatement

        return p
}</span>

func (s *DeleteStatementContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *DeleteStatementContext) DELETE() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserDELETE, 0)
}</span>

func (s *DeleteStatementContext) FROM() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserFROM, 0)
}</span>

func (s *DeleteStatementContext) ID() antlr.TerminalNode <span class="cov8" title="1">{
        return s.GetToken(MySqlParserID, 0)
}</span>

func (s *DeleteStatementContext) IGNORE() antlr.TerminalNode <span class="cov8" title="1">{
        return s.GetToken(MySqlParserIGNORE, 0)
}</span>

func (s *DeleteStatementContext) WHERE() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserWHERE, 0)
}</span>

func (s *DeleteStatementContext) Expression() IExpressionContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(IExpressionContext)</span>
}

func (s *DeleteStatementContext) OrderByClause() IOrderByClauseContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrderByClauseContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(IOrderByClauseContext)</span>
}

func (s *DeleteStatementContext) LimitClause() ILimitClauseContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*ILimitClauseContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(ILimitClauseContext)</span>
}

func (s *DeleteStatementContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *DeleteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>


func (s *DeleteStatementContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterDeleteStatement(s)
        }</span>
}

func (s *DeleteStatementContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitDeleteStatement(s)
        }</span>
}

func (s *DeleteStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitDeleteStatement(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}




func (p *MySqlParser) DeleteStatement() (localctx IDeleteStatementContext) <span class="cov8" title="1">{
        localctx = NewDeleteStatementContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 78, MySqlParserRULE_deleteStatement)
        var _la int


        defer func() </span><span class="cov8" title="1">{
                p.ExitRule()
        }</span>()

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        if v, ok := err.(antlr.RecognitionException); ok </span><span class="cov0" title="0">{
                                localctx.SetException(v)
                                p.GetErrorHandler().ReportError(p, v)
                                p.GetErrorHandler().Recover(p, v)
                        }</span> else<span class="cov0" title="0"> {
                                panic(err)</span>
                        }
                }
        }()

        <span class="cov8" title="1">p.EnterOuterAlt(localctx, 1)
        </span><span class="cov8" title="1">{
                p.SetState(573)
                p.Match(MySqlParserDELETE)
        }</span>
        <span class="cov8" title="1">p.SetState(575)
        p.GetErrorHandler().Sync(p)
        _la = p.GetTokenStream().LA(1)


        if _la == MySqlParserIGNORE </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        p.SetState(574)
                        p.Match(MySqlParserIGNORE)
                }</span>

        }
        <span class="cov8" title="1">{
                p.SetState(577)
                p.Match(MySqlParserFROM)
        }</span>
        <span class="cov8" title="1">{
                p.SetState(578)
                p.Match(MySqlParserID)
        }</span>
        <span class="cov8" title="1">p.SetState(581)
        p.GetErrorHandler().Sync(p)
        _la = p.GetTokenStream().LA(1)


        if _la == MySqlParserWHERE </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        p.SetState(579)
                        p.Match(MySqlParserWHERE)
                }</span>
                <span class="cov8" title="1">{
                        p.SetState(580)
                        p.expression(0)
                }</span>

        }
        <span class="cov8" title="1">p.SetState(584)
        p.GetErrorHandler().Sync(p)
        _la = p.GetTokenStream().LA(1)


        if _la == MySqlParserORDER </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        p.SetState(583)
                        p.OrderByClause()
                }</span>

        }
        <span class="cov8" title="1">p.SetState(587)
        p.GetErrorHandler().Sync(p)
        _la = p.GetTokenStream().LA(1)


        if _la == MySqlParserLIMIT </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        p.SetState(586)
                        p.LimitClause()
                }</span>

        }



        <span class="cov8" title="1">return localctx</span>
}


// IUpdateStatementContext is an interface to support dynamic dispatch.
type IUpdateStatementContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // IsUpdateStatementContext differentiates from other interfaces.
        IsUpdateStatementContext()
}

type UpdateStatementContext struct {
        *antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyUpdateStatementContext() *UpdateStatementContext <span class="cov0" title="0">{
        var p = new(UpdateStatementContext)
        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
        p.RuleIndex = MySqlParserRULE_updateStatement
        return p
}</span>

func (*UpdateStatementContext) IsUpdateStatementContext() {<span class="cov0" title="0">}</span>

func NewUpdateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdateStatementContext <span class="cov8" title="1">{
        var p = new(UpdateStatementContext)

        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

        p.parser = parser
        p.RuleIndex = MySqlParserRULE_updateStatement

        return p
}</span>

func (s *UpdateStatementContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *UpdateStatementContext) UPDATE() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserUPDATE, 0)
}</span>

func (s *UpdateStatementContext) AllID() []antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetTokens(MySqlParserID)
}</span>

func (s *UpdateStatementContext) ID(i int) antlr.TerminalNode <span class="cov8" title="1">{
        return s.GetToken(MySqlParserID, i)
}</span>

func (s *UpdateStatementContext) SET() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserSET, 0)
}</span>

func (s *UpdateStatementContext) AllUpdatedElement() []IUpdatedElementContext <span class="cov8" title="1">{
        var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUpdatedElementContext)(nil)).Elem())
        var tst = make([]IUpdatedElementContext, len(ts))

        for i, t := range ts </span><span class="cov8" title="1">{
                if t != nil </span><span class="cov8" title="1">{
                        tst[i] = t.(IUpdatedElementContext)
                }</span>
        }

        <span class="cov8" title="1">return tst</span>
}

func (s *UpdateStatementContext) UpdatedElement(i int) IUpdatedElementContext <span class="cov0" title="0">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IUpdatedElementContext)(nil)).Elem(), i)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IUpdatedElementContext)</span>
}

func (s *UpdateStatementContext) IGNORE() antlr.TerminalNode <span class="cov8" title="1">{
        return s.GetToken(MySqlParserIGNORE, 0)
}</span>

func (s *UpdateStatementContext) AllCOMMA() []antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetTokens(MySqlParserCOMMA)
}</span>

func (s *UpdateStatementContext) COMMA(i int) antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserCOMMA, i)
}</span>

func (s *UpdateStatementContext) WHERE() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(MySqlParserWHERE, 0)
}</span>

func (s *UpdateStatementContext) Expression() IExpressionContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(IExpressionContext)</span>
}

func (s *UpdateStatementContext) OrderByClause() IOrderByClauseContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrderByClauseContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(IOrderByClauseContext)</span>
}

func (s *UpdateStatementContext) LimitClause() ILimitClauseContext <span class="cov8" title="1">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*ILimitClauseContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return t.(ILimitClauseContext)</span>
}

func (s *UpdateStatementContext) AS() antlr.TerminalNode <span class="cov8" title="1">{
        return s.GetToken(MySqlParserAS, 0)
}</span>

func (s *UpdateStatementContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *UpdateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>


func (s *UpdateStatementContext) EnterRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.EnterUpdateStatement(s)
        }</span>
}

func (s *UpdateStatementContext) ExitRule(listener antlr.ParseTreeListener) <span class="cov0" title="0">{
        if listenerT, ok := listener.(MySqlParserListener); ok </span><span class="cov0" title="0">{
                listenerT.ExitUpdateStatement(s)
        }</span>
}

func (s *UpdateStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case MySqlParserVisitor:<span class="cov0" title="0">
                return t.VisitUpdateStatement(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}




func (p *MySqlParser) UpdateStatement() (localctx IUpdateStatementContext) <span class="cov8" title="1">{
        localctx = NewUpdateStatementContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 80, MySqlParserRULE_updateStatement)
        var _la int


        defer func() </span><span class="cov8" title="1">{
                p.ExitRule()
        }</span>()

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        if v, ok := err.(antlr.RecognitionException); ok </span><span class="cov0" title="0">{
                                localctx.SetException(v)
                                p.GetErrorHandler().ReportError(p, v)
                                p.GetErrorHandler().Recover(p, v)
                        }</span> else<span class="cov0" title="0"> {
                                panic(err)</span>
                        }
                }
        }()

        <span class="cov8" title="1">p.EnterOuterAlt(localctx, 1)
        </span><span class="cov8" title="1">{
                p.SetState(589)
                p.Match(MySqlParserUPDATE)
        }</span>
        <span class="cov8" title="1">p.SetState(591)
        p.GetErrorHandler().Sync(p)
        _la = p.GetTokenStream().LA(1)


        if _la == MySqlParserIGNORE </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        p.SetState(590)
                        p.Match(MySqlParserIGNORE)
                }</span>

        }
        <span class="cov8" title="1">{
                p.SetState(593)
                p.Match(MySqlParserID)
        }</span>
        <span class="cov8" title="1">p.SetState(598)
        p.GetErrorHandler().Sync(p)
        _la = p.GetTokenStream().LA(1)


        if _la == MySqlParserAS || _la == MySqlParserID </span><span class="cov0" title="0">{
                p.SetState(595)
                p.GetErrorHandler().Sync(p)
                _la = p.GetTokenStream().LA(1)


                if _la == MySqlParserAS </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                p.SetState(594)
                                p.Match(MySqlParserAS)
                        }</span>

                }
                <span class="cov0" title="0">{
                        p.SetState(597)
                        p.Match(MySqlParserID)
                }</span>

        }
        <span class="cov8" title="1">{
                p.SetState(600)
                p.Match(MySqlParserSET)
        }</span>
        <span class="cov8" title="1">{
                p.SetState(601)
                p.UpdatedElement()
        }</span>
        <span class="cov8" title="1">p.SetState(606)
        p.GetErrorHandler().Sync(p)
        _la = p.GetTokenStream().LA(1)


        for _la == MySqlParserCOMMA </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        p.SetState(602)
                        p.Match(MySqlParserCOMMA)
                }</span>
                <span class="cov0" title="0">{
                        p.SetState(603)
                        p.UpdatedElement()
                }</span>


                <span class="cov0" title="0">p.SetState(608)
                p.GetErrorHandler().Sync(p)
                _la = p.GetTokenStream().LA(1)</span>
        }
        <span class="cov8" title="1">p.SetState(611)
        p.GetErrorHandler().Sync(p)
        _la = p.GetTokenStream().LA(1)


        if _la == MySqlParserWHERE </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        p.SetState(609)
                        p.Match(MySqlParserWHERE)
                }</span>
                <span class="cov8" title="1">{
                        p.SetState(610)
                        p.expression(0)
                }</span>

        }
        <span class="cov8" title="1">p.SetState(614)
        p.GetErrorHandler().Sync(p)
        _la = p.GetTokenStream().LA(1)


        if _la == MySqlParserORDER </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        p.SetState(613)
                        p.OrderByClause()
                }</span>

        }
        <span class="cov8" title="1">p.SetState(617)
        p.GetErrorHandler().Sync(p)
        _la = p.GetTokenStream().LA(1)


        if _la == MySqlParserLIMIT </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        p.SetState(616)
                        p.LimitClause()
                }</span>

        }



        <span class="cov8" title="1">return localctx</span>
}


func (p *MySqlParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool <span class="cov0" title="0">{
        switch ruleIndex </span>{
        case 27:<span class="cov0" title="0">
                        var t *ExpressionContext = nil
                        if localctx != nil </span><span class="cov0" title="0">{ t = localctx.(*ExpressionContext) }</span>
                        <span class="cov0" title="0">return p.Expression_Sempred(t, predIndex)</span>

        case 28:<span class="cov0" title="0">
                        var t *PredicateContext = nil
                        if localctx != nil </span><span class="cov0" title="0">{ t = localctx.(*PredicateContext) }</span>
                        <span class="cov0" title="0">return p.Predicate_Sempred(t, predIndex)</span>

        case 29:<span class="cov0" title="0">
                        var t *ExpressionAtomContext = nil
                        if localctx != nil </span><span class="cov0" title="0">{ t = localctx.(*ExpressionAtomContext) }</span>
                        <span class="cov0" title="0">return p.ExpressionAtom_Sempred(t, predIndex)</span>


        default:<span class="cov0" title="0">
                panic("No predicate with index: " + fmt.Sprint(ruleIndex))</span>
        }
}

func (p *MySqlParser) Expression_Sempred(localctx antlr.RuleContext, predIndex int) bool <span class="cov0" title="0">{
        switch predIndex </span>{
        case 0:<span class="cov0" title="0">
                        return p.Precpred(p.GetParserRuleContext(), 3)</span>

        default:<span class="cov0" title="0">
                panic("No predicate with index: " + fmt.Sprint(predIndex))</span>
        }
}

func (p *MySqlParser) Predicate_Sempred(localctx antlr.RuleContext, predIndex int) bool <span class="cov0" title="0">{
        switch predIndex </span>{
        case 1:<span class="cov0" title="0">
                        return p.Precpred(p.GetParserRuleContext(), 6)</span>

        case 2:<span class="cov0" title="0">
                        return p.Precpred(p.GetParserRuleContext(), 4)</span>

        case 3:<span class="cov0" title="0">
                        return p.Precpred(p.GetParserRuleContext(), 3)</span>

        case 4:<span class="cov0" title="0">
                        return p.Precpred(p.GetParserRuleContext(), 2)</span>

        case 5:<span class="cov0" title="0">
                        return p.Precpred(p.GetParserRuleContext(), 8)</span>

        case 6:<span class="cov0" title="0">
                        return p.Precpred(p.GetParserRuleContext(), 7)</span>

        case 7:<span class="cov0" title="0">
                        return p.Precpred(p.GetParserRuleContext(), 5)</span>

        default:<span class="cov0" title="0">
                panic("No predicate with index: " + fmt.Sprint(predIndex))</span>
        }
}

func (p *MySqlParser) ExpressionAtom_Sempred(localctx antlr.RuleContext, predIndex int) bool <span class="cov0" title="0">{
        switch predIndex </span>{
        case 8:<span class="cov0" title="0">
                        return p.Precpred(p.GetParserRuleContext(), 2)</span>

        case 9:<span class="cov0" title="0">
                        return p.Precpred(p.GetParserRuleContext(), 1)</span>

        default:<span class="cov0" title="0">
                panic("No predicate with index: " + fmt.Sprint(predIndex))</span>
        }
}

</pre>
		
		<pre class="file" id="file12" style="display: none">// Code generated from /Users/zhangzhiqiang/go/src/github.com/Aiyane/golinq/sql-parser/MySqlParser.g4 by ANTLR 4.7.2. DO NOT EDIT.

package parser // MySqlParser

import "github.com/antlr/antlr4/runtime/Go/antlr"

// BaseMySqlParserListener is a complete listener for a parse tree produced by MySqlParser.
type BaseMySqlParserListener struct{}

var _ MySqlParserListener = &amp;BaseMySqlParserListener{}

// VisitTerminal is called when a terminal node is visited.
func (s *BaseMySqlParserListener) VisitTerminal(node antlr.TerminalNode) {<span class="cov0" title="0">}</span>

// VisitErrorNode is called when an error node is visited.
func (s *BaseMySqlParserListener) VisitErrorNode(node antlr.ErrorNode) {<span class="cov0" title="0">}</span>

// EnterEveryRule is called when any rule is entered.
func (s *BaseMySqlParserListener) EnterEveryRule(ctx antlr.ParserRuleContext) {<span class="cov0" title="0">}</span>

// ExitEveryRule is called when any rule is exited.
func (s *BaseMySqlParserListener) ExitEveryRule(ctx antlr.ParserRuleContext) {<span class="cov0" title="0">}</span>

// EnterDmlStatement is called when production dmlStatement is entered.
func (s *BaseMySqlParserListener) EnterDmlStatement(ctx *DmlStatementContext) {<span class="cov0" title="0">}</span>

// ExitDmlStatement is called when production dmlStatement is exited.
func (s *BaseMySqlParserListener) ExitDmlStatement(ctx *DmlStatementContext) {<span class="cov0" title="0">}</span>

// EnterSimpleSelect is called when production simpleSelect is entered.
func (s *BaseMySqlParserListener) EnterSimpleSelect(ctx *SimpleSelectContext) {<span class="cov0" title="0">}</span>

// ExitSimpleSelect is called when production simpleSelect is exited.
func (s *BaseMySqlParserListener) ExitSimpleSelect(ctx *SimpleSelectContext) {<span class="cov0" title="0">}</span>

// EnterParenthesisSelect is called when production parenthesisSelect is entered.
func (s *BaseMySqlParserListener) EnterParenthesisSelect(ctx *ParenthesisSelectContext) {<span class="cov0" title="0">}</span>

// ExitParenthesisSelect is called when production parenthesisSelect is exited.
func (s *BaseMySqlParserListener) ExitParenthesisSelect(ctx *ParenthesisSelectContext) {<span class="cov0" title="0">}</span>

// EnterOrderByClause is called when production orderByClause is entered.
func (s *BaseMySqlParserListener) EnterOrderByClause(ctx *OrderByClauseContext) {<span class="cov0" title="0">}</span>

// ExitOrderByClause is called when production orderByClause is exited.
func (s *BaseMySqlParserListener) ExitOrderByClause(ctx *OrderByClauseContext) {<span class="cov0" title="0">}</span>

// EnterOrderByExpression is called when production orderByExpression is entered.
func (s *BaseMySqlParserListener) EnterOrderByExpression(ctx *OrderByExpressionContext) {<span class="cov0" title="0">}</span>

// ExitOrderByExpression is called when production orderByExpression is exited.
func (s *BaseMySqlParserListener) ExitOrderByExpression(ctx *OrderByExpressionContext) {<span class="cov0" title="0">}</span>

// EnterTableSourceBase is called when production tableSourceBase is entered.
func (s *BaseMySqlParserListener) EnterTableSourceBase(ctx *TableSourceBaseContext) {<span class="cov0" title="0">}</span>

// ExitTableSourceBase is called when production tableSourceBase is exited.
func (s *BaseMySqlParserListener) ExitTableSourceBase(ctx *TableSourceBaseContext) {<span class="cov0" title="0">}</span>

// EnterTableSourceNested is called when production tableSourceNested is entered.
func (s *BaseMySqlParserListener) EnterTableSourceNested(ctx *TableSourceNestedContext) {<span class="cov0" title="0">}</span>

// ExitTableSourceNested is called when production tableSourceNested is exited.
func (s *BaseMySqlParserListener) ExitTableSourceNested(ctx *TableSourceNestedContext) {<span class="cov0" title="0">}</span>

// EnterTableSources is called when production tableSources is entered.
func (s *BaseMySqlParserListener) EnterTableSources(ctx *TableSourcesContext) {<span class="cov0" title="0">}</span>

// ExitTableSources is called when production tableSources is exited.
func (s *BaseMySqlParserListener) ExitTableSources(ctx *TableSourcesContext) {<span class="cov0" title="0">}</span>

// EnterAtomTableItem is called when production atomTableItem is entered.
func (s *BaseMySqlParserListener) EnterAtomTableItem(ctx *AtomTableItemContext) {<span class="cov0" title="0">}</span>

// ExitAtomTableItem is called when production atomTableItem is exited.
func (s *BaseMySqlParserListener) ExitAtomTableItem(ctx *AtomTableItemContext) {<span class="cov0" title="0">}</span>

// EnterSubqueryTableItem is called when production subqueryTableItem is entered.
func (s *BaseMySqlParserListener) EnterSubqueryTableItem(ctx *SubqueryTableItemContext) {<span class="cov0" title="0">}</span>

// ExitSubqueryTableItem is called when production subqueryTableItem is exited.
func (s *BaseMySqlParserListener) ExitSubqueryTableItem(ctx *SubqueryTableItemContext) {<span class="cov0" title="0">}</span>

// EnterTableSourcesItem is called when production tableSourcesItem is entered.
func (s *BaseMySqlParserListener) EnterTableSourcesItem(ctx *TableSourcesItemContext) {<span class="cov0" title="0">}</span>

// ExitTableSourcesItem is called when production tableSourcesItem is exited.
func (s *BaseMySqlParserListener) ExitTableSourcesItem(ctx *TableSourcesItemContext) {<span class="cov0" title="0">}</span>

// EnterInnerJoin is called when production innerJoin is entered.
func (s *BaseMySqlParserListener) EnterInnerJoin(ctx *InnerJoinContext) {<span class="cov0" title="0">}</span>

// ExitInnerJoin is called when production innerJoin is exited.
func (s *BaseMySqlParserListener) ExitInnerJoin(ctx *InnerJoinContext) {<span class="cov0" title="0">}</span>

// EnterOuterJoin is called when production outerJoin is entered.
func (s *BaseMySqlParserListener) EnterOuterJoin(ctx *OuterJoinContext) {<span class="cov0" title="0">}</span>

// ExitOuterJoin is called when production outerJoin is exited.
func (s *BaseMySqlParserListener) ExitOuterJoin(ctx *OuterJoinContext) {<span class="cov0" title="0">}</span>

// EnterQueryExpression is called when production queryExpression is entered.
func (s *BaseMySqlParserListener) EnterQueryExpression(ctx *QueryExpressionContext) {<span class="cov0" title="0">}</span>

// ExitQueryExpression is called when production queryExpression is exited.
func (s *BaseMySqlParserListener) ExitQueryExpression(ctx *QueryExpressionContext) {<span class="cov0" title="0">}</span>

// EnterQuerySpecification is called when production querySpecification is entered.
func (s *BaseMySqlParserListener) EnterQuerySpecification(ctx *QuerySpecificationContext) {<span class="cov0" title="0">}</span>

// ExitQuerySpecification is called when production querySpecification is exited.
func (s *BaseMySqlParserListener) ExitQuerySpecification(ctx *QuerySpecificationContext) {<span class="cov0" title="0">}</span>

// EnterSelectElements is called when production selectElements is entered.
func (s *BaseMySqlParserListener) EnterSelectElements(ctx *SelectElementsContext) {<span class="cov0" title="0">}</span>

// ExitSelectElements is called when production selectElements is exited.
func (s *BaseMySqlParserListener) ExitSelectElements(ctx *SelectElementsContext) {<span class="cov0" title="0">}</span>

// EnterSelectColumnElement is called when production selectColumnElement is entered.
func (s *BaseMySqlParserListener) EnterSelectColumnElement(ctx *SelectColumnElementContext) {<span class="cov0" title="0">}</span>

// ExitSelectColumnElement is called when production selectColumnElement is exited.
func (s *BaseMySqlParserListener) ExitSelectColumnElement(ctx *SelectColumnElementContext) {<span class="cov0" title="0">}</span>

// EnterSelectFunctionElement is called when production selectFunctionElement is entered.
func (s *BaseMySqlParserListener) EnterSelectFunctionElement(ctx *SelectFunctionElementContext) {<span class="cov0" title="0">}</span>

// ExitSelectFunctionElement is called when production selectFunctionElement is exited.
func (s *BaseMySqlParserListener) ExitSelectFunctionElement(ctx *SelectFunctionElementContext) {<span class="cov0" title="0">}</span>

// EnterSelectExpressionElement is called when production selectExpressionElement is entered.
func (s *BaseMySqlParserListener) EnterSelectExpressionElement(ctx *SelectExpressionElementContext) {<span class="cov0" title="0">}</span>

// ExitSelectExpressionElement is called when production selectExpressionElement is exited.
func (s *BaseMySqlParserListener) ExitSelectExpressionElement(ctx *SelectExpressionElementContext) {<span class="cov0" title="0">}</span>

// EnterFromClause is called when production fromClause is entered.
func (s *BaseMySqlParserListener) EnterFromClause(ctx *FromClauseContext) {<span class="cov0" title="0">}</span>

// ExitFromClause is called when production fromClause is exited.
func (s *BaseMySqlParserListener) ExitFromClause(ctx *FromClauseContext) {<span class="cov0" title="0">}</span>

// EnterGroupByItem is called when production groupByItem is entered.
func (s *BaseMySqlParserListener) EnterGroupByItem(ctx *GroupByItemContext) {<span class="cov0" title="0">}</span>

// ExitGroupByItem is called when production groupByItem is exited.
func (s *BaseMySqlParserListener) ExitGroupByItem(ctx *GroupByItemContext) {<span class="cov0" title="0">}</span>

// EnterLimitClause is called when production limitClause is entered.
func (s *BaseMySqlParserListener) EnterLimitClause(ctx *LimitClauseContext) {<span class="cov0" title="0">}</span>

// ExitLimitClause is called when production limitClause is exited.
func (s *BaseMySqlParserListener) ExitLimitClause(ctx *LimitClauseContext) {<span class="cov0" title="0">}</span>

// EnterFullColumnName is called when production fullColumnName is entered.
func (s *BaseMySqlParserListener) EnterFullColumnName(ctx *FullColumnNameContext) {<span class="cov0" title="0">}</span>

// ExitFullColumnName is called when production fullColumnName is exited.
func (s *BaseMySqlParserListener) ExitFullColumnName(ctx *FullColumnNameContext) {<span class="cov0" title="0">}</span>

// EnterBooleanLiteral is called when production booleanLiteral is entered.
func (s *BaseMySqlParserListener) EnterBooleanLiteral(ctx *BooleanLiteralContext) {<span class="cov0" title="0">}</span>

// ExitBooleanLiteral is called when production booleanLiteral is exited.
func (s *BaseMySqlParserListener) ExitBooleanLiteral(ctx *BooleanLiteralContext) {<span class="cov0" title="0">}</span>

// EnterNullNotnull is called when production nullNotnull is entered.
func (s *BaseMySqlParserListener) EnterNullNotnull(ctx *NullNotnullContext) {<span class="cov0" title="0">}</span>

// ExitNullNotnull is called when production nullNotnull is exited.
func (s *BaseMySqlParserListener) ExitNullNotnull(ctx *NullNotnullContext) {<span class="cov0" title="0">}</span>

// EnterConstant is called when production constant is entered.
func (s *BaseMySqlParserListener) EnterConstant(ctx *ConstantContext) {<span class="cov0" title="0">}</span>

// ExitConstant is called when production constant is exited.
func (s *BaseMySqlParserListener) ExitConstant(ctx *ConstantContext) {<span class="cov0" title="0">}</span>

// EnterUidList is called when production uidList is entered.
func (s *BaseMySqlParserListener) EnterUidList(ctx *UidListContext) {<span class="cov0" title="0">}</span>

// ExitUidList is called when production uidList is exited.
func (s *BaseMySqlParserListener) ExitUidList(ctx *UidListContext) {<span class="cov0" title="0">}</span>

// EnterExpressions is called when production expressions is entered.
func (s *BaseMySqlParserListener) EnterExpressions(ctx *ExpressionsContext) {<span class="cov0" title="0">}</span>

// ExitExpressions is called when production expressions is exited.
func (s *BaseMySqlParserListener) ExitExpressions(ctx *ExpressionsContext) {<span class="cov0" title="0">}</span>

// EnterSpecificFunctionCall is called when production specificFunctionCall is entered.
func (s *BaseMySqlParserListener) EnterSpecificFunctionCall(ctx *SpecificFunctionCallContext) {<span class="cov0" title="0">}</span>

// ExitSpecificFunctionCall is called when production specificFunctionCall is exited.
func (s *BaseMySqlParserListener) ExitSpecificFunctionCall(ctx *SpecificFunctionCallContext) {<span class="cov0" title="0">}</span>

// EnterScalarFunctionCall is called when production scalarFunctionCall is entered.
func (s *BaseMySqlParserListener) EnterScalarFunctionCall(ctx *ScalarFunctionCallContext) {<span class="cov0" title="0">}</span>

// ExitScalarFunctionCall is called when production scalarFunctionCall is exited.
func (s *BaseMySqlParserListener) ExitScalarFunctionCall(ctx *ScalarFunctionCallContext) {<span class="cov0" title="0">}</span>

// EnterCaseVarFunctionCall is called when production caseVarFunctionCall is entered.
func (s *BaseMySqlParserListener) EnterCaseVarFunctionCall(ctx *CaseVarFunctionCallContext) {<span class="cov0" title="0">}</span>

// ExitCaseVarFunctionCall is called when production caseVarFunctionCall is exited.
func (s *BaseMySqlParserListener) ExitCaseVarFunctionCall(ctx *CaseVarFunctionCallContext) {<span class="cov0" title="0">}</span>

// EnterCaseFunctionCall is called when production caseFunctionCall is entered.
func (s *BaseMySqlParserListener) EnterCaseFunctionCall(ctx *CaseFunctionCallContext) {<span class="cov0" title="0">}</span>

// ExitCaseFunctionCall is called when production caseFunctionCall is exited.
func (s *BaseMySqlParserListener) ExitCaseFunctionCall(ctx *CaseFunctionCallContext) {<span class="cov0" title="0">}</span>

// EnterCaseFuncAlternative is called when production caseFuncAlternative is entered.
func (s *BaseMySqlParserListener) EnterCaseFuncAlternative(ctx *CaseFuncAlternativeContext) {<span class="cov0" title="0">}</span>

// ExitCaseFuncAlternative is called when production caseFuncAlternative is exited.
func (s *BaseMySqlParserListener) ExitCaseFuncAlternative(ctx *CaseFuncAlternativeContext) {<span class="cov0" title="0">}</span>

// EnterFunctionArgs is called when production functionArgs is entered.
func (s *BaseMySqlParserListener) EnterFunctionArgs(ctx *FunctionArgsContext) {<span class="cov0" title="0">}</span>

// ExitFunctionArgs is called when production functionArgs is exited.
func (s *BaseMySqlParserListener) ExitFunctionArgs(ctx *FunctionArgsContext) {<span class="cov0" title="0">}</span>

// EnterAllFunctionArg is called when production allFunctionArg is entered.
func (s *BaseMySqlParserListener) EnterAllFunctionArg(ctx *AllFunctionArgContext) {<span class="cov0" title="0">}</span>

// ExitAllFunctionArg is called when production allFunctionArg is exited.
func (s *BaseMySqlParserListener) ExitAllFunctionArg(ctx *AllFunctionArgContext) {<span class="cov0" title="0">}</span>

// EnterFunctionArg is called when production functionArg is entered.
func (s *BaseMySqlParserListener) EnterFunctionArg(ctx *FunctionArgContext) {<span class="cov0" title="0">}</span>

// ExitFunctionArg is called when production functionArg is exited.
func (s *BaseMySqlParserListener) ExitFunctionArg(ctx *FunctionArgContext) {<span class="cov0" title="0">}</span>

// EnterIsExpression is called when production isExpression is entered.
func (s *BaseMySqlParserListener) EnterIsExpression(ctx *IsExpressionContext) {<span class="cov0" title="0">}</span>

// ExitIsExpression is called when production isExpression is exited.
func (s *BaseMySqlParserListener) ExitIsExpression(ctx *IsExpressionContext) {<span class="cov0" title="0">}</span>

// EnterNotExpression is called when production notExpression is entered.
func (s *BaseMySqlParserListener) EnterNotExpression(ctx *NotExpressionContext) {<span class="cov0" title="0">}</span>

// ExitNotExpression is called when production notExpression is exited.
func (s *BaseMySqlParserListener) ExitNotExpression(ctx *NotExpressionContext) {<span class="cov0" title="0">}</span>

// EnterLogicalExpression is called when production logicalExpression is entered.
func (s *BaseMySqlParserListener) EnterLogicalExpression(ctx *LogicalExpressionContext) {<span class="cov0" title="0">}</span>

// ExitLogicalExpression is called when production logicalExpression is exited.
func (s *BaseMySqlParserListener) ExitLogicalExpression(ctx *LogicalExpressionContext) {<span class="cov0" title="0">}</span>

// EnterPredicateExpression is called when production predicateExpression is entered.
func (s *BaseMySqlParserListener) EnterPredicateExpression(ctx *PredicateExpressionContext) {<span class="cov0" title="0">}</span>

// ExitPredicateExpression is called when production predicateExpression is exited.
func (s *BaseMySqlParserListener) ExitPredicateExpression(ctx *PredicateExpressionContext) {<span class="cov0" title="0">}</span>

// EnterExpressionAtomPredicate is called when production expressionAtomPredicate is entered.
func (s *BaseMySqlParserListener) EnterExpressionAtomPredicate(ctx *ExpressionAtomPredicateContext) {<span class="cov0" title="0">}</span>

// ExitExpressionAtomPredicate is called when production expressionAtomPredicate is exited.
func (s *BaseMySqlParserListener) ExitExpressionAtomPredicate(ctx *ExpressionAtomPredicateContext) {<span class="cov0" title="0">}</span>

// EnterInPredicate is called when production inPredicate is entered.
func (s *BaseMySqlParserListener) EnterInPredicate(ctx *InPredicateContext) {<span class="cov0" title="0">}</span>

// ExitInPredicate is called when production inPredicate is exited.
func (s *BaseMySqlParserListener) ExitInPredicate(ctx *InPredicateContext) {<span class="cov0" title="0">}</span>

// EnterSubqueryComparasionPredicate is called when production subqueryComparasionPredicate is entered.
func (s *BaseMySqlParserListener) EnterSubqueryComparasionPredicate(ctx *SubqueryComparasionPredicateContext) {<span class="cov0" title="0">}</span>

// ExitSubqueryComparasionPredicate is called when production subqueryComparasionPredicate is exited.
func (s *BaseMySqlParserListener) ExitSubqueryComparasionPredicate(ctx *SubqueryComparasionPredicateContext) {<span class="cov0" title="0">}</span>

// EnterBetweenPredicate is called when production betweenPredicate is entered.
func (s *BaseMySqlParserListener) EnterBetweenPredicate(ctx *BetweenPredicateContext) {<span class="cov0" title="0">}</span>

// ExitBetweenPredicate is called when production betweenPredicate is exited.
func (s *BaseMySqlParserListener) ExitBetweenPredicate(ctx *BetweenPredicateContext) {<span class="cov0" title="0">}</span>

// EnterBinaryComparasionPredicate is called when production binaryComparasionPredicate is entered.
func (s *BaseMySqlParserListener) EnterBinaryComparasionPredicate(ctx *BinaryComparasionPredicateContext) {<span class="cov0" title="0">}</span>

// ExitBinaryComparasionPredicate is called when production binaryComparasionPredicate is exited.
func (s *BaseMySqlParserListener) ExitBinaryComparasionPredicate(ctx *BinaryComparasionPredicateContext) {<span class="cov0" title="0">}</span>

// EnterIsNullPredicate is called when production isNullPredicate is entered.
func (s *BaseMySqlParserListener) EnterIsNullPredicate(ctx *IsNullPredicateContext) {<span class="cov0" title="0">}</span>

// ExitIsNullPredicate is called when production isNullPredicate is exited.
func (s *BaseMySqlParserListener) ExitIsNullPredicate(ctx *IsNullPredicateContext) {<span class="cov0" title="0">}</span>

// EnterLikePredicate is called when production likePredicate is entered.
func (s *BaseMySqlParserListener) EnterLikePredicate(ctx *LikePredicateContext) {<span class="cov0" title="0">}</span>

// ExitLikePredicate is called when production likePredicate is exited.
func (s *BaseMySqlParserListener) ExitLikePredicate(ctx *LikePredicateContext) {<span class="cov0" title="0">}</span>

// EnterRegexpPredicate is called when production regexpPredicate is entered.
func (s *BaseMySqlParserListener) EnterRegexpPredicate(ctx *RegexpPredicateContext) {<span class="cov0" title="0">}</span>

// ExitRegexpPredicate is called when production regexpPredicate is exited.
func (s *BaseMySqlParserListener) ExitRegexpPredicate(ctx *RegexpPredicateContext) {<span class="cov0" title="0">}</span>

// EnterUnaryExpressionAtom is called when production unaryExpressionAtom is entered.
func (s *BaseMySqlParserListener) EnterUnaryExpressionAtom(ctx *UnaryExpressionAtomContext) {<span class="cov0" title="0">}</span>

// ExitUnaryExpressionAtom is called when production unaryExpressionAtom is exited.
func (s *BaseMySqlParserListener) ExitUnaryExpressionAtom(ctx *UnaryExpressionAtomContext) {<span class="cov0" title="0">}</span>

// EnterSubqueryExpressionAtom is called when production subqueryExpressionAtom is entered.
func (s *BaseMySqlParserListener) EnterSubqueryExpressionAtom(ctx *SubqueryExpressionAtomContext) {<span class="cov0" title="0">}</span>

// ExitSubqueryExpressionAtom is called when production subqueryExpressionAtom is exited.
func (s *BaseMySqlParserListener) ExitSubqueryExpressionAtom(ctx *SubqueryExpressionAtomContext) {<span class="cov0" title="0">}</span>

// EnterPriorityMathExpressionAtom is called when production priorityMathExpressionAtom is entered.
func (s *BaseMySqlParserListener) EnterPriorityMathExpressionAtom(ctx *PriorityMathExpressionAtomContext) {<span class="cov0" title="0">}</span>

// ExitPriorityMathExpressionAtom is called when production priorityMathExpressionAtom is exited.
func (s *BaseMySqlParserListener) ExitPriorityMathExpressionAtom(ctx *PriorityMathExpressionAtomContext) {<span class="cov0" title="0">}</span>

// EnterConstantExpressionAtom is called when production constantExpressionAtom is entered.
func (s *BaseMySqlParserListener) EnterConstantExpressionAtom(ctx *ConstantExpressionAtomContext) {<span class="cov0" title="0">}</span>

// ExitConstantExpressionAtom is called when production constantExpressionAtom is exited.
func (s *BaseMySqlParserListener) ExitConstantExpressionAtom(ctx *ConstantExpressionAtomContext) {<span class="cov0" title="0">}</span>

// EnterFunctionCallExpressionAtom is called when production functionCallExpressionAtom is entered.
func (s *BaseMySqlParserListener) EnterFunctionCallExpressionAtom(ctx *FunctionCallExpressionAtomContext) {<span class="cov0" title="0">}</span>

// ExitFunctionCallExpressionAtom is called when production functionCallExpressionAtom is exited.
func (s *BaseMySqlParserListener) ExitFunctionCallExpressionAtom(ctx *FunctionCallExpressionAtomContext) {<span class="cov0" title="0">}</span>

// EnterFullColumnNameExpressionAtom is called when production fullColumnNameExpressionAtom is entered.
func (s *BaseMySqlParserListener) EnterFullColumnNameExpressionAtom(ctx *FullColumnNameExpressionAtomContext) {<span class="cov0" title="0">}</span>

// ExitFullColumnNameExpressionAtom is called when production fullColumnNameExpressionAtom is exited.
func (s *BaseMySqlParserListener) ExitFullColumnNameExpressionAtom(ctx *FullColumnNameExpressionAtomContext) {<span class="cov0" title="0">}</span>

// EnterNestedExpressionAtom is called when production nestedExpressionAtom is entered.
func (s *BaseMySqlParserListener) EnterNestedExpressionAtom(ctx *NestedExpressionAtomContext) {<span class="cov0" title="0">}</span>

// ExitNestedExpressionAtom is called when production nestedExpressionAtom is exited.
func (s *BaseMySqlParserListener) ExitNestedExpressionAtom(ctx *NestedExpressionAtomContext) {<span class="cov0" title="0">}</span>

// EnterMathExpressionAtom is called when production mathExpressionAtom is entered.
func (s *BaseMySqlParserListener) EnterMathExpressionAtom(ctx *MathExpressionAtomContext) {<span class="cov0" title="0">}</span>

// ExitMathExpressionAtom is called when production mathExpressionAtom is exited.
func (s *BaseMySqlParserListener) ExitMathExpressionAtom(ctx *MathExpressionAtomContext) {<span class="cov0" title="0">}</span>

// EnterExistsExpressionAtom is called when production existsExpressionAtom is entered.
func (s *BaseMySqlParserListener) EnterExistsExpressionAtom(ctx *ExistsExpressionAtomContext) {<span class="cov0" title="0">}</span>

// ExitExistsExpressionAtom is called when production existsExpressionAtom is exited.
func (s *BaseMySqlParserListener) ExitExistsExpressionAtom(ctx *ExistsExpressionAtomContext) {<span class="cov0" title="0">}</span>

// EnterUnaryOperator is called when production unaryOperator is entered.
func (s *BaseMySqlParserListener) EnterUnaryOperator(ctx *UnaryOperatorContext) {<span class="cov0" title="0">}</span>

// ExitUnaryOperator is called when production unaryOperator is exited.
func (s *BaseMySqlParserListener) ExitUnaryOperator(ctx *UnaryOperatorContext) {<span class="cov0" title="0">}</span>

// EnterComparisonOperator is called when production comparisonOperator is entered.
func (s *BaseMySqlParserListener) EnterComparisonOperator(ctx *ComparisonOperatorContext) {<span class="cov0" title="0">}</span>

// ExitComparisonOperator is called when production comparisonOperator is exited.
func (s *BaseMySqlParserListener) ExitComparisonOperator(ctx *ComparisonOperatorContext) {<span class="cov0" title="0">}</span>

// EnterLogicalOperator is called when production logicalOperator is entered.
func (s *BaseMySqlParserListener) EnterLogicalOperator(ctx *LogicalOperatorContext) {<span class="cov0" title="0">}</span>

// ExitLogicalOperator is called when production logicalOperator is exited.
func (s *BaseMySqlParserListener) ExitLogicalOperator(ctx *LogicalOperatorContext) {<span class="cov0" title="0">}</span>

// EnterMathOperator is called when production mathOperator is entered.
func (s *BaseMySqlParserListener) EnterMathOperator(ctx *MathOperatorContext) {<span class="cov0" title="0">}</span>

// ExitMathOperator is called when production mathOperator is exited.
func (s *BaseMySqlParserListener) ExitMathOperator(ctx *MathOperatorContext) {<span class="cov0" title="0">}</span>

// EnterInsertStatement is called when production insertStatement is entered.
func (s *BaseMySqlParserListener) EnterInsertStatement(ctx *InsertStatementContext) {<span class="cov0" title="0">}</span>

// ExitInsertStatement is called when production insertStatement is exited.
func (s *BaseMySqlParserListener) ExitInsertStatement(ctx *InsertStatementContext) {<span class="cov0" title="0">}</span>

// EnterInsertStatementValue is called when production insertStatementValue is entered.
func (s *BaseMySqlParserListener) EnterInsertStatementValue(ctx *InsertStatementValueContext) {<span class="cov0" title="0">}</span>

// ExitInsertStatementValue is called when production insertStatementValue is exited.
func (s *BaseMySqlParserListener) ExitInsertStatementValue(ctx *InsertStatementValueContext) {<span class="cov0" title="0">}</span>

// EnterUpdatedElement is called when production updatedElement is entered.
func (s *BaseMySqlParserListener) EnterUpdatedElement(ctx *UpdatedElementContext) {<span class="cov0" title="0">}</span>

// ExitUpdatedElement is called when production updatedElement is exited.
func (s *BaseMySqlParserListener) ExitUpdatedElement(ctx *UpdatedElementContext) {<span class="cov0" title="0">}</span>

// EnterExpressionsWithDefaults is called when production expressionsWithDefaults is entered.
func (s *BaseMySqlParserListener) EnterExpressionsWithDefaults(ctx *ExpressionsWithDefaultsContext) {<span class="cov0" title="0">}</span>

// ExitExpressionsWithDefaults is called when production expressionsWithDefaults is exited.
func (s *BaseMySqlParserListener) ExitExpressionsWithDefaults(ctx *ExpressionsWithDefaultsContext) {<span class="cov0" title="0">}</span>

// EnterExpressionOrDefault is called when production expressionOrDefault is entered.
func (s *BaseMySqlParserListener) EnterExpressionOrDefault(ctx *ExpressionOrDefaultContext) {<span class="cov0" title="0">}</span>

// ExitExpressionOrDefault is called when production expressionOrDefault is exited.
func (s *BaseMySqlParserListener) ExitExpressionOrDefault(ctx *ExpressionOrDefaultContext) {<span class="cov0" title="0">}</span>

// EnterDeleteStatement is called when production deleteStatement is entered.
func (s *BaseMySqlParserListener) EnterDeleteStatement(ctx *DeleteStatementContext) {<span class="cov0" title="0">}</span>

// ExitDeleteStatement is called when production deleteStatement is exited.
func (s *BaseMySqlParserListener) ExitDeleteStatement(ctx *DeleteStatementContext) {<span class="cov0" title="0">}</span>

// EnterUpdateStatement is called when production updateStatement is entered.
func (s *BaseMySqlParserListener) EnterUpdateStatement(ctx *UpdateStatementContext) {<span class="cov0" title="0">}</span>

// ExitUpdateStatement is called when production updateStatement is exited.
func (s *BaseMySqlParserListener) ExitUpdateStatement(ctx *UpdateStatementContext) {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">// Code generated from /Users/zhangzhiqiang/go/src/github.com/Aiyane/golinq/sql-parser/MySqlParser.g4 by ANTLR 4.7.2. DO NOT EDIT.

package parser // MySqlParser

import "github.com/antlr/antlr4/runtime/Go/antlr"

type BaseMySqlParserVisitor struct {
        *antlr.BaseParseTreeVisitor
}

func (v *BaseMySqlParserVisitor) VisitDmlStatement(ctx *DmlStatementContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitSimpleSelect(ctx *SimpleSelectContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitParenthesisSelect(ctx *ParenthesisSelectContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitOrderByClause(ctx *OrderByClauseContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitOrderByExpression(ctx *OrderByExpressionContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitTableSourceBase(ctx *TableSourceBaseContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitTableSourceNested(ctx *TableSourceNestedContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitTableSources(ctx *TableSourcesContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitAtomTableItem(ctx *AtomTableItemContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitSubqueryTableItem(ctx *SubqueryTableItemContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitTableSourcesItem(ctx *TableSourcesItemContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitInnerJoin(ctx *InnerJoinContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitOuterJoin(ctx *OuterJoinContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitQueryExpression(ctx *QueryExpressionContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitQuerySpecification(ctx *QuerySpecificationContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitSelectElements(ctx *SelectElementsContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitSelectColumnElement(ctx *SelectColumnElementContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitSelectFunctionElement(ctx *SelectFunctionElementContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitSelectExpressionElement(ctx *SelectExpressionElementContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitFromClause(ctx *FromClauseContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitGroupByItem(ctx *GroupByItemContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitLimitClause(ctx *LimitClauseContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitFullColumnName(ctx *FullColumnNameContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitBooleanLiteral(ctx *BooleanLiteralContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitNullNotnull(ctx *NullNotnullContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitConstant(ctx *ConstantContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitUidList(ctx *UidListContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitExpressions(ctx *ExpressionsContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitSpecificFunctionCall(ctx *SpecificFunctionCallContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitScalarFunctionCall(ctx *ScalarFunctionCallContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitCaseVarFunctionCall(ctx *CaseVarFunctionCallContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitCaseFunctionCall(ctx *CaseFunctionCallContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitCaseFuncAlternative(ctx *CaseFuncAlternativeContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitFunctionArgs(ctx *FunctionArgsContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitAllFunctionArg(ctx *AllFunctionArgContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitFunctionArg(ctx *FunctionArgContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitIsExpression(ctx *IsExpressionContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitNotExpression(ctx *NotExpressionContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitLogicalExpression(ctx *LogicalExpressionContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitPredicateExpression(ctx *PredicateExpressionContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitExpressionAtomPredicate(ctx *ExpressionAtomPredicateContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitInPredicate(ctx *InPredicateContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitSubqueryComparasionPredicate(ctx *SubqueryComparasionPredicateContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitBetweenPredicate(ctx *BetweenPredicateContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitBinaryComparasionPredicate(ctx *BinaryComparasionPredicateContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitIsNullPredicate(ctx *IsNullPredicateContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitLikePredicate(ctx *LikePredicateContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitRegexpPredicate(ctx *RegexpPredicateContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitUnaryExpressionAtom(ctx *UnaryExpressionAtomContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitSubqueryExpressionAtom(ctx *SubqueryExpressionAtomContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitPriorityMathExpressionAtom(ctx *PriorityMathExpressionAtomContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitConstantExpressionAtom(ctx *ConstantExpressionAtomContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitFunctionCallExpressionAtom(ctx *FunctionCallExpressionAtomContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitFullColumnNameExpressionAtom(ctx *FullColumnNameExpressionAtomContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitNestedExpressionAtom(ctx *NestedExpressionAtomContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitMathExpressionAtom(ctx *MathExpressionAtomContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitExistsExpressionAtom(ctx *ExistsExpressionAtomContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitUnaryOperator(ctx *UnaryOperatorContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitComparisonOperator(ctx *ComparisonOperatorContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitLogicalOperator(ctx *LogicalOperatorContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitMathOperator(ctx *MathOperatorContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitInsertStatement(ctx *InsertStatementContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitInsertStatementValue(ctx *InsertStatementValueContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitUpdatedElement(ctx *UpdatedElementContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitExpressionsWithDefaults(ctx *ExpressionsWithDefaultsContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitExpressionOrDefault(ctx *ExpressionOrDefaultContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitDeleteStatement(ctx *DeleteStatementContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseMySqlParserVisitor) VisitUpdateStatement(ctx *UpdateStatementContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package interpreters

import (
        sql_parser "github.com/Aiyane/golinq/sql-parser"
        "github.com/Aiyane/golinq/types"
)

var (
        SimpleDeleteInterp types.SimpleDeleteInterp
        OrderDeleteInterp  types.OrderDeleteInterp
)

func DeleteInterp(deleteExpr *sql_parser.DeleteExpr, dataSources types.DataSources) int <span class="cov8" title="1">{
        env = NewEnv()
        table := deleteExpr.Table
        singleTableName = table // 单一表名
        records := dataSources[table]
        var n int
        if deleteExpr.Order != nil </span><span class="cov8" title="1">{
                records, n = OrderDeleteInterp.Interp(deleteExpr, records)
        }</span> else<span class="cov8" title="1"> {
                records, n = SimpleDeleteInterp.Interp(deleteExpr, records)
        }</span>
        <span class="cov8" title="1">dataSources[table] = records
        return n</span>
}

type SimpleDelete struct{}

func (*SimpleDelete) Interp(deleteExpr *sql_parser.DeleteExpr, records types.Records) (types.Records, int) <span class="cov8" title="1">{
        total := len(records)
        needDeleteIndex := make([]int, 0, total)
        whereExpr := deleteExpr.Where
        for i, record := range records </span><span class="cov8" title="1">{
                if whereExpr == nil || visitFunc(whereExpr, types.InstanceDict{deleteExpr.Table: record}, -1) == true </span><span class="cov8" title="1">{
                        needDeleteIndex = append(needDeleteIndex, i)
                }</span>
        }
        <span class="cov8" title="1">if deleteExpr := deleteExpr.Limit; deleteExpr != nil </span><span class="cov0" title="0">{
                needDeleteIndex = deleteOrUpdateLimit(deleteExpr, needDeleteIndex)
        }</span>
        <span class="cov8" title="1">deleteLen := len(needDeleteIndex)
        return deleteRecords(total-deleteLen, needDeleteIndex, records), deleteLen</span>
}

func deleteRecords(retLen int, needDeleteIndex []int, records types.Records) types.Records <span class="cov8" title="1">{
        ret := make(types.Records, 0, retLen)
        subNum := 0
        for _, i := range needDeleteIndex </span><span class="cov8" title="1">{
                index := i - subNum
                ret = append(ret, records[:index]...)
                records = records[index+1:]
                subNum += index + 1
        }</span>
        <span class="cov8" title="1">ret = append(ret, records...)
        return ret</span>
}

func deleteOrUpdateLimit(sqlExpr *sql_parser.Limit, needDeleteIndex []int) []int <span class="cov8" title="1">{
        offset := visitConst(sqlExpr.Offset).(int)
        limit := visitConst(sqlExpr.Limit).(int)
        length := len(needDeleteIndex)
        if offset &gt;= length </span><span class="cov0" title="0">{
                return []int{}
        }</span>
        <span class="cov8" title="1">end := offset + limit
        if end &gt; length </span><span class="cov0" title="0">{
                end = length
        }</span>
        <span class="cov8" title="1">return needDeleteIndex[offset:end]</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package interpreters

import (
        sql_parser "github.com/Aiyane/golinq/sql-parser"
        "github.com/Aiyane/golinq/types"
)

type OrderDelete struct{}

func (*OrderDelete) Interp(deleteExpr *sql_parser.DeleteExpr, records types.Records) (types.Records, int) <span class="cov8" title="1">{
        // 初始化结果集
        res = make([]interface{}, 0, 100)
        orders := getOrders(deleteExpr.Order)
        total := len(records)
        needDeleteIndex := make([]int, 0, total)
        whereExpr := deleteExpr.Where
        for i, record := range records </span><span class="cov8" title="1">{
                instanceDict := types.InstanceDict{deleteExpr.Table: record}
                if whereExpr == nil || visitFunc(whereExpr, instanceDict, -1) == true </span><span class="cov8" title="1">{
                        index := bisectLeft(res, instanceDict, orders)
                        // 插入 index 位置
                        if index == len(res) </span><span class="cov8" title="1">{
                                res = append(res, instanceDict)
                                needDeleteIndex = append(needDeleteIndex, i)
                        }</span> else<span class="cov8" title="1"> {
                                res = append(res[:index+1], res[index:]...)
                                res[index] = instanceDict
                                needDeleteIndex = append(needDeleteIndex[:index+1], needDeleteIndex[index:]...)
                                needDeleteIndex[index] = i
                        }</span>
                }
        }
        <span class="cov8" title="1">if deleteExpr := deleteExpr.Limit; deleteExpr != nil </span><span class="cov8" title="1">{
                needDeleteIndex = deleteOrUpdateLimit(deleteExpr, needDeleteIndex)
        }</span>
        <span class="cov8" title="1">deleteLen := len(needDeleteIndex)
        return deleteRecords(total-deleteLen, needDeleteIndex, records), deleteLen</span>
}

func getOrders(expr []sql_parser.SqlToken) []*types.OrderFields <span class="cov8" title="1">{
        orders := make([]*types.OrderFields, 0, 10)
        for _, subExpr := range expr </span><span class="cov8" title="1">{
                orders = append(orders, getOrderList(subExpr))
        }</span>
        <span class="cov8" title="1">return orders</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package interpreters

import (
        "github.com/Aiyane/golinq/functions"
        "github.com/Aiyane/golinq/sql-parser"
        "github.com/Aiyane/golinq/types"
        "reflect"
)

var (
        singleTableName        string                          // 在能确定的单一表执行情况下保存的表名
        env                    *types.Env                      // 环境
        res                    []interface{}                   // 结果集
        expr                   *sql_parser.EXPR                // 语句
        TypeRegistry           = make(map[string]reflect.Type) // 类型字典
        hadSetStructFieldValue types.UsedKey                   // 是否设置过 struct 属性值
        tmpFieldValue          map[string]interface{}          // 临时属性值
        preFieldName           map[string]struct{}             // 前一个select语句的 select 字段名
)

// 生成解释环境
func NewEnv() *types.Env <span class="cov8" title="1">{
        return &amp;types.Env{
                // 将内置函数代理放入环境中
                Funcs:       functions.NewFuncProxy(),
                Index:       make([]*sql_parser.Func, 0, 10),
                AggrFuncs:   make(map[string]functions.SqlFunc, 10),
                AggPosition: make(map[int]bool, 10),
                Link:        make(map[int][]interface{}, 3),
                LinkCache:   make(map[int]interface{}, 3),
                HasAgg:      false,
                HasIndex:    false,
                GroupList:   make([]interface{}, 0, 10),
                GroupMap:    make(map[string]bool, 10),
                HasNames:    make(map[string]bool, 10),
                ReTableName: make(map[string]string, 10),
        }
}</span>

func clearEnv() <span class="cov8" title="1">{
        env.HasAgg = false
        env.AggrFuncs = make(map[string]functions.SqlFunc, 10)
        env.HasIndex = false
        env.GroupMap = make(map[string]bool, 10)
        env.GroupList = make([]interface{}, 0, 10)
        env.Index = make([]*sql_parser.Func, 0, 10)
        env.AggPosition = make(map[int]bool, 10)
        env.HasNames = make(map[string]bool, 10)
        env.ReTableName = make(map[string]string, 10)
        // 设置前一个select语句的 select 字段名, 为Link取值用
        preFieldName = make(map[string]struct{}, len(env.FieldName))
        for _, name := range env.FieldName </span><span class="cov8" title="1">{
                preFieldName[name] = struct{}{}
        }</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package interpreters

import (
        "github.com/Aiyane/golinq/functions"
        sql_parser "github.com/Aiyane/golinq/sql-parser"
        "github.com/Aiyane/golinq/types"
)

// insertExpr 插入语句
// dataSources 源数据
// records select 语句的结果集
func InsertInterp(insertExpr *sql_parser.InsertExpr, dataSources types.DataSources, records []interface{}) int <span class="cov8" title="1">{
        env = NewEnv()
        table := insertExpr.Table
        maxId, _ := getIdSet(dataSources[table])
        _columns := insertExpr.Columns
        columns := make([]string, 0, len(_columns))
        hasId := false
        for _, column := range _columns </span><span class="cov8" title="1">{
                columnName := visit(column, nil, -1).(string)
                if columnName == "id" </span><span class="cov8" title="1">{
                        hasId = true
                }</span>
                <span class="cov8" title="1">columns = append(columns, columnName)</span>
        }
        <span class="cov8" title="1">var values interface{} = insertExpr.Values
        if records != nil </span><span class="cov8" title="1">{
                values = records
        }</span>
        <span class="cov8" title="1">_, isStruct := TypeRegistry[table]
        insertRecordsIterator(values, func(record interface{}) </span><span class="cov8" title="1">{
                switch r := record.(type) </span>{
                case map[string]interface{}:<span class="cov8" title="1">
                        if isStruct </span><span class="cov0" title="0">{
                                resRecord := newStruct(table)
                                for _, column := range columns </span><span class="cov0" title="0">{
                                        if column == "id" </span><span class="cov0" title="0">{
                                                maxId = r[column]
                                        }</span>
                                        <span class="cov0" title="0">setValue(resRecord, column, r[column], false)</span>
                                }
                                <span class="cov0" title="0">if !hasId </span><span class="cov0" title="0">{
                                        newId := functions.Add(maxId, 1)
                                        setValue(resRecord, "id", newId, false)
                                        maxId = newId
                                }</span>
                                <span class="cov0" title="0">dataSources[table] = append(dataSources[table], resRecord)</span>
                        } else<span class="cov8" title="1"> {
                                resRecord := make(map[string]interface{})
                                for _, column := range columns </span><span class="cov8" title="1">{
                                        if column == "id" </span><span class="cov8" title="1">{
                                                maxId = r[column]
                                        }</span>
                                        <span class="cov8" title="1">resRecord[column] = r[column]</span>
                                }
                                <span class="cov8" title="1">if !hasId </span><span class="cov0" title="0">{
                                        newId := functions.Add(maxId, 1)
                                        resRecord["id"] = newId
                                        maxId = newId
                                }</span>
                                <span class="cov8" title="1">dataSources[table] = append(dataSources[table], resRecord)</span>
                        }
                case []sql_parser.SqlToken:<span class="cov8" title="1">
                        if isStruct </span><span class="cov0" title="0">{
                                resRecord := newStruct(table)
                                for i, column := range columns </span><span class="cov0" title="0">{
                                        if column == "id" </span><span class="cov0" title="0">{
                                                maxId = visit(r[i], nil, -1)
                                        }</span>
                                        <span class="cov0" title="0">setValue(resRecord, column, visit(r[i], nil, -1), false)</span>
                                }
                                <span class="cov0" title="0">if !hasId </span><span class="cov0" title="0">{
                                        newId := functions.Add(maxId, 1)
                                        setValue(resRecord, "id", newId, false)
                                        maxId = newId
                                }</span>
                                <span class="cov0" title="0">dataSources[table] = append(dataSources[table], resRecord)</span>
                        } else<span class="cov8" title="1"> {
                                resRecord := make(map[string]interface{})
                                for i, column := range columns </span><span class="cov8" title="1">{
                                        if column == "id" </span><span class="cov8" title="1">{
                                                maxId = visit(r[i], nil, -1)
                                        }</span>
                                        <span class="cov8" title="1">resRecord[column] = visit(r[i], nil, -1)</span>
                                }
                                <span class="cov8" title="1">if !hasId </span><span class="cov8" title="1">{
                                        newId := functions.Add(maxId, 1)
                                        resRecord["id"] = newId
                                        maxId = newId
                                }</span>
                                <span class="cov8" title="1">dataSources[table] = append(dataSources[table], resRecord)</span>
                        }
                }
        })
        <span class="cov8" title="1">return functions.ToInt(maxId).(int)</span>
}

func insertRecordsIterator(records interface{}, fn func(interface{})) <span class="cov8" title="1">{
        switch r := records.(type) </span>{
        case [][]sql_parser.SqlToken:<span class="cov8" title="1">
                for _, record := range r </span><span class="cov8" title="1">{
                        fn(record)
                }</span>
        case []interface{}:<span class="cov8" title="1">
                for _, record := range r </span><span class="cov8" title="1">{
                        fn(record)
                }</span>
        }
}

func getIdSet(records types.Records) (maxId interface{}, idSet map[interface{}]struct{})<span class="cov8" title="1">{
        idSet = make(map[interface{}]struct{}, len(records))
        maxId = 0
        for _, record := range records </span><span class="cov8" title="1">{
                id, _ := recordValue(record, "id")
                if functions.Greater(id, maxId) </span><span class="cov8" title="1">{
                        maxId = id
                }</span>
                <span class="cov8" title="1">idSet[id] = struct{}{}</span>
        }
        <span class="cov8" title="1">return maxId, idSet</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package interpreters

import (
        "github.com/Aiyane/golinq/functions"
        "github.com/Aiyane/golinq/types"
        "reflect"
        "strings"
)

var TagString string

func RegisterType(elem interface{}) <span class="cov8" title="1">{
        t := reflect.TypeOf(elem)
        e := t.Elem()
        TypeRegistry[e.Name()] = t
}</span>

func newStruct(name string) interface{} <span class="cov8" title="1">{
        elem, ok := TypeRegistry[name]
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return reflect.New(elem.Elem()).Interface()</span>
}

// 设置 struct/map 的值
// isDelete 删除 key 的值
func setValue(resRecord interface{}, key string, value interface{}, isDelete bool) <span class="cov8" title="1">{
        if isStruct(resRecord) </span><span class="cov8" title="1">{
                setStructValue(resRecord, key, value, isDelete)
        }</span> else<span class="cov8" title="1"> {
                setMapVlaue(resRecord, key, value, isDelete)
        }</span>
}

// 为 map 赋值
func setMapVlaue(resRecord interface{}, key string, value interface{}, isDelete bool) <span class="cov8" title="1">{
        if isDelete </span><span class="cov8" title="1">{
                delete(resRecord.(map[string]interface{}), key)
        }</span> else<span class="cov8" title="1"> {
                resRecord.(map[string]interface{})[key] = value
        }</span>
}

// 为 struct 赋值
func setStructValue(resRecord interface{}, key string, value interface{}, isDelete bool) <span class="cov8" title="1">{
        t := reflect.TypeOf(resRecord)
        v := reflect.ValueOf(resRecord)
        if t.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                t = t.Elem()
                v = v.Elem()
        }</span>
        <span class="cov8" title="1">if t.Name() == types.RecordStructName </span><span class="cov8" title="1">{
                if isDelete </span><span class="cov8" title="1">{
                        delete(hadSetStructFieldValue, key)
                        delete(tmpFieldValue, key)
                }</span> else<span class="cov8" title="1"> {
                        hadSetStructFieldValue[key] = struct{}{}
                }</span>
        }
        <span class="cov8" title="1">if _, exist := t.FieldByName(key); exist </span><span class="cov0" title="0">{
                // 设置过属性值
                hadSetStructFieldValue[key] = struct{}{}
                setFieldValue(v.FieldByName(key), value)
        }</span> else<span class="cov8" title="1"> {
                setValueFromTag(t, v, key, value, isDelete)
                tmpFieldValue[key] = value
        }</span>
}

// 从 tag 名中设置值
func setValueFromTag(resRecordOfType reflect.Type, resRecordOfValue reflect.Value, key string, value interface{}, isDelete bool) <span class="cov8" title="1">{
        fieldNum := resRecordOfType.NumField()
        for i := 0; i &lt; fieldNum; i++ </span><span class="cov8" title="1">{
                name := resRecordOfType.Field(i).Name
                tags := strings.Split(string(resRecordOfType.Field(i).Tag), "\"")
                if len(tags) &gt; 1 </span><span class="cov8" title="1">{
                        for j, tag := range tags </span><span class="cov8" title="1">{
                                if (tag == TagString+":" || tag == " "+TagString+":") &amp;&amp; len(tags) &gt;= j+2 </span><span class="cov8" title="1">{
                                        if tags[j+1] == key </span><span class="cov8" title="1">{
                                                field := resRecordOfValue.FieldByName(name)
                                                // 设置过属性值
                                                if isDelete || value == nil </span><span class="cov8" title="1">{
                                                        field.Set(reflect.Zero(field.Type()))
                                                }</span> else<span class="cov8" title="1"> {
                                                        setFieldValue(field, value)
                                                }</span>
                                                <span class="cov8" title="1">return</span>
                                        }
                                        <span class="cov8" title="1">break</span>
                                }
                        }
                }
        }
}

// 为结构体字段赋值 field 结构体字段, key 字段名, v 值
func setFieldValue(field reflect.Value, v interface{}) <span class="cov8" title="1">{
        typeName := field.Type().String()
        t, ok := functions.Name2Type[typeName]
        if !ok </span><span class="cov8" title="1">{
                field.Set(reflect.ValueOf(v))
        }</span> else<span class="cov8" title="1"> {
                realV := functions.Type2Func[t](reflect.ValueOf(v).Interface())
                field.Set(reflect.ValueOf(realV))
        }</span>
}

// 从 map 中取值
func valueFromMap(record interface{}, key string) (interface{}, bool) <span class="cov8" title="1">{
        v, ok := record.(map[string]interface{})[key]
        return v, ok
}</span>

// 从 struct 中取值
func valueFromStruct(record interface{}, key string) (interface{}, bool) <span class="cov8" title="1">{
        t := reflect.TypeOf(record)
        if t.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                t = t.Elem()
        }</span>
        <span class="cov8" title="1">var had bool
        if _, ok := hadSetStructFieldValue[key]; ok </span><span class="cov8" title="1">{
                had = true
        }</span> else<span class="cov8" title="1"> {
                had = false
        }</span>
        <span class="cov8" title="1">if _, exist := t.FieldByName(key); exist </span><span class="cov0" title="0">{
                return reflect.Indirect(reflect.ValueOf(record)).FieldByName(key).Interface(), had
        }</span>
        <span class="cov8" title="1">fieldNum := t.NumField()
        for i := 0; i &lt; fieldNum; i++ </span><span class="cov8" title="1">{
                name := t.Field(i).Name
                tags := strings.Split(string(t.Field(i).Tag), "\"")
                if len(tags) &gt; 1 </span><span class="cov8" title="1">{
                        for j, tag := range tags </span><span class="cov8" title="1">{
                                if (tag == TagString+":" || tag == " "+TagString+":") &amp;&amp; len(tags) &gt;= j+2 </span><span class="cov8" title="1">{
                                        if tags[j+1] == key </span><span class="cov8" title="1">{
                                                return reflect.Indirect(reflect.ValueOf(record)).FieldByName(name).Interface(), had
                                        }</span>
                                        <span class="cov8" title="1">break</span>
                                }
                        }
                }
        }
        <span class="cov8" title="1">if had </span><span class="cov8" title="1">{
                return tmpFieldValue[key], had
        }</span>
        <span class="cov8" title="1">return nil, had</span>
}

// 判断是 struct
func isStruct(record interface{}) bool <span class="cov8" title="1">{
        t := reflect.TypeOf(record)
        if t.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                t = t.Elem()
        }</span>
        <span class="cov8" title="1">if t.Kind() != reflect.Struct </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

// 取值
func recordValue(record interface{}, key string) (interface{}, bool) <span class="cov8" title="1">{
        if isStruct(record) </span><span class="cov8" title="1">{
                return valueFromStruct(record, key)
        }</span>
        <span class="cov8" title="1">return valueFromMap(record, key)</span>
}

// 返回 {key:value}
func recordKeyValue(record interface{}, fn func(name string, value interface{})) <span class="cov8" title="1">{
        if !isStruct(record) </span><span class="cov8" title="1">{
                for k, v := range record.(map[string]interface{}) </span><span class="cov8" title="1">{
                        fn(k, v)
                }</span>
        } else<span class="cov8" title="1"> {
                t := reflect.TypeOf(record)
                if t.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                        t = t.Elem()
                }</span>
                <span class="cov8" title="1">fieldNum := t.NumField()
                for i := 0; i &lt; fieldNum; i++ </span><span class="cov8" title="1">{
                        name := t.Field(i).Name
                        tagName := t.Field(i).Name
                        tags := strings.Split(string(t.Field(i).Tag), "\"")
                        if len(tags) &gt; 1 </span><span class="cov8" title="1">{
                                for j, tag := range tags </span><span class="cov8" title="1">{
                                        if (tag == TagString+":" || tag == " "+TagString+":") &amp;&amp; len(tags) &gt;= j+2 </span><span class="cov8" title="1">{
                                                tagName = tags[j+1]
                                                break</span>
                                        }
                                }
                        }
                        <span class="cov8" title="1">fn(tagName, reflect.Indirect(reflect.ValueOf(record)).FieldByName(name).Interface())</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package interpreters

import (
        "github.com/Aiyane/golinq/functions"
        "github.com/Aiyane/golinq/sql-parser"
        "github.com/Aiyane/golinq/types"
        "strconv"
)

// 该死的 Golang 没有泛型！！！
// 给不同 tag 的 SqlToken 对象分配不同的解释函数, 返回执行结果
// dataSources: 数据源
// env: 环境
// index: select 语句中的列号
// 例如:
// "SELECT COUNT(a.name), COUNT(a.age) FROM a" 中的
//          子语法树 SqlToken{COUNT(a.name)}
//          其 tag = FUNC, 其 index = 0 (备注说明: "COUNT(a.age)" 语句的 index = 1, 其他语句的 index = -1)
func visit(sqlExpr interface{}, dataSources interface{}, index int) interface{} <span class="cov8" title="1">{
        /*
                index: -1 时没有意义
        */
        switch dataSourcesOrInstanceDict := dataSources.(type) </span>{
        case types.DataSources:<span class="cov8" title="1">
                return visitDataSources(sqlExpr, dataSourcesOrInstanceDict)</span>
        case types.InstanceDict:<span class="cov8" title="1">
                return visitInstanceDict(sqlExpr, dataSourcesOrInstanceDict, index)</span>
        }
        <span class="cov8" title="1">switch subExpr := sqlExpr.(type) </span>{
        case *sql_parser.Const:<span class="cov8" title="1">
                return visitConst(subExpr)</span>
        case *sql_parser.Var:<span class="cov8" title="1">
                return subExpr.Value.Value</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func visitDataSources(sqlExpr interface{}, dataSources types.DataSources) interface{} <span class="cov8" title="1">{
        switch subExpr := sqlExpr.(type) </span>{
        case *sql_parser.Var:<span class="cov8" title="1">
                return visitFromVar(subExpr, dataSources)</span>
        case *sql_parser.Inner:<span class="cov8" title="1">
                return visitInner(subExpr, dataSources)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func visitInstanceDict(sqlExpr interface{}, instanceDict types.InstanceDict, index int) interface{} <span class="cov8" title="1">{
        switch subExpr := sqlExpr.(type) </span>{
        case *sql_parser.As:<span class="cov8" title="1">
                return visit(subExpr.Value, instanceDict, index)</span>
        case *sql_parser.Link:<span class="cov8" title="1">
                return visitLink(subExpr)</span>
        case *sql_parser.Case:<span class="cov8" title="1">
                return visitCase(subExpr, instanceDict, index)</span>
        case *sql_parser.Func:<span class="cov8" title="1">
                return visitFunc(subExpr, instanceDict, index)</span>
        case *sql_parser.Var:<span class="cov8" title="1">
                return visitVar(subExpr, instanceDict)</span>
        case *sql_parser.Const:<span class="cov8" title="1">
                return visitConst(subExpr)</span>
        case []sql_parser.SqlToken:<span class="cov8" title="1">
                var ret []interface{}
                for _, subExpr := range subExpr </span><span class="cov8" title="1">{
                        ret = append(ret, visitInstanceDict(subExpr, instanceDict, index))
                }</span>
                <span class="cov8" title="1">return ret</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// 解释 LIMIT 语句
// 例如: res = [
//         {"name": "li"},
//  {"age": 18},
// ]
// sqlExpr = SqlToken{LIMIT 1, 1}
// 返回: [
//         {"age": 18},
// ]
func visitLimit(sqlExpr *sql_parser.Limit) <span class="cov8" title="1">{
        offset := visitConst(sqlExpr.Offset).(int)
        limit := visitConst(sqlExpr.Limit).(int)
        length := len(res)
        if offset &gt;= length </span><span class="cov0" title="0">{
                res = []interface{}{}
        }</span>
        <span class="cov8" title="1">end := offset + limit
        if end &gt; length </span><span class="cov8" title="1">{
                end = length
        }</span>
        <span class="cov8" title="1">res = res[offset:end]</span>
}

// 链接子 SELECT 语句结果
// 例如: sqlExpr = SqlToken{Tag=LINK, Args=1}
// 表示链接 id=1 的 SELECT 语句结果, 结果保存在 env.Link 中
// env.Link[1] = [
//         {"name": "li", "time": 20},
//  {"name": "jay", "time": 30},
// ]
// 返回:
// [
//         ["li", 20],
//  ["jay", 30],
// ]
func visitLink(sqlExpr *sql_parser.Link) interface{} <span class="cov8" title="1">{
        if ret, exist := env.LinkCache[sqlExpr.Id]; exist </span><span class="cov8" title="1">{
                return ret
        }</span>
        <span class="cov8" title="1">var ret []interface{}
        for _, resRecord := range env.Link[sqlExpr.Id] </span><span class="cov8" title="1">{
                var line []interface{}
                for key := range preFieldName </span><span class="cov8" title="1">{
                        v, _ := recordValue(resRecord, key)
                        line = append(line, v)
                }</span>
                <span class="cov8" title="1">if len(line) == 1 </span><span class="cov8" title="1">{
                        ret = append(ret, line[0])
                }</span> else<span class="cov0" title="0"> {
                        ret = append(ret, line)
                }</span>
        }
        <span class="cov8" title="1">env.LinkCache[sqlExpr.Id] = ret
        return ret</span>
}

// 解释 CASE 语句 [[条件, 结果], [条件, 结果], ..., [nil, 结果]]
//          满足条件, 返回对应结果, 如果最后一个条件是 ELSE, 其值保存的是 nil
func visitCase(sqlExpr *sql_parser.Case, instanceDict types.InstanceDict, index int) interface{} <span class="cov8" title="1">{
        for _, caseItem := range sqlExpr.Values </span><span class="cov8" title="1">{
                condition, val := caseItem.Condition, caseItem.Value
                if condition == nil || visitFunc(condition.(*sql_parser.Func), instanceDict, index).(bool) </span><span class="cov8" title="1">{
                        return visit(val, instanceDict, index)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// 解释函数, 一般函数保存在 env.Funcs 中, 聚合函数
//          以 `函数名+列号` 保存在 env.AggrFuncs 中
//          函数参数保存在 Args 属性中, 第一个参数是 DISTINCT, 忽略
func visitFunc(sqlExpr *sql_parser.Func, instanceDict types.InstanceDict, index int) interface{} <span class="cov8" title="1">{
        function := getFunc(index, sqlExpr.Name)

        var funcArgs []interface{}
        for _, _funcArg := range sqlExpr.Args </span><span class="cov8" title="1">{
                funcArg := visit(_funcArg, instanceDict, index)
                if funcArg == "*" </span><span class="cov8" title="1">{
                        funcArgs = append(funcArgs, funcStar(instanceDict)...)
                }</span> else<span class="cov8" title="1"> {
                        funcArgs = append(funcArgs, funcArg)
                }</span>
        }
        <span class="cov8" title="1">return function(funcArgs...)</span>
}

// 解释常数, 例如 sqlExpr = SqlToken{100}
func visitConst(sqlExpr *sql_parser.Const) interface{} <span class="cov8" title="1">{
        return sqlExpr.Value
}</span>

// 解释 JOIN ON 语句, 将 ON 部分语句保存在环境中, 返回 JOIN 表结果
// 例如: "JOIN b ON a.id=b.a_id"
// dataSources = {
//         "a": [
//           {"id": 1, "name": "hi"},
//    {"id": 1, "name": "ok"},
//    {"id": 2, "name": "hi"},
//    {"id": 2, "name": "ok"},
//         ],
//  "b": [
//    {"a_id": 1, "other": "ha"},
//    {"a_id": 1, "other": "hh"},
//  ],
//  "c": [
//    {"a_id": 2, "field": "yo"},
//    {"a_id": 2, "field": "ya"},
//  ]
// }
// sqlExpr = SqlToken{JOIN b ON a.id=b.a_id}
// env.HasIndex &lt;= true
// env.Index &lt;= SqlToken{a.id=b.a_id}
// 返回: [
//  "b", [
//    {"a_id": 1, "other": "ha"},
//    {"a_id": 1, "other": "hh"},
//  ],
// ]
func visitInner(sqlExpr *sql_parser.Inner, dataSources types.DataSources) interface{} <span class="cov8" title="1">{
        if sqlExpr.Condition != nil </span><span class="cov8" title="1">{
                env.HasIndex = true
                env.Index = append(env.Index, sqlExpr.Condition)
        }</span>
        <span class="cov8" title="1">return &amp;types.InnerTable{
                Name:  sqlExpr.Table.Value.Value.(string),
                Table: visit(sqlExpr.Table, dataSources, -1).(types.Records),
        }</span>
}

// 解释变量, 返回变量的真实值
// 例如: sqlExpr = SqlToken{"a.name.first"}
// dataSourcesOrInstanceDict = {
//         "a": {"id": 1, "name": "hi"},
//  "b": {"a_id": 1, "other": "ha"},
//  "c": {"a_id": 2, "field": "yo"},
// }
// "a" =&gt; {"id": 1, "name": "hi"}
// "a.name" =&gt; "hi",
// "a.name.first" =&gt; "h"
// 返回: "h"
// 再例如: sqlExpr = SqlToken{"a"}
// dataSourcesOrInstanceDict = {
//         "a": [
//           {"id": 1, "name": "hi"},
//    {"id": 1, "name": "ok"},
//    {"id": 2, "name": "hi"},
//    {"id": 2, "name": "ok"},
//         ],
//  "b": [
//    {"a_id": 1, "other": "ha"},
//    {"a_id": 1, "other": "hh"},
//  ],
//  "c": [
//    {"a_id": 2, "field": "yo"},
//    {"a_id": 2, "field": "ya"},
//  ]
// }
// 返回:
// "a": [
//           {"id": 1, "name": "hi"},
//    {"id": 1, "name": "ok"},
//    {"id": 2, "name": "hi"},
//    {"id": 2, "name": "ok"},
//         ],
func visitVar(sqlExpr *sql_parser.Var, instanceDict types.InstanceDict) interface{} <span class="cov8" title="1">{
        name := visitConst(sqlExpr.Value).(string)
        if rename, exist := env.ReTableName[name]; exist </span><span class="cov8" title="1">{
                name = rename
        }</span>
        <span class="cov8" title="1">record := instanceDict[name]
        var ok bool
        // 单一表可以省略表名
        if record == nil &amp;&amp; singleTableName != "" </span><span class="cov8" title="1">{
                record = instanceDict[singleTableName]
                record, ok = recordValue(record, name)
                // 解决没有引号引起的var错误
                if record == nil &amp;&amp; !ok </span><span class="cov8" title="1">{
                        return name
                }</span>
        }
        <span class="cov8" title="1">next := sqlExpr.Next
        for next != nil </span><span class="cov8" title="1">{
                name = visitConst(next.Value).(string)
                record, _ = recordValue(record, name)
                next = next.Next
        }</span>
        <span class="cov8" title="1">return record</span>
}

// 获取表内容
func visitFromVar(sqlExpr *sql_parser.Var, dataSources types.DataSources) interface{} <span class="cov8" title="1">{
        name := visitConst(sqlExpr.Value)
        records := dataSources[name.(string)]
        return records
}</span>

// 解释 FROM 语句, 返回数据源
// 例如: "FROM b, c"
// dataSources = {
//         "a": [
//           {"id": 1, "name": "hi"},
//    {"id": 1, "name": "ok"},
//    {"id": 2, "name": "hi"},
//    {"id": 2, "name": "ok"},
//         ],
//  "b": [
//    {"a_id": 1, "other": "ha"},
//    {"a_id": 1, "other": "hh"},
//  ],
//  "c": [
//    {"a_id": 2, "field": "yo"},
//    {"a_id": 2, "field": "ya"},
//  ]
// }
// sqlExpr = [SqlToken{b}, SqlToken{c}]
// 返回:
// {
//  "b": [
//    {"a_id": 1, "other": "ha"},
//    {"a_id": 1, "other": "hh"},
//  ],
//  "c": [
//    {"a_id": 2, "field": "yo"},
//    {"a_id": 2, "field": "ya"},
//  ]
// }
func visitTables(sqlExpr *sql_parser.Tables, dataSources types.DataSources) types.DataSources <span class="cov8" title="1">{
        var key string
        var ret = make(types.DataSources, 10)
        for _, tableExpr := range sqlExpr.Values </span><span class="cov8" title="1">{
                records := visit(tableExpr, dataSources, -1)
                switch subExpr := tableExpr.(type) </span>{
                case *sql_parser.Var:<span class="cov8" title="1">
                        key = subExpr.Value.Value.(string)
                        singleTableName = key</span> // 单一表可以确定表名
                case *sql_parser.As:<span class="cov8" title="1">
                        records = visit(subExpr.Value, dataSources, -1)
                        key = subExpr.NewName.Value.(string)
                        env.ReTableName[subExpr.Value.(*sql_parser.Var).Value.Value.(string)] = key</span>
                case *sql_parser.Inner:<span class="cov8" title="1">
                        key = records.(*types.InnerTable).Name
                        records = records.(*types.InnerTable).Table</span>
                }
                <span class="cov8" title="1">ret[key] = records.(types.Records)</span>
        }
        <span class="cov8" title="1">return ret</span>
}

func visitSelect(sqlExpr []sql_parser.SqlToken, instanceDict types.InstanceDict) interface{} <span class="cov8" title="1">{
        // * 表达式
        if visit(sqlExpr[1], nil, -1) == true </span><span class="cov8" title="1">{
                return selectStar(instanceDict)
        }</span>
        <span class="cov8" title="1">var resRecord interface{}
        if useStruct() </span><span class="cov8" title="1">{
                resRecord = newStruct(types.RecordStructName)
                hadSetStructFieldValue = make(types.UsedKey, 10)
                tmpFieldValue = make(map[string]interface{}, 10)
                for i, subExpr := range sqlExpr[2:] </span><span class="cov8" title="1">{
                        setValue(resRecord, env.FieldName[i], visit(subExpr, instanceDict, i), false)
                }</span>
        } else<span class="cov8" title="1"> {
                resRecord = make(map[string]interface{}, len(sqlExpr)-2)
                for i, subExpr := range sqlExpr[2:] </span><span class="cov8" title="1">{
                        resRecord.(map[string]interface{})[env.FieldName[i]] = visit(subExpr, instanceDict, i)
                }</span>
        }
        <span class="cov8" title="1">return resRecord</span>
}

// 解释函数中 * 表达式
func funcStar(instanceDict types.InstanceDict) []interface{} <span class="cov8" title="1">{
        var ret []interface{}
        for _, record := range instanceDict </span><span class="cov8" title="1">{
                recordKeyValue(record, func(name string, value interface{}) </span><span class="cov8" title="1">{
                        ret = append(ret, value)
                }</span>)
        }
        <span class="cov8" title="1">return ret</span>
}

// 获取函数
func getFunc(index int, name string) functions.SqlFunc <span class="cov8" title="1">{
        var function functions.SqlFunc
        if index &gt;= 0 &amp;&amp; env.AggPosition[index] </span><span class="cov8" title="1">{
                if _function, exist := env.AggrFuncs[name+strconv.Itoa(index)]; exist </span><span class="cov8" title="1">{
                        function = _function
                }</span> else<span class="cov8" title="1"> {
                        function = env.Funcs.Get(name)
                }</span>
        } else<span class="cov8" title="1"> {
                function = env.Funcs.Get(name)
        }</span>
        <span class="cov8" title="1">return function</span>
}

// 创建索引, 由 indexExpr、dataSources 条件构造 indexDict
// 例如:
// indexExpr = "FROM a JOIN b ON a.id = b.a_id join c ON a.id = c.a_id" 的
//   条件语法树 [SqlToken{a.id = b.a_id}, SqlToken{a.id = c.a_id}]
// dataSources = {
//         "a": [
//           {"id": 1, "name": "hi"},
//    {"id": 1, "name": "ok"},
//    {"id": 2, "name": "hi"},
//    {"id": 2, "name": "ok"},
//         ],
//  "b": [
//    {"a_id": 1, "other": "ha"},
//    {"a_id": 1, "other": "hh"},
//  ],
//  "c": [
//    {"a_id": 2, "field": "yo"},
//    {"a_id": 2, "field": "ya"},
//  ]
// }
// indexDict &lt;=
// {
// "a": {
//           1: [
//                 {"a": {"id": 1, "name": "hi"}},
//                {"a": {"id": 1, "name": "ok"}},
//           ],
//    2: [
//          {"a": {"id": 2, "name": "hi"}},
//                {"a": {"id": 2, "name": "ok"}},
//    ]
//   },
// "b": {
//           1: [
//                 {"b": {"a_id": 1, "other": "ha"}},
//                {"b": {"a_id": 1, "other": "hh"}},
//           ],
//   },
// "c": {
//    2: [
//          {"c": {"a_id": 2, "field": "yo"}},
//                {"c": {"a_id": 2, "field": "ya"}},
//    ]
//   },
// }
func makeIndexDict(indexExpr_ interface{}, dataSources types.DataSources, indexDict types.IndexDict) <span class="cov8" title="1">{
        switch indexExpr := indexExpr_.(type) </span>{
        case []*sql_parser.Func:<span class="cov8" title="1">
                for _, subExpr := range indexExpr </span><span class="cov8" title="1">{
                        makeIndexDict(subExpr, dataSources, indexDict)
                }</span>
        case *sql_parser.Func:<span class="cov8" title="1">
                if indexExpr.Name == functions.Keys.Equal </span><span class="cov8" title="1">{
                        makeIndexDict(indexExpr.Args[0], dataSources, indexDict)
                        makeIndexDict(indexExpr.Args[1], dataSources, indexDict)
                }</span> else<span class="cov0" title="0"> {
                        // 不是等号, 放入 where 语句中
                        expr.WhereExpr = &amp;sql_parser.Func{
                                Name: functions.Keys.And,
                                Args: []interface{}{expr.WhereExpr, indexExpr},
                        }
                }</span>
        case *sql_parser.Var:<span class="cov8" title="1">
                tableName := visitConst(indexExpr.Value).(string)
                if records, exist := dataSources[tableName]; exist </span><span class="cov8" title="1">{
                        delete(dataSources, tableName)
                        indexRecords := make(types.IndexRecords, 10)
                        for _, record := range records </span><span class="cov8" title="1">{
                                value, next := record, indexExpr.Next
                                for next != nil </span><span class="cov8" title="1">{
                                        newName := visitConst(next.Value).(string)
                                        value, _ = recordValue(value, newName)
                                        next = next.Next
                                }</span>
                                <span class="cov8" title="1">if _, ok := indexRecords[value]; !ok </span><span class="cov8" title="1">{
                                        indexRecords[value] = []types.Record{}
                                }</span>
                                <span class="cov8" title="1">indexRecords[value] = append(indexRecords[value], record)</span>
                        }
                        <span class="cov8" title="1">indexDict[tableName] = indexRecords</span>
                }
        }
}

// 调整重名
func adjustName(newName string, resRecord interface{}, hadAdjust map[string]bool,
        key2table map[string]string, value interface{}) <span class="cov8" title="1">{
        if value2, ok := recordValue(resRecord, newName); ok </span><span class="cov8" title="1">{
                newName2 := key2table[newName] + "_" + newName
                setValue(resRecord, newName, nil, true)
                adjustName(newName2, resRecord, hadAdjust, key2table, value2)
        }</span>
        <span class="cov8" title="1">setValue(resRecord, newName, value, false)
        hadAdjust[newName] = true</span>
}

// 解释 SELECT 语句中的 * 表达式
func selectStar(instanceDict types.InstanceDict) interface{} <span class="cov8" title="1">{
        var resRecord interface{}
        if useStruct() </span><span class="cov8" title="1">{
                resRecord = newStruct(types.RecordStructName)
                hadSetStructFieldValue = make(types.UsedKey, 10)
                tmpFieldValue = make(map[string]interface{}, 10)
        }</span> else<span class="cov8" title="1"> {
                resRecord = make(map[string]interface{})
        }</span>
        <span class="cov8" title="1">hadAdjust := make(map[string]bool)
        key2table := make(map[string]string)
        hadName := make(map[string]bool)
        for table, record := range instanceDict </span><span class="cov8" title="1">{
                recordKeyValue(record, func(key string, value interface{}) </span><span class="cov8" title="1">{
                        if value2, ok := recordValue(resRecord, key); ok </span><span class="cov8" title="1">{
                                newName := table + "_" + key
                                adjustName(newName, resRecord, hadAdjust, key2table, value)
                                // 存在的key未被调整过的状态
                                if !hadAdjust[key] </span><span class="cov8" title="1">{
                                        newName2 := key2table[key] + "_" + key
                                        // 先将存在的删除
                                        setValue(resRecord, key, nil, true)
                                        adjustName(newName2, resRecord, hadAdjust, key2table, value2)
                                }</span>
                        } else<span class="cov8" title="1"> {
                                // 存在key已经是已有字段, 需要调整
                                if hadName[key] </span><span class="cov8" title="1">{
                                        newName := table + "_" + key
                                        adjustName(newName, resRecord, hadAdjust, key2table, value)
                                        // key不是已有字段, 并且key也没有存在的
                                }</span> else<span class="cov8" title="1"> {
                                        setValue(resRecord, key, value, false)
                                        hadName[key] = true
                                        key2table[key] = table
                                }</span>
                        }
                })
        }
        <span class="cov8" title="1">return resRecord</span>
}

// 若 SELECT 语句中有聚合函数，则在环境中保存聚合函数，保存相应列位置，保存是否有聚合函数
// 例如:
// token = "SELECT COUNT(a.name), COUNT(a.age) FROM a" 中的
//   选择语法树 [false, false, SqlToken{COUNT(a.name)}, SqlToken{COUNT(a.age)}], 其中
//   列表前两个元素表示是否有 DISTINCT、*
// env.AggPosition &lt;= {0: true, 1: true}
// env.initAggfuncsFieldName &lt;= {"COUNT1": count函数对象, "COUNT2": count函数对象}}
// env.HasAgg &lt;= true
func initAggfuncsFieldName(token interface{}, i int) string <span class="cov8" title="1">{
        switch subExpr := token.(type) </span>{
        case *sql_parser.As:<span class="cov8" title="1">
                initAggfuncsFieldName(subExpr.Value, i)
                return visitConst(subExpr.NewName).(string)</span>
        case *sql_parser.Func:<span class="cov8" title="1">
                // CASE 语句最后一个条件 ELSE 是 nil
                if subExpr == nil </span><span class="cov0" title="0">{
                        return ""
                }</span>
                <span class="cov8" title="1">if env.Funcs.AggregateFuncNameSet[subExpr.Name] </span><span class="cov8" title="1">{
                        env.HasAgg = true
                        env.AggPosition[i] = true
                        env.AggrFuncs[subExpr.Name+strconv.Itoa(i)] = env.Funcs.Get(subExpr.Name)
                }</span>
                // 防止嵌套函数
                <span class="cov8" title="1">for _, subExpr := range subExpr.Args </span><span class="cov8" title="1">{
                        initAggfuncsFieldName(subExpr, i)
                }</span>
                <span class="cov8" title="1">return subExpr.Name</span>
        case *sql_parser.Var:<span class="cov8" title="1">
                name := visitConst(subExpr.Value).(string)
                next := subExpr.Next
                for next != nil </span><span class="cov8" title="1">{
                        name = visitConst(next.Value).(string)
                        next = next.Next
                }</span>
                <span class="cov8" title="1">return name</span>
        case *sql_parser.Case:<span class="cov8" title="1">
                for _, subExpr := range subExpr.Values </span><span class="cov8" title="1">{
                        initAggfuncsFieldName(subExpr, i)
                }</span>
                <span class="cov8" title="1">return "case"</span>
        case *sql_parser.CaseItem:<span class="cov8" title="1">
                initAggfuncsFieldName(subExpr.Condition, i)
                initAggfuncsFieldName(subExpr.Value, i)</span>
        }
        <span class="cov8" title="1">return ""</span>
}

// 预处理
func pretreatment(token []sql_parser.SqlToken) <span class="cov8" title="1">{
        length := len(token) - 2
        env.NameIds = make([]int, length)
        env.FieldName = make([]string, length)
        for j, subSubExpr := range token[2:] </span><span class="cov8" title="1">{
                fieldName := initAggfuncsFieldName(subSubExpr, j)
                // 非 * 表达式
                if visit(token[1], nil, -1) != true </span><span class="cov8" title="1">{
                        // 结果集字段名冲突
                        if _, exist := env.HasNames[fieldName]; exist </span><span class="cov0" title="0">{
                                env.NameIds[j]++
                                newFieldName := fieldName + "_" + string(env.NameIds[j])
                                env.FieldName[j] = newFieldName
                                env.HasNames[newFieldName] = true
                        }</span> else<span class="cov8" title="1"> {
                                env.FieldName[j] = fieldName
                                env.HasNames[fieldName] = true
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package interpreters

import (
        "encoding/json"
        "github.com/Aiyane/golinq/functions"
        "github.com/Aiyane/golinq/sql-parser"
        "github.com/Aiyane/golinq/types"
        "unsafe"
)

func groupVisit(sqlExpr interface{}, groupDataSources types.GroupDataSources, index int) interface{} <span class="cov8" title="1">{
        switch subExpr := sqlExpr.(type) </span>{
        case *sql_parser.Var:<span class="cov8" title="1">
                return groupVisitVar(subExpr, groupDataSources, index)</span>
        case *sql_parser.Const:<span class="cov8" title="1">
                return groupVisitConst(subExpr)</span>
        case *sql_parser.As:<span class="cov8" title="1">
                return groupVisit(subExpr.Value, groupDataSources, index)</span>
        case *sql_parser.Func:<span class="cov8" title="1">
                return groupVisitFunc(subExpr, groupDataSources, index)</span>
        case *sql_parser.Link:<span class="cov0" title="0">
                return groupVisitLink(subExpr)</span>
        case *sql_parser.Case:<span class="cov0" title="0">
                return groupVisitCase(subExpr, groupDataSources, index)</span>
        case []sql_parser.SqlToken:<span class="cov0" title="0">
                var ret []interface{}
                for _, subExpr := range subExpr </span><span class="cov0" title="0">{
                        ret = append(ret, groupVisit(subExpr, groupDataSources, index))
                }</span>
                <span class="cov0" title="0">return ret</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

func groupVisitCase(sqlExpr *sql_parser.Case, groupDataSources types.GroupDataSources, index int) interface{} <span class="cov0" title="0">{
        for _, item := range sqlExpr.Values </span><span class="cov0" title="0">{
                condition := item.Condition
                if condition == nil || groupVisit(condition, groupDataSources, index).(bool) </span><span class="cov0" title="0">{
                        return groupVisit(item.Value, groupDataSources, index)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func groupVisitLink(sqlExpr *sql_parser.Link) interface{} <span class="cov0" title="0">{
        if ret, exist := env.LinkCache[sqlExpr.Id]; exist </span><span class="cov0" title="0">{
                return ret
        }</span>
        <span class="cov0" title="0">var ret []interface{}
        for _, resRecord := range env.Link[sqlExpr.Id] </span><span class="cov0" title="0">{
                var line []interface{}
                for key := range preFieldName </span><span class="cov0" title="0">{
                        v, _ := recordValue(resRecord, key)
                        line = append(line, v)
                }</span>
                <span class="cov0" title="0">if len(line) == 1 </span><span class="cov0" title="0">{
                        ret = append(ret, line[0])
                }</span> else<span class="cov0" title="0"> {
                        ret = append(ret, line)
                }</span>
        }
        <span class="cov0" title="0">env.LinkCache[sqlExpr.Id] = ret
        return ret</span>
}

func groupVisitFunc(sqlExpr *sql_parser.Func, groupDataSources types.GroupDataSources, index int) interface{} <span class="cov8" title="1">{
        function := getFunc(index, sqlExpr.Name)

        var funcArgs []interface{}
        for _, _funcArg := range sqlExpr.Args </span><span class="cov8" title="1">{
                funcArg := groupVisit(_funcArg, groupDataSources, index)
                if funcArg == "*" </span><span class="cov8" title="1">{
                        funcArgs = append(funcArgs, groupFuncStar(groupDataSources)...)
                }</span> else<span class="cov8" title="1"> {
                        funcArgs = append(funcArgs, funcArg)
                }</span>
        }
        <span class="cov8" title="1">return function(funcArgs...)</span>
}

func groupVisitConst(sqlExpr *sql_parser.Const) interface{} <span class="cov8" title="1">{
        return sqlExpr.Value
}</span>

// 支持 A.b.c.d 这类操作
func groupVisitVar(sqlExpr *sql_parser.Var, groupDataSources types.GroupDataSources, index int) interface{} <span class="cov8" title="1">{
        name := groupVisit(sqlExpr.Value, groupDataSources, index).(string)
        if rename, exist := env.ReTableName[name]; exist </span><span class="cov0" title="0">{
                name = rename
        }</span>
        <span class="cov8" title="1">next := sqlExpr.Next
        // 单表省略表名
        if next == nil </span><span class="cov8" title="1">{
                next = sqlExpr
                name = singleTableName
                sqlExpr = &amp;sql_parser.Var{
                        Value: &amp;sql_parser.Const{Value: singleTableName},
                        Next:  next,
                }
        }</span>
        <span class="cov8" title="1">_subName := groupVisit(next.Value, groupDataSources, index).(string)
        _subNext := next.Next
        var value functions.GroupRecord
        for _, instanceDicts := range groupDataSources </span><span class="cov8" title="1">{
                for _, instanceDict := range instanceDicts </span><span class="cov8" title="1">{
                        subName, subNext := _subName, _subNext
                        subValue, _ := recordValue(instanceDict[name], subName)
                        for subNext != nil </span><span class="cov8" title="1">{
                                subName = groupVisit(subNext.Value, groupDataSources, index).(string)
                                subValue, _ = recordValue(subValue, subName)
                                subNext = subNext.Next
                        }</span>
                        // 如果是group by的字段查询,查出第一个就可以了,因为group后的值是相等的
                        // 如果是函数之类的, 很可能计算数量或者其他, 那么需要取出全部
                        <span class="cov8" title="1">if varInGroupMap(sqlExpr) </span><span class="cov8" title="1">{
                                return subValue
                        }</span>
                        <span class="cov8" title="1">value = append(value, subValue)</span>
                }
                <span class="cov8" title="1">return value</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func groupVisitSelect(sqlExpr []sql_parser.SqlToken, groupDataSources types.GroupDataSources) interface{} <span class="cov8" title="1">{
        var resRecord interface{}
        if useStruct() </span><span class="cov8" title="1">{
                resRecord = newStruct(types.RecordStructName)
                hadSetStructFieldValue = make(types.UsedKey, 10)
                tmpFieldValue = make(map[string]interface{}, 10)
        }</span> else<span class="cov8" title="1"> {
                resRecord = make(map[string]interface{})
        }</span>

        <span class="cov8" title="1">if visit(sqlExpr[1], nil, -1) == true </span><span class="cov8" title="1">{
                return groupSelectStar(resRecord, groupDataSources)
        }</span>

        <span class="cov8" title="1">for i, subExpr := range sqlExpr[2:] </span><span class="cov8" title="1">{
                name := env.FieldName[i]
                val := groupVisit(subExpr, groupDataSources, i)
                switch value := val.(type) </span>{
                case functions.GroupRecord:<span class="cov8" title="1">
                        setValue(resRecord, name, value[len(value)-1], false)</span>
                default:<span class="cov8" title="1">
                        setValue(resRecord, name, value, false)</span>
                }
        }
        <span class="cov8" title="1">return resRecord</span>
}

// group 语句顶层接口, 做 group 聚合与 where 筛选, 给后续的 having 筛选创造新的数据源
func getGroupDataSources(dataSources types.DataSources) types.GroupDataSources <span class="cov8" title="1">{
        getGroupsList(expr.GroupExpr)
        groupDataSources := make(types.GroupDataSources, 10)
        if env.HasIndex </span><span class="cov8" title="1">{
                groupIndexLoop(dataSources, groupDataSources)
        }</span> else<span class="cov8" title="1"> {
                groupMainLoop(dataSources, make(types.InstanceDict, 10), groupDataSources)
        }</span>
        <span class="cov8" title="1">return groupDataSources</span>
}

// 主循环
func groupMainLoop(dataSources types.DataSources, instanceDict types.InstanceDict,
        groupDataSources types.GroupDataSources) <span class="cov8" title="1">{
        groupMainIterator(groupDataSources, make(types.UsedKey, 10), 0, len(dataSources), instanceDict, dataSources)
}</span>

// 主迭代器
func groupMainIterator(groupDataSources types.GroupDataSources, usedKey types.UsedKey, num int, dataLen int,
        instanceDict types.InstanceDict, dataSources types.DataSources) <span class="cov8" title="1">{
        if num == dataLen </span><span class="cov8" title="1">{
                copyInstanceDict := deepCopyInstanceDict(instanceDict, "", nil)
                groupWhereFilter(copyInstanceDict, groupDataSources)
        }</span> else<span class="cov8" title="1"> {
                // 取一张表
                for name, records := range dataSources </span><span class="cov8" title="1">{
                        if _, ok := usedKey[name]; !ok </span><span class="cov8" title="1">{
                                usedKey[name] = struct{}{}
                                for _, record := range records </span><span class="cov8" title="1">{
                                        instanceDict[name] = record
                                        groupMainIterator(groupDataSources, usedKey, num+1, dataLen, instanceDict, dataSources)
                                        delete(instanceDict, name)
                                }</span>
                                <span class="cov8" title="1">delete(usedKey, name)
                                return</span>
                        }
                }
        }
}

// 索引循环
func groupIndexLoop(dataSources types.DataSources, groupDataSources types.GroupDataSources) <span class="cov8" title="1">{
        var indexDict = make(types.IndexDict, 10)
        makeIndexDict(env.Index, dataSources, indexDict)
        name, indexRecords := popItem(indexDict)
        indexLen := len(indexDict)
        hasDataSources := !isEmptyMap(dataSources)
        for indexKey, records := range indexRecords </span><span class="cov8" title="1">{
                groupIndexIterator(hasDataSources, groupDataSources, indexKey, make(types.UsedKey, 10), indexDict,
                        dataSources, make(types.InstanceDict, 10), 0, indexLen, name, records)
        }</span>
}

// 索引迭代器
func groupIndexIterator(hasDataSources bool, groupDataSources types.GroupDataSources, indexKey types.IndexKey,
        usedKey types.UsedKey, indexDict types.IndexDict, dataSources types.DataSources, instanceDict types.InstanceDict,
        num int, indexNum int, tableName string, records types.Records) <span class="cov8" title="1">{
        if num == indexNum </span><span class="cov8" title="1">{
                for _, record := range records </span><span class="cov8" title="1">{
                        copyInstanceDict := deepCopyInstanceDict(instanceDict, tableName, record)
                        if hasDataSources </span><span class="cov0" title="0">{
                                groupMainLoop(dataSources, instanceDict, groupDataSources)
                        }</span> else<span class="cov8" title="1"> {
                                groupWhereFilter(copyInstanceDict, groupDataSources)
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                for name, indexRecords := range indexDict </span><span class="cov8" title="1">{
                        if _, ok := usedKey[name]; !ok </span><span class="cov8" title="1">{
                                usedKey[name] = struct{}{}
                                if records2, exist2 := indexRecords[indexKey]; exist2 </span><span class="cov8" title="1">{
                                        for _, record := range records2 </span><span class="cov8" title="1">{
                                                instanceDict[name] = record
                                                groupIndexIterator(hasDataSources, groupDataSources, indexKey, usedKey, indexDict,
                                                        dataSources, instanceDict, num+1, indexNum, tableName, records)
                                                delete(instanceDict, name)
                                        }</span>
                                }
                                <span class="cov8" title="1">delete(usedKey, name)
                                return</span>
                        }
                }
        }
}

// 筛选器
func groupWhereFilter(instanceDict types.InstanceDict, groupDataSources types.GroupDataSources) <span class="cov8" title="1">{
        if expr.WhereExpr == nil || visitFunc(expr.WhereExpr, instanceDict, -1) == true </span><span class="cov8" title="1">{
                pk := getRecordPk(instanceDict)
                if instanceDicts, exist := groupDataSources[pk]; exist </span><span class="cov8" title="1">{
                        groupDataSources[pk] = append(instanceDicts, instanceDict)
                }</span> else<span class="cov8" title="1"> {
                        groupDataSources[pk] = []types.InstanceDict{instanceDict}
                }</span>
        }
}

// 获取记录主键值
// 先序列化, 后转为字符串
func getRecordPk(instanceDict types.InstanceDict) string <span class="cov8" title="1">{
        pkSlice := make([]interface{}, 0, 10)
        for _, _groupKey := range env.GroupList </span><span class="cov8" title="1">{
                groupKey := _groupKey.([]string)
                name := groupKey[0]
                if rename, exist := env.ReTableName[name]; exist </span><span class="cov8" title="1">{
                        name = rename
                }</span>
                <span class="cov8" title="1">record, _ := instanceDict[name]
                for _, key := range groupKey[1:] </span><span class="cov8" title="1">{
                        record, _ = recordValue(record, key)
                }</span>
                <span class="cov8" title="1">pkSlice = append(pkSlice, record)</span>
        }
        <span class="cov8" title="1">pk, _ := json.Marshal(pkSlice)
        // 据说这样转字符串更快??
        return *(*string)(unsafe.Pointer(&amp;pk))</span>
}

func getGroupsList(varExpr []*sql_parser.Var) <span class="cov8" title="1">{
        groupList := make([]interface{}, 0, 10)
        for _, subExpr := range varExpr </span><span class="cov8" title="1">{
                groupKey := getVar(subExpr)
                // 单表可以省略表名
                if singleTableName != "" &amp;&amp; singleTableName != groupKey[0] </span><span class="cov8" title="1">{
                        _groupKey := make([]string, 0, len(groupKey)+1)
                        _groupKey = append(_groupKey, singleTableName)
                        groupKey = append(_groupKey, groupKey...)
                }</span>
                <span class="cov8" title="1">groupList = append(groupList, groupKey)
                setGroupMap(groupKey)</span>
        }
        <span class="cov8" title="1">env.GroupList = groupList</span>
}

func groupFuncStar(groupDataSources types.GroupDataSources) []interface{} <span class="cov8" title="1">{
        var argRes []interface{}
        for _, instanceDicts := range groupDataSources </span><span class="cov8" title="1">{
                length := len(instanceDicts)
                instanceDict := instanceDicts[0]
                for tableName, record := range instanceDict </span><span class="cov8" title="1">{
                        recordKeyValue(record, func(columnName string, v interface{}) </span><span class="cov8" title="1">{
                                row := []interface{}{v}
                                i := 0
                                for ; i+1 &lt; length; i++ </span><span class="cov8" title="1">{
                                        instanceDict2 := instanceDicts[i+1]
                                        v, _ := recordValue(instanceDict2[tableName], columnName)
                                        row = append(row, v)
                                }</span>
                                <span class="cov8" title="1">argRes = append(argRes, row)</span>
                        })
                }
                <span class="cov8" title="1">return argRes</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// 调整重名
func groupAdjustName(newName string, resRecord interface{}, hadAdjust types.UsedKey,
        keyName map[string]string, value interface{}, tableName string, oldName string) <span class="cov8" title="1">{
        if value2, ok := recordValue(resRecord, newName); ok </span><span class="cov8" title="1">{
                newName2 := keyName[newName] + "_" + newName
                setValue(resRecord, newName, nil, true)
                groupAdjustName(newName2, resRecord, hadAdjust, keyName, value2, keyName[newName], oldName)
        }</span>
        <span class="cov8" title="1">if lstInGroupMap([]string{tableName, oldName}) </span><span class="cov8" title="1">{
                setValue(resRecord, newName, value, false)
                hadAdjust[newName] = struct{}{}
        }</span> else<span class="cov8" title="1"> {
                setValue(resRecord, newName, nil, false)
                hadAdjust[newName] = struct{}{}
        }</span>
}

func groupSelectStar(resRecord interface{}, groupDataSources types.GroupDataSources) interface{} <span class="cov8" title="1">{
        hadAdjust := make(types.UsedKey, 10)
        keyName := make(map[string]string)
        hadName := make(types.UsedKey, 10)
        for _, instanceDicts := range groupDataSources </span><span class="cov8" title="1">{
                for _, instanceDict := range instanceDicts </span><span class="cov8" title="1">{
                        for tableName, record := range instanceDict </span><span class="cov8" title="1">{
                                recordKeyValue(record, func(key string, value interface{}) </span><span class="cov8" title="1">{
                                        if value2, ok := recordValue(resRecord, key); ok </span><span class="cov8" title="1">{
                                                newName := tableName + "_" + key
                                                groupAdjustName(newName, resRecord, hadAdjust, keyName, value, tableName, key)
                                                // 存在的key未被调整过的状态
                                                if _, ok := hadAdjust[key]; !ok </span><span class="cov8" title="1">{
                                                        newName2 := keyName[key] + "_" + key
                                                        // 先将存在的删除
                                                        setValue(resRecord, key, nil, true)
                                                        groupAdjustName(newName2, resRecord, hadAdjust, keyName, value2, keyName[key], key)
                                                }</span>
                                        } else<span class="cov8" title="1"> {
                                                // 存在key已经是已有字段, 需要调整
                                                if _, ok := hadName[key]; ok </span><span class="cov8" title="1">{
                                                        newName := tableName + "_" + key
                                                        groupAdjustName(newName, resRecord, hadAdjust, keyName, value, tableName, key)
                                                        // key不是已有字段, 并且key也没有存在的
                                                }</span> else<span class="cov8" title="1"> {
                                                        if lstInGroupMap([]string{tableName, key}) </span><span class="cov8" title="1">{
                                                                setValue(resRecord, key, value, false)
                                                                hadName[key] = struct{}{}
                                                                keyName[key] = tableName
                                                        }</span> else<span class="cov8" title="1"> {
                                                                setValue(resRecord, key, nil, false)
                                                                hadName[key] = struct{}{}
                                                                keyName[key] = tableName
                                                        }</span>
                                                }
                                        }
                                })
                        }
                        <span class="cov8" title="1">return resRecord</span>
                }
        }
        <span class="cov0" title="0">return resRecord</span>
}

func setGroupMap(groupKey []string) <span class="cov8" title="1">{
        key, _ := json.Marshal(groupKey)
        env.GroupMap[*(*string)(unsafe.Pointer(&amp;key))] = true
}</span>

func varInGroupMap(expr *sql_parser.Var) bool <span class="cov8" title="1">{
        key := make([]string, 0, 10)
        for expr != nil </span><span class="cov8" title="1">{
                key = append(key, visitConst(expr.Value).(string))
                expr = expr.Next
        }</span>
        <span class="cov8" title="1">pk, _ := json.Marshal(key)
        if env.GroupMap[*(*string)(unsafe.Pointer(&amp;pk))] </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

func lstInGroupMap(key []string) bool <span class="cov8" title="1">{
        pk, _ := json.Marshal(key)
        if env.GroupMap[*(*string)(unsafe.Pointer(&amp;pk))] </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package interpreters

import "github.com/Aiyane/golinq/types"

type Group struct{}

func (*Group) Interp(dataSources types.DataSources) <span class="cov8" title="1">{
        /*
                无 order 语句
        */
        // group by 聚合
        groupDataSources := getGroupDataSources(dataSources)

        // having 筛选
        for pk, instanceDicts := range groupDataSources </span><span class="cov8" title="1">{
                havingFilter(types.GroupDataSources{pk: instanceDicts})
        }</span>
}

func havingFilter(groupDataSources types.GroupDataSources) <span class="cov8" title="1">{
        if expr.HavingExpr == nil || groupVisit(expr.HavingExpr, groupDataSources, -1) == true </span><span class="cov8" title="1">{
                res = append(res, groupVisitSelect(expr.SelectExpr, groupDataSources))
        }</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package interpreters

import "github.com/Aiyane/golinq/types"

type GroupOrder struct{}

func (*GroupOrder) Interp(dataSources types.DataSources) <span class="cov8" title="1">{
        // 排序规则
        orders := getSelectOrders()

        // group by 聚合
        groupDataSources := getGroupDataSources(dataSources)

        // having 筛选
        for pk, instanceDicts := range groupDataSources </span><span class="cov8" title="1">{
                orderHavingFilter(types.GroupDataSources{pk: instanceDicts}, orders)
        }</span>

        // select 语句
        <span class="cov8" title="1">newRes := make([]interface{}, 0, 10)
        for _, subRes := range res </span><span class="cov8" title="1">{
                newRes = append(newRes, groupVisitSelect(expr.SelectExpr, subRes.(types.GroupDataSources)))
        }</span>
        <span class="cov8" title="1">res = newRes</span>
}

func orderHavingFilter(groupDataSources types.GroupDataSources, orders []*types.OrderFields) <span class="cov8" title="1">{
        if expr.HavingExpr == nil || groupVisit(expr.HavingExpr, groupDataSources, -1) == true </span><span class="cov8" title="1">{
                index := groupBisectLeft(res, groupDataSources, orders)
                // 插入 index 位置
                if index == len(res) </span><span class="cov8" title="1">{
                        res = append(res, groupDataSources)
                }</span> else<span class="cov8" title="1"> {
                        res = append(res[:index+1], res[index:]...)
                        res[index] = groupDataSources
                }</span>
        }
}

func groupBisectLeft(a []interface{}, x types.GroupDataSources, orders []*types.OrderFields) int <span class="cov8" title="1">{
        hi := len(a)
        lo := 0
        for lo &lt; hi </span><span class="cov8" title="1">{
                mid := (lo + hi) / 2
                if groupCompareRecord(a[mid].(types.GroupDataSources), x, orders) </span><span class="cov8" title="1">{
                        lo = mid + 1
                }</span> else<span class="cov8" title="1"> {
                        hi = mid
                }</span>
        }
        <span class="cov8" title="1">return lo</span>
}

func groupCompareRecord(item1 types.GroupDataSources, item2 types.GroupDataSources, orders []*types.OrderFields) bool <span class="cov8" title="1">{
        for _, condition := range orders </span><span class="cov8" title="1">{
                order := condition.Order
                for _, instanceDicts := range item1 </span><span class="cov8" title="1">{
                        for _, instanceDicts2 := range item2 </span><span class="cov8" title="1">{
                                var v1, v2 interface{}
                                for i, key := range condition.Fields </span><span class="cov8" title="1">{
                                        if i == 0 </span><span class="cov8" title="1">{
                                                v1 = instanceDicts[0][key]
                                                v2 = instanceDicts2[0][key]
                                                // 单一表省略了表名
                                                if v1 == nil &amp;&amp; v2 == nil </span><span class="cov8" title="1">{
                                                        v1 = instanceDicts[0][singleTableName].(types.Record)
                                                        v2 = instanceDicts2[0][singleTableName].(types.Record)
                                                        v1, _ = recordValue(v1, key)
                                                        v2, _ = recordValue(v2, key)
                                                }</span>
                                        } else<span class="cov8" title="1"> {
                                                v1, _ = recordValue(v1, key)
                                                v2, _ = recordValue(v2, key)
                                        }</span>
                                }
                                <span class="cov8" title="1">compareRes := compareValue(v1, v2)
                                if compareRes &lt; 0 </span><span class="cov8" title="1">{
                                        if order == types.PositiveOrder </span><span class="cov8" title="1">{
                                                return true
                                        }</span>
                                        <span class="cov8" title="1">return false</span>
                                } else<span class="cov8" title="1"> if compareRes &gt; 0 </span><span class="cov8" title="1">{
                                        if order == types.PositiveOrder </span><span class="cov8" title="1">{
                                                return false
                                        }</span>
                                        <span class="cov8" title="1">return true</span>
                                }
                                <span class="cov0" title="0">break</span>
                        }
                        <span class="cov0" title="0">break</span>
                }
        }
        <span class="cov0" title="0">return true</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package interpreters

import (
        "github.com/Aiyane/golinq/sql-parser"
        "github.com/Aiyane/golinq/types"
)

var (
        SimpleInterp     types.SimpleInterp
        OrderInterp      types.OrderInterp
        GroupInterp      types.GroupInterp
        GroupOrderInterp types.GroupOrderInterp
)

func SqlInterpreter(tree *sql_parser.State, dataSources types.DataSources, newEnv *types.Env) []interface{} <span class="cov8" title="1">{
        // 初始化环境
        env = newEnv
        // 初始化结果集
        res = make([]interface{}, 0, 100)
        // 初始化表达式
        expr = sql_parser.NewExpr(tree)
        selectSqlInterpreterExec(dataSources)
        // 清理环境
        clearEnv()
        return res
}</span>

func selectSqlInterpreterExec(dataSources types.DataSources) <span class="cov8" title="1">{
        // 如果有 from 执行 from 筛选
        if expr.FromExpr != nil </span><span class="cov8" title="1">{
                dataSources = visitTables(expr.FromExpr, dataSources)
                if len(dataSources) &gt; 1 </span><span class="cov8" title="1">{
                        singleTableName = "" // 非单一表删除表名
                }</span>
        }
        // 通过 select 语句先确定有哪些聚合函数，每一列的都需要新生成一个函数
        <span class="cov8" title="1">pretreatment(expr.SelectExpr)
        // 选择解释器
        if expr.GroupExpr != nil </span><span class="cov8" title="1">{
                if expr.OrderExpr != nil </span><span class="cov8" title="1">{
                        GroupOrderInterp.Interp(dataSources)
                }</span> else<span class="cov8" title="1"> {
                        GroupInterp.Interp(dataSources)
                }</span>
        } else<span class="cov8" title="1"> if expr.OrderExpr != nil </span><span class="cov8" title="1">{
                OrderInterp.Interp(dataSources)
        }</span> else<span class="cov8" title="1"> {
                SimpleInterp.Interp(dataSources)
        }</span>
        // 如果有聚合函数
        <span class="cov8" title="1">if env.HasAgg </span><span class="cov8" title="1">{
                if length := len(res); length &gt; 0 </span><span class="cov8" title="1">{
                        res = []interface{}{res[length-1]}
                }</span> else<span class="cov8" title="1"> {
                        res = []interface{}{}
                }</span>
        }
        // 如果有 limit 语句
        <span class="cov8" title="1">if expr.LimitExpr != nil </span><span class="cov8" title="1">{
                visitLimit(expr.LimitExpr)
        }</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package interpreters

import (
        "github.com/Aiyane/golinq/sql-parser"
        "github.com/Aiyane/golinq/types"
        "github.com/sirupsen/logrus"
)

type Order struct{}

func (*Order) Interp(dataSources types.DataSources) <span class="cov8" title="1">{
        /*
                无 group 有 Order 语句
        */
        // 排序规则
        orders := getSelectOrders()

        // 如果使用 join on 索引优化
        if env.HasIndex </span><span class="cov8" title="1">{
                orderIndexLoop(dataSources, orders)
        }</span> else<span class="cov8" title="1"> {
                orderMainLoop(dataSources, make(types.InstanceDict, 10), orders)
        }</span>

        // select 语句, 因为是有序插入, 需要做比较, 所以不能提前 select, 如果提前 select 会导致之前的记录没有做比较的字段
        <span class="cov8" title="1">newRes := make([]interface{}, 0, 100)
        for _, instanceDict := range res </span><span class="cov8" title="1">{
                newRes = append(newRes, visitSelect(expr.SelectExpr, instanceDict.(types.InstanceDict)))
        }</span>
        <span class="cov8" title="1">res = newRes</span>
}

// 主循环
func orderMainLoop(dataSources types.DataSources, instanceDict types.InstanceDict, orders []*types.OrderFields) <span class="cov8" title="1">{
        orderMainIterator(make(types.UsedKey, 10), 0, len(dataSources), instanceDict, dataSources, orders)
}</span>

// 主迭代器
func orderMainIterator(usedKey types.UsedKey, num int, dataNum int, instanceDict types.InstanceDict, dataSources types.DataSources,
        orders []*types.OrderFields) <span class="cov8" title="1">{
        if num == dataNum </span><span class="cov8" title="1">{
                copyInstanceDict := deepCopyInstanceDict(instanceDict, "", nil)
                orderWhereFilter(copyInstanceDict, orders)
        }</span> else<span class="cov8" title="1"> {
                // 取一个表
                for name, records := range dataSources </span><span class="cov8" title="1">{
                        if _, ok := usedKey[name]; !ok </span><span class="cov8" title="1">{
                                usedKey[name] = struct{}{}
                                for _, record := range records </span><span class="cov8" title="1">{
                                        instanceDict[name] = record
                                        orderMainIterator(usedKey, num+1, dataNum, instanceDict, dataSources, orders)
                                        delete(instanceDict, name)
                                }</span>
                                <span class="cov8" title="1">delete(usedKey, name)
                                return</span>
                        }
                }
        }
}

// 索引主循环
func orderIndexLoop(dataSources types.DataSources, orders []*types.OrderFields) <span class="cov8" title="1">{
        var indexDict = make(types.IndexDict, 10)
        makeIndexDict(env.Index, dataSources, indexDict)
        name, indexRecords := popItem(indexDict)
        indexLen := len(indexDict)
        hasDataSources := len(dataSources) &gt; 0
        for indexKey, records := range indexRecords </span><span class="cov8" title="1">{
                orderIndexIterator(hasDataSources, indexKey, make(types.UsedKey, 10), indexDict,
                        dataSources, make(types.InstanceDict, 10), 0, indexLen, name, records, orders)
        }</span>
}

// 索引迭代器
func orderIndexIterator(hasDataSources bool, indexKey interface{}, usedKey types.UsedKey, indexDict types.IndexDict,
        dataSources types.DataSources, instanceDict types.InstanceDict, num int, indexLen int, tableName string, records types.Records,
        orders []*types.OrderFields) <span class="cov8" title="1">{
        if num == indexLen </span><span class="cov8" title="1">{
                for _, record := range records </span><span class="cov8" title="1">{
                        copyInstanceDict := deepCopyInstanceDict(instanceDict, tableName, record)
                        if hasDataSources </span><span class="cov8" title="1">{
                                orderMainLoop(dataSources, copyInstanceDict, orders)
                        }</span> else<span class="cov8" title="1"> {
                                orderWhereFilter(copyInstanceDict, orders)
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                for name, indexRecords := range indexDict </span><span class="cov8" title="1">{
                        if _, ok := usedKey[name]; !ok </span><span class="cov8" title="1">{
                                usedKey[name] = struct{}{}
                                if records2, exist2 := indexRecords[indexKey]; exist2 </span><span class="cov8" title="1">{
                                        for _, record := range records2 </span><span class="cov8" title="1">{
                                                instanceDict[name] = record
                                                orderIndexIterator(hasDataSources, indexKey, usedKey, indexDict, dataSources,
                                                        instanceDict, num+1, indexLen, tableName, records, orders)
                                                delete(instanceDict, name)
                                        }</span>
                                }
                                <span class="cov8" title="1">delete(usedKey, name)
                                return</span>
                        }
                }
        }
}

// 筛选器
func orderWhereFilter(instanceDict types.InstanceDict, orders []*types.OrderFields) <span class="cov8" title="1">{
        if expr.WhereExpr == nil || visitFunc(expr.WhereExpr, instanceDict, -1) == true </span><span class="cov8" title="1">{
                index := bisectLeft(res, instanceDict, orders)
                // 插入 index 位置
                if index == len(res) </span><span class="cov8" title="1">{
                        res = append(res, instanceDict)
                }</span> else<span class="cov8" title="1"> {
                        res = append(res[:index+1], res[index:]...)
                        res[index] = instanceDict
                }</span>
        }
}

func getSelectOrders() []*types.OrderFields <span class="cov8" title="1">{
        orders := make([]*types.OrderFields, 0, 10)
        for _, subExpr := range expr.OrderExpr </span><span class="cov8" title="1">{
                orders = append(orders, getOrderList(subExpr))
        }</span>
        <span class="cov8" title="1">return orders</span>
}

func getOrderList(sqlExpr interface{}) *types.OrderFields <span class="cov8" title="1">{
        var orderFields *types.OrderFields
        switch subExpr := sqlExpr.(type) </span>{
        case *sql_parser.Var:<span class="cov8" title="1">
                orderFields = &amp;types.OrderFields{
                        Order:  types.PositiveOrder,
                        Fields: getVar(subExpr),
                }</span>
        case *sql_parser.Desc:<span class="cov8" title="1">
                orderFields = &amp;types.OrderFields{
                        Order:  types.ReverseOrder,
                        Fields: getVar(subExpr.Value),
                }</span>
        default:<span class="cov0" title="0">
                logrus.Errorf("[getOrderList] type error: sqlExpr[%T]:[%v]", sqlExpr, sqlExpr)
                panic("")</span>
        }
        <span class="cov8" title="1">return orderFields</span>
}

func getVar(sqlExpr *sql_parser.Var) []string <span class="cov8" title="1">{
        res := make([]string, 0, 10)
        for sqlExpr != nil </span><span class="cov8" title="1">{
                res = append(res, visitConst(sqlExpr.Value).(string))
                sqlExpr = sqlExpr.Next
        }</span>
        <span class="cov8" title="1">return res</span>
}

// 获取插入位置
func bisectLeft(a []interface{}, x types.InstanceDict, orders []*types.OrderFields) int <span class="cov8" title="1">{
        hi := len(a)
        lo := 0
        for lo &lt; hi </span><span class="cov8" title="1">{
                mid := (lo + hi) / 2
                if compareRecord(a[mid].(types.InstanceDict), x, orders) </span><span class="cov8" title="1">{
                        lo = mid + 1
                }</span> else<span class="cov8" title="1"> {
                        hi = mid
                }</span>
        }
        <span class="cov8" title="1">return lo</span>
}

// 记录比较函数
func compareRecord(item1 types.InstanceDict, item2 types.InstanceDict, orders []*types.OrderFields) bool <span class="cov8" title="1">{
        for _, condition := range orders </span><span class="cov8" title="1">{
                order := condition.Order
                var v1, v2 interface{}
                for i, key := range condition.Fields </span><span class="cov8" title="1">{
                        if i == 0 </span><span class="cov8" title="1">{
                                v1 = item1[key]
                                v2 = item2[key]
                                // 单一表省略了表名
                                if v1 == nil &amp;&amp; v2 == nil </span><span class="cov8" title="1">{
                                        v1 = item1[singleTableName].(types.Record)
                                        v2 = item2[singleTableName].(types.Record)
                                        v1, _ = recordValue(v1, key)
                                        v2, _ = recordValue(v2, key)
                                }</span>
                        } else<span class="cov8" title="1"> {
                                v1, _ = recordValue(v1, key)
                                v2, _ = recordValue(v2, key)
                        }</span>
                }
                <span class="cov8" title="1">compareRes := compareValue(v1, v2)
                if compareRes &lt; 0 </span><span class="cov8" title="1">{
                        if order == types.PositiveOrder </span><span class="cov8" title="1">{
                                return true
                        }</span>
                        <span class="cov8" title="1">return false</span>
                } else<span class="cov8" title="1"> if compareRes &gt; 0 </span><span class="cov8" title="1">{
                        if order == types.PositiveOrder </span><span class="cov8" title="1">{
                                return false
                        }</span>
                        <span class="cov8" title="1">return true</span>
                }
        }
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package interpreters

import "github.com/Aiyane/golinq/types"

type Simple struct{}

// 解释顶层接口
func (*Simple) Interp(dataSources types.DataSources) <span class="cov8" title="1">{
        /*
                无 group 与 order 语句
        */
        // 如果使用 join on 索引优化
        if env.HasIndex </span><span class="cov8" title="1">{
                simpleIndexLoop(dataSources)
        }</span> else<span class="cov8" title="1"> {
                simpleMainLoop(dataSources, make(types.InstanceDict, 10))
        }</span>
}

// 主循环
func simpleMainLoop(dataSources types.DataSources, instanceDict types.InstanceDict) <span class="cov8" title="1">{
        simpleMainIterator(make(types.UsedKey, 10), 0, len(dataSources), instanceDict, dataSources)
}</span>

// 主迭代器
func simpleMainIterator(usedKey types.UsedKey, num int, dataLen int, instanceDict types.InstanceDict,
        dataSources types.DataSources) <span class="cov8" title="1">{
        if num == dataLen </span><span class="cov8" title="1">{
                copyInstanceDict := deepCopyInstanceDict(instanceDict, "", nil)
                simpleWhereFilter(copyInstanceDict)
        }</span> else<span class="cov8" title="1"> {
                // 取一个表
                for name, records := range dataSources </span><span class="cov8" title="1">{
                        if _, ok := usedKey[name]; !ok </span><span class="cov8" title="1">{
                                usedKey[name] = struct{}{}
                                for _, record := range records </span><span class="cov8" title="1">{
                                        instanceDict[name] = record
                                        simpleMainIterator(usedKey, num+1, dataLen, instanceDict, dataSources)
                                        delete(instanceDict, name)
                                }</span>
                                <span class="cov8" title="1">delete(usedKey, name)
                                return</span>
                        }
                }
        }
}

// 索引主循环
func simpleIndexLoop(dataSources types.DataSources) <span class="cov8" title="1">{
        var indexDict = make(types.IndexDict)
        makeIndexDict(env.Index, dataSources, indexDict)
        name, indexRecords := popItem(indexDict)
        indexLen := len(indexDict)
        hasDataSources := len(dataSources) &gt; 0
        for indexKey, records := range indexRecords </span><span class="cov8" title="1">{
                simpleIndexIterator(hasDataSources, indexKey, make(types.UsedKey, 10), indexDict,
                        dataSources, make(types.InstanceDict, 10), 0, indexLen, name, records)
        }</span>
}

// 索引迭代器
func simpleIndexIterator(hasDataSources bool, indexKey interface{}, usedKeys types.UsedKey, indexDict types.IndexDict,
        dataSources types.DataSources, instanceDict types.InstanceDict, num int, indexLen int, tableName string, records types.Records) <span class="cov8" title="1">{
        if num == indexLen </span><span class="cov8" title="1">{
                for _, record := range records </span><span class="cov8" title="1">{
                        copyInstanceDict := deepCopyInstanceDict(instanceDict, tableName, record)
                        if hasDataSources </span><span class="cov8" title="1">{
                                simpleMainLoop(dataSources, copyInstanceDict)
                        }</span> else<span class="cov8" title="1"> {
                                simpleWhereFilter(copyInstanceDict)
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                for name, indexRecords := range indexDict </span><span class="cov8" title="1">{
                        if _, ok := usedKeys[name]; !ok </span><span class="cov8" title="1">{
                                usedKeys[name] = struct{}{}
                                if records2, exist2 := indexRecords[indexKey]; exist2 </span><span class="cov8" title="1">{
                                        for _, record := range records2 </span><span class="cov8" title="1">{
                                                instanceDict[name] = record
                                                simpleIndexIterator(hasDataSources, indexKey, usedKeys, indexDict, dataSources,
                                                        instanceDict, num+1, indexLen, tableName, records)
                                                delete(instanceDict, name)
                                        }</span>
                                }
                                <span class="cov8" title="1">delete(usedKeys, name)
                                return</span>
                        }
                }
        }
}

// 筛选器
func simpleWhereFilter(instanceDict types.InstanceDict) <span class="cov8" title="1">{
        if expr.WhereExpr == nil || visitFunc(expr.WhereExpr, instanceDict, -1) == true </span><span class="cov8" title="1">{
                res = append(res, visitSelect(expr.SelectExpr, instanceDict))
        }</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package interpreters

import (
        sql_parser "github.com/Aiyane/golinq/sql-parser"
        "github.com/Aiyane/golinq/types"
)

var (
        SimpleUpdateInterp types.SimpleUpdateInterp
        OrderUpdateInterp  types.OrderUpdateInterp
)

func UpdateInterp(updateExpr *sql_parser.UpdateExpr, dataSources types.DataSources) int <span class="cov8" title="1">{
        env = NewEnv()
        var n int
        table, records := updateTable(updateExpr.Table, dataSources)
        singleTableName = table // 单一表名
        if orderExpr := updateExpr.Order; orderExpr != nil </span><span class="cov8" title="1">{
                records, n = OrderUpdateInterp.Interp(updateExpr, table, records)
        }</span> else<span class="cov8" title="1"> {
                records, n = SimpleUpdateInterp.Interp(updateExpr, table, records)
        }</span>
        <span class="cov8" title="1">dataSources[table] = records
        return n</span>
}

type SimpleUpdate struct{}

func (*SimpleUpdate) Interp(updateExpr *sql_parser.UpdateExpr, table string, records types.Records) (types.Records, int) <span class="cov8" title="1">{
        whereExpr := updateExpr.Where
        total := len(records)
        ret := make(types.Records, 0, total)
        var limit, offset = -1, -1
        if limitExpr := updateExpr.Limit; limitExpr != nil </span><span class="cov0" title="0">{
                offset = visitConst(limitExpr.Offset).(int)
                limit = visitConst(limitExpr.Limit).(int)
        }</span>
        <span class="cov8" title="1">noLimit := limit == -1
        updateCount := 0
        var ok bool
        values := updateExpr.Values
        for _, record := range records </span><span class="cov8" title="1">{
                instanceDict := types.InstanceDict{table: record}
                if whereExpr == nil || visitFunc(whereExpr, instanceDict, -1) == true </span><span class="cov8" title="1">{
                        if ok, limit, offset = canUpdate(noLimit, limit, offset); ok </span><span class="cov8" title="1">{
                                for _, columnValue := range values </span><span class="cov8" title="1">{
                                        names := getVar(columnValue.Column)
                                        name := names[len(names)-1]
                                        value := visit(columnValue.Value, instanceDict, -1)
                                        setValue(record, name, value, false)
                                }</span>
                                <span class="cov8" title="1">updateCount += 1</span>
                        }
                }
                <span class="cov8" title="1">ret = append(ret, record)</span>
        }
        <span class="cov8" title="1">return ret, updateCount</span>
}

func canUpdate(noLimit bool, hadLimit int, hadOffset int) (bool, int, int) <span class="cov8" title="1">{
        if noLimit </span><span class="cov8" title="1">{
                return true, 0, 0
        }</span>
        <span class="cov0" title="0">if hadLimit == 0 &amp;&amp; hadOffset &gt; 0 </span><span class="cov0" title="0">{
                return true, hadLimit, hadOffset - 1
        }</span>
        <span class="cov0" title="0">return false, hadLimit, hadOffset</span>
}

func updateTable(tableExpr sql_parser.SqlToken, dataSources types.DataSources) (string, types.Records) <span class="cov8" title="1">{
        var key string
        records := visit(tableExpr, dataSources, -1)
        switch subExpr := tableExpr.(type) </span>{
        case *sql_parser.Var:<span class="cov8" title="1">
                key = subExpr.Value.Value.(string)</span>
        case *sql_parser.As:<span class="cov0" title="0">
                records = visit(subExpr.Value, dataSources, -1)
                rename := subExpr.NewName.Value.(string)
                env.ReTableName[subExpr.Value.(*sql_parser.Var).Value.Value.(string)] = rename</span>
        }
        <span class="cov8" title="1">return key, records.(types.Records)</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package interpreters

import (
        sql_parser "github.com/Aiyane/golinq/sql-parser"
        "github.com/Aiyane/golinq/types"
)

type OrderUpdate struct{}

func (*OrderUpdate) Interp(updateExpr *sql_parser.UpdateExpr, table string, records types.Records) (types.Records, int) <span class="cov8" title="1">{
        whereExpr := updateExpr.Where
        res = make([]interface{}, 0, 100)
        total := len(records)
        orders := getOrders(updateExpr.Order)
        needUpdateIndex := make([]int, 0, total)
        updateCount := 0
        for i, record := range records </span><span class="cov8" title="1">{
                instanceDict := types.InstanceDict{table: record}
                if whereExpr == nil || visitFunc(whereExpr, instanceDict, -1) == true </span><span class="cov8" title="1">{
                        index := bisectLeft(res, instanceDict, orders)
                        // 插入 index 位置
                        if index == len(res) </span><span class="cov8" title="1">{
                                res = append(res, instanceDict)
                                needUpdateIndex = append(needUpdateIndex, i)
                        }</span> else<span class="cov0" title="0"> {
                                res = append(res[:index+1], res[index:]...)
                                res[index] = instanceDict
                                needUpdateIndex = append(needUpdateIndex[:index+1], needUpdateIndex[index:]...)
                                needUpdateIndex[index] = i
                        }</span>
                }
        }
        <span class="cov8" title="1">if limitExpr := updateExpr.Limit; limitExpr != nil </span><span class="cov8" title="1">{
                needUpdateIndex = deleteOrUpdateLimit(limitExpr, needUpdateIndex)
        }</span>
        <span class="cov8" title="1">values := updateExpr.Values
        for _, index := range needUpdateIndex </span><span class="cov8" title="1">{
                record := records[index]
                instanceDict := types.InstanceDict{table: record}
                for _, columnValue := range values </span><span class="cov8" title="1">{
                        names := getVar(columnValue.Column)
                        name := names[len(names)-1]
                        value := visit(columnValue.Value, instanceDict, -1)
                        setValue(record, name, value, false)
                }</span>
                <span class="cov8" title="1">records[index] = record
                updateCount += 1</span>
        }
        <span class="cov8" title="1">return records, updateCount</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package interpreters

import (
        "github.com/Aiyane/golinq/functions"
        "github.com/Aiyane/golinq/types"
        "strings"
)

// 判断字典是否为空
func isEmptyMap(map_ types.DataSources) bool <span class="cov8" title="1">{
        for range map_ </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

/*
值比较函数, 没有泛型！！！！！
item1 &gt; item2 返回 1
item2 &lt; item2 返回 -1
item1 == item2 返回 0
*/
func compareValue(item interface{}, item2 interface{}) int <span class="cov8" title="1">{
        switch item1 := item.(type) </span>{
        case string:<span class="cov8" title="1">
                return strings.Compare(item1, item2.(string))</span>
        case []interface{}:<span class="cov8" title="1">
                for i, v1 := range item1 </span><span class="cov8" title="1">{
                        temRes := compareValue(v1, item2.([]interface{})[i])
                        if temRes == 1 </span><span class="cov0" title="0">{
                                return 1
                        }</span> else<span class="cov8" title="1"> if temRes == -1 </span><span class="cov8" title="1">{
                                return -1
                        }</span>
                }
                <span class="cov0" title="0">return 0</span>
        case []string:<span class="cov8" title="1">
                for i, v1 := range item1 </span><span class="cov8" title="1">{
                        temRes := compareValue(v1, item2.([]string)[i])
                        if temRes == 1 </span><span class="cov0" title="0">{
                                return 1
                        }</span> else<span class="cov8" title="1"> if temRes == -1 </span><span class="cov8" title="1">{
                                return -1
                        }</span>
                }
                <span class="cov0" title="0">return 0</span>
        case []int:<span class="cov0" title="0">
                for i, v1 := range item1 </span><span class="cov0" title="0">{
                        temRes := compareValue(v1, item2.([]int)[i])
                        if temRes == 1 </span><span class="cov0" title="0">{
                                return 1
                        }</span> else<span class="cov0" title="0"> if temRes == -1 </span><span class="cov0" title="0">{
                                return -1
                        }</span>
                }
                <span class="cov0" title="0">return 0</span>
        case []int8:<span class="cov0" title="0">
                for i, v1 := range item1 </span><span class="cov0" title="0">{
                        temRes := compareValue(v1, item2.([]int8)[i])
                        if temRes == 1 </span><span class="cov0" title="0">{
                                return 1
                        }</span> else<span class="cov0" title="0"> if temRes == -1 </span><span class="cov0" title="0">{
                                return -1
                        }</span>
                }
                <span class="cov0" title="0">return 0</span>
        case []int16:<span class="cov0" title="0">
                for i, v1 := range item1 </span><span class="cov0" title="0">{
                        temRes := compareValue(v1, item2.([]int16)[i])
                        if temRes == 1 </span><span class="cov0" title="0">{
                                return 1
                        }</span> else<span class="cov0" title="0"> if temRes == -1 </span><span class="cov0" title="0">{
                                return -1
                        }</span>
                }
                <span class="cov0" title="0">return 0</span>
        case []int32:<span class="cov0" title="0">
                for i, v1 := range item1 </span><span class="cov0" title="0">{
                        temRes := compareValue(v1, item2.([]int32)[i])
                        if temRes == 1 </span><span class="cov0" title="0">{
                                return 1
                        }</span> else<span class="cov0" title="0"> if temRes == -1 </span><span class="cov0" title="0">{
                                return -1
                        }</span>
                }
                <span class="cov0" title="0">return 0</span>
        case []int64:<span class="cov0" title="0">
                for i, v1 := range item1 </span><span class="cov0" title="0">{
                        temRes := compareValue(v1, item2.([]int64)[i])
                        if temRes == 1 </span><span class="cov0" title="0">{
                                return 1
                        }</span> else<span class="cov0" title="0"> if temRes == -1 </span><span class="cov0" title="0">{
                                return -1
                        }</span>
                }
                <span class="cov0" title="0">return 0</span>
        case []float32:<span class="cov0" title="0">
                for i, v1 := range item1 </span><span class="cov0" title="0">{
                        temRes := compareValue(v1, item2.([]float32)[i])
                        if temRes == 1 </span><span class="cov0" title="0">{
                                return 1
                        }</span> else<span class="cov0" title="0"> if temRes == -1 </span><span class="cov0" title="0">{
                                return -1
                        }</span>
                }
                <span class="cov0" title="0">return 0</span>
        case []float64:<span class="cov0" title="0">
                for i, v1 := range item1 </span><span class="cov0" title="0">{
                        temRes := compareValue(v1, item2.([]float64)[i])
                        if temRes == 1 </span><span class="cov0" title="0">{
                                return 1
                        }</span> else<span class="cov0" title="0"> if temRes == -1 </span><span class="cov0" title="0">{
                                return -1
                        }</span>
                }
                <span class="cov0" title="0">return 0</span>
        case []uint8:<span class="cov0" title="0">
                for i, v1 := range item1 </span><span class="cov0" title="0">{
                        temRes := compareValue(v1, item2.([]uint8)[i])
                        if temRes == 1 </span><span class="cov0" title="0">{
                                return 1
                        }</span> else<span class="cov0" title="0"> if temRes == -1 </span><span class="cov0" title="0">{
                                return -1
                        }</span>
                }
                <span class="cov0" title="0">return 0</span>
        case []uint16:<span class="cov0" title="0">
                for i, v1 := range item1 </span><span class="cov0" title="0">{
                        temRes := compareValue(v1, item2.([]uint16)[i])
                        if temRes == 1 </span><span class="cov0" title="0">{
                                return 1
                        }</span> else<span class="cov0" title="0"> if temRes == -1 </span><span class="cov0" title="0">{
                                return -1
                        }</span>
                }
                <span class="cov0" title="0">return 0</span>
        case []uint32:<span class="cov0" title="0">
                for i, v1 := range item1 </span><span class="cov0" title="0">{
                        temRes := compareValue(v1, item2.([]uint32)[i])
                        if temRes == 1 </span><span class="cov0" title="0">{
                                return 1
                        }</span> else<span class="cov0" title="0"> if temRes == -1 </span><span class="cov0" title="0">{
                                return -1
                        }</span>
                }
                <span class="cov0" title="0">return 0</span>
        case []uint64:<span class="cov0" title="0">
                for i, v1 := range item1 </span><span class="cov0" title="0">{
                        temRes := compareValue(v1, item2.([]uint64)[i])
                        if temRes == 1 </span><span class="cov0" title="0">{
                                return 1
                        }</span> else<span class="cov0" title="0"> if temRes == -1 </span><span class="cov0" title="0">{
                                return -1
                        }</span>
                }
                <span class="cov0" title="0">return 0</span>
        case []uint:<span class="cov0" title="0">
                for i, v1 := range item1 </span><span class="cov0" title="0">{
                        temRes := compareValue(v1, item2.([]uint)[i])
                        if temRes == 1 </span><span class="cov0" title="0">{
                                return 1
                        }</span> else<span class="cov0" title="0"> if temRes == -1 </span><span class="cov0" title="0">{
                                return -1
                        }</span>
                }
                <span class="cov0" title="0">return 0</span>
        default:<span class="cov8" title="1">
                if functions.Greater(item1, item2) </span><span class="cov8" title="1">{
                        return 1
                }</span> else<span class="cov8" title="1"> if functions.Less(item1, item2) </span><span class="cov8" title="1">{
                        return -1
                }</span>
                <span class="cov8" title="1">return 0</span>
        }
}

/*
弹出 indexDict 中的一个元素
例如:
indexDict = {
"b": {
  1: [
        {"b": {"a_id": 1, "other": "ha"}},
        {"b": {"a_id": 1, "other": "hh"}},
  ],
 },
"c": {
   2: [
         {"c": {"a_id": 2, "field": "yo"}},
                {"c": {"a_id": 2, "field": "ya"}},
   ]
  },
}
返回:
"b": {
 1: [
   {"b": {"a_id": 1, "other": "ha"}},
   {"b": {"a_id": 1, "other": "hh"}},
 ],
},
并且
indexDict = {
"c": {
   2: [
         {"c": {"a_id": 2, "field": "yo"}},
                {"c": {"a_id": 2, "field": "ya"}},
   ]
  },
}
*/
func popItem(indexDict types.IndexDict) (string, types.IndexRecords) <span class="cov8" title="1">{
        for key, value := range indexDict </span><span class="cov8" title="1">{
                delete(indexDict, key)
                return key, value
        }</span>
        <span class="cov0" title="0">return "", nil</span>
}

// 深拷贝一条记录
// 例如:
// instanceDict = {
//         "a": {"a_id": 1, "name": "hi"},
//         "b": {"b_id": 1, "other": "ha"}
// }
// tableName = "c"
// frontInstance = {
//         "c_id": 1, "recordValue": "yo"
// }
// 返回 {
//  "a": {"a_id": 1, "name": "hi"},
//         "b": {"b_id": 1, "other": "ha"},
//         "c": {"c_id": 1, "recordValue": "yo"}
// }
func deepCopyInstanceDict(instanceDict types.InstanceDict, tableName string, record types.Record) types.InstanceDict <span class="cov8" title="1">{
        copyInstanceDict := make(types.InstanceDict, 10)
        for key, record := range instanceDict </span><span class="cov8" title="1">{
                copyInstanceDict[key] = record
        }</span>
        <span class="cov8" title="1">if tableName != "" </span><span class="cov8" title="1">{
                copyInstanceDict[tableName] = record
        }</span>
        <span class="cov8" title="1">return copyInstanceDict</span>
}

func useStruct() bool <span class="cov8" title="1">{
        return types.RecordStructName != ""
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package golinq

import (
        "database/sql"
        "database/sql/driver"
        "sync"
)

const (
        // DriverName is the name of the fake driver
        DriverName = "MOCK_FAKE_DRIVER"
)

// Catcher is global instance of Catcher used for attaching all mocks to connection
var Catcher *MockCatcher

// MockCatcher is global entity to save all mocks aka FakeResponses
type MockCatcher struct {
        Mocks                []*FakeResponse // Slice of all mocks
        Logging              bool            // Do we need to log what we catching?
        PanicOnEmptyResponse bool            // If not response matches - do we need to panic?
        mu                   sync.Mutex
}

func (mc *MockCatcher) SetLogging(l bool) <span class="cov0" title="0">{
        mc.mu.Lock()
        defer mc.mu.Unlock()
        mc.Logging = l
}</span>

// Register safely register FakeDriver
func (mc *MockCatcher) Register() <span class="cov8" title="1">{
        driversList := sql.Drivers()
        for _, name := range driversList </span><span class="cov0" title="0">{
                if name == DriverName </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov8" title="1">sql.Register(DriverName, &amp;FakeDriver{})</span>
}

// 钩子，搞个实现以下可以搞个连接失败
type Exceptions struct {
        HookQueryBadConnection func() bool
        HookExecBadConnection  func() bool
}

// FakeResponse represents mock of response with holding all required values to return mocked response
type FakeResponse struct {
        Pattern      string                            // 保存需要匹配的sql语句
        Strict       bool                              // 是不是必须完全匹配
        Args         []interface{}                     // 参数列表
        Response     []map[string]interface{}          // 响应结果
        Once         bool                              // 就触发一次
        Triggered    bool                              // 触发过就是true
        Callback     func(string, []driver.NamedValue) // Callback to execute when response triggered
        RowsAffected int64                             // 影响的行数，delete和update可以用
        LastInsertID int64                             // 插入完返回的id，insert可以用
        Error        error                             // Any type of error which could happen dur
        mu           sync.Mutex                        // Used to lock concurrent access to variables
        *Exceptions
}

func init() <span class="cov8" title="1">{
        Catcher = &amp;MockCatcher{}
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package golinq

import (
        "database/sql/driver"
)

// FakeResult implementation of sql Result interface
type FakeResult struct {
        insertID     int64
        rowsAffected int64
}

// NewFakeResult returns result interface instance
func NewFakeResult(insertID int64, rowsAffected int64) driver.Result <span class="cov8" title="1">{
        return &amp;FakeResult{insertID, rowsAffected}
}</span>

// LastInsertId required to give sql package ability get ID of inserted record
func (fr *FakeResult) LastInsertId() (int64, error) <span class="cov8" title="1">{
        return fr.insertID, nil
}</span>

// RowsAffected returns the number of rows affected
func (fr *FakeResult) RowsAffected() (int64, error) <span class="cov8" title="1">{
        return fr.rowsAffected, nil
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package golinq

import (
        "database/sql"
        "database/sql/driver"
        "errors"
        "io"
        "reflect"
        "time"
)

// RowsCursor is implementation of Rows sql interface
type RowsCursor struct {
        cols    []string
        colType [][]string
        posSet  int
        posRow  int
        rows    [][]*row
        closed  bool

        // errPos and err are for making Next return early with error.
        errPos int
        err    error

        bytesClone map[*byte][]byte
}

type row struct {
        cols []interface{} // must be same size as its table colname + coltype
}

// Close closes the rows iterator.
func (rc *RowsCursor) Close() error <span class="cov8" title="1">{
        if !rc.closed </span><span class="cov8" title="1">{
                for _, bs := range rc.bytesClone </span><span class="cov0" title="0">{
                        bs[0] = 255 // first byte corrupted
                }</span>
        }
        <span class="cov8" title="1">rc.closed = true
        return nil</span>
}

// Columns returns the names of the columns.
func (rc *RowsCursor) Columns() []string <span class="cov8" title="1">{
        return rc.cols
}</span>

// ColumnTypeScanType may be implemented by Rows. It should return
// the value type that can be used to scan types into.
func (rc *RowsCursor) ColumnTypeScanType(index int) reflect.Type <span class="cov0" title="0">{
        return colTypeToReflectType(rc.colType[rc.posSet][index])
}</span>

// Next is called to populate the next row of data into
// the provided slice.
func (rc *RowsCursor) Next(accumulator []driver.Value) error <span class="cov8" title="1">{
        if rc.closed </span><span class="cov0" title="0">{
                return errors.New("fake_db_driver: cursor is closed")
        }</span>
        <span class="cov8" title="1">rc.posRow++
        if rc.posRow == rc.errPos </span><span class="cov0" title="0">{
                return rc.err
        }</span>
        <span class="cov8" title="1">if rc.posRow &gt;= len(rc.rows[rc.posSet]) </span><span class="cov8" title="1">{
                return io.EOF // per interface spec
        }</span>
        <span class="cov8" title="1">for i, v := range rc.rows[rc.posSet][rc.posRow].cols </span><span class="cov8" title="1">{
                accumulator[i] = v
                if bs, ok := v.([]byte); ok </span><span class="cov0" title="0">{
                        if rc.bytesClone == nil </span><span class="cov0" title="0">{
                                rc.bytesClone = make(map[*byte][]byte)
                        }</span>
                        <span class="cov0" title="0">clone, ok := rc.bytesClone[&amp;bs[0]]
                        if !ok </span><span class="cov0" title="0">{
                                clone = make([]byte, len(bs))
                                copy(clone, bs)
                                rc.bytesClone[&amp;bs[0]] = clone
                        }</span>
                        <span class="cov0" title="0">accumulator[i] = clone</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// HasNextResultSet is called at the end of the current result set and
// reports whether there is another result set after the current one.
func (rc *RowsCursor) HasNextResultSet() bool <span class="cov8" title="1">{
        return rc.posSet &lt; len(rc.rows)-1
}</span>

// NextResultSet advances the driver to the next result set even
// if there are remaining rows in the current result set.
func (rc *RowsCursor) NextResultSet() error <span class="cov0" title="0">{
        if rc.HasNextResultSet() </span><span class="cov0" title="0">{
                rc.posSet++
                rc.posRow = -1
                return nil
        }</span>
        <span class="cov0" title="0">return io.EOF</span> // Per interface spec.
}

func colTypeToReflectType(typ string) reflect.Type <span class="cov0" title="0">{
        switch typ </span>{
        case "bool":<span class="cov0" title="0">
                return reflect.TypeOf(false)</span>
        case "nullbool":<span class="cov0" title="0">
                return reflect.TypeOf(sql.NullBool{})</span>
        case "int32":<span class="cov0" title="0">
                return reflect.TypeOf(int32(0))</span>
        case "string":<span class="cov0" title="0">
                return reflect.TypeOf("")</span>
        case "nullstring":<span class="cov0" title="0">
                return reflect.TypeOf(sql.NullString{})</span>
        case "int64":<span class="cov0" title="0">
                return reflect.TypeOf(int64(0))</span>
        case "nullint64":<span class="cov0" title="0">
                return reflect.TypeOf(sql.NullInt64{})</span>
        case "float64":<span class="cov0" title="0">
                return reflect.TypeOf(float64(0))</span>
        case "nullfloat64":<span class="cov0" title="0">
                return reflect.TypeOf(sql.NullFloat64{})</span>
        case "datetime":<span class="cov0" title="0">
                return reflect.TypeOf(time.Time{})</span>
        }
        <span class="cov0" title="0">panic("invalid fakedb column type of " + typ)</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package sql_parser

import "github.com/golang-collections/collections/queue"

type OuterTag int
type BuiltinType int

func (BuiltinType) GetTokenName() string <span class="cov0" title="0">{
        return "builtin"
}</span>

const (
        LeftOn     OuterTag = 1
        LeftUsing  OuterTag = 2
        RightOn    OuterTag = 3
        RightUsing OuterTag = 4
)

const (
        Default BuiltinType = -1
)

type SelectStatement struct {
        Id   int
        Tree *State
}

// Token 类型定义
type SqlToken interface {
        GetTokenName() string
}

type Tables struct {
        Values []SqlToken // As 或 Var
}

func (self *Tables) GetTokenName() string <span class="cov0" title="0">{
        return "tables"
}</span>

type As struct {
        NewName *Const
        Value   SqlToken
}

func (self *As) GetTokenName() string <span class="cov0" title="0">{
        return "as"
}</span>

type Func struct {
        Name string
        Args []interface{}
}

func (self *Func) GetTokenName() string <span class="cov0" title="0">{
        return "func"
}</span>

type Case struct {
        Values []*CaseItem
}

func (self *Case) GetTokenName() string <span class="cov0" title="0">{
        return "case"
}</span>

type CaseItem struct {
        Condition SqlToken  // *Func 或 *Var
        Value     SqlToken
}

func (self *CaseItem) GetTokenName() string <span class="cov0" title="0">{
        return "case-item"
}</span>

type Inner struct {
        Table     *Var
        Condition *Func
}

func (self *Inner) GetTokenName() string <span class="cov0" title="0">{
        return "inner"
}</span>

type Outer struct {
        Tag       OuterTag
        Table     SqlToken // As 或 Var
        Condition *Func
        Using     []SqlToken
}

func (self *Outer) GetTokenName() string <span class="cov0" title="0">{
        return "outer"
}</span>

type Desc struct {
        Value *Var
}

func (self *Desc) GetTokenName() string <span class="cov0" title="0">{
        return "desc"
}</span>

type Limit struct {
        Limit  *Const
        Offset *Const
}

func (self *Limit) GetTokenName() string <span class="cov0" title="0">{
        return "limit"
}</span>

type Link struct {
        Id int
}

func (self *Link) GetTokenName() string <span class="cov0" title="0">{
        return "link"
}</span>

type From struct {
        Tables *Tables
        Where  *Func
        Group  []*Var
        Having *Func
}

func (self *From) GetTokenName() string <span class="cov0" title="0">{
        return "from"
}</span>

type State struct {
        From   *From
        Order  []SqlToken
        Limit  *Limit
        Select []SqlToken
}

func (self *State) GetTokenName() string <span class="cov0" title="0">{
        return "state"
}</span>

type Var struct {
        Value *Const
        Next  *Var
}

func (self *Var) GetTokenName() string <span class="cov0" title="0">{
        return "var"
}</span>

type Const struct {
        Value interface{}
}

func (self *Const) GetTokenName() string <span class="cov0" title="0">{
        return "const"
}</span>

type EXPR struct {
        FromExpr   *Tables
        WhereExpr  *Func
        GroupExpr  []*Var
        HavingExpr *Func
        OrderExpr  []SqlToken
        LimitExpr  *Limit
        SelectExpr []SqlToken
}

func NewExpr(tree *State) *EXPR <span class="cov8" title="1">{
        frontPart := tree.From
        return &amp;EXPR{
                FromExpr:   frontPart.Tables,
                WhereExpr:  frontPart.Where,
                GroupExpr:  frontPart.Group,
                HavingExpr: frontPart.Having,
                OrderExpr:  tree.Order,
                LimitExpr:  tree.Limit,
                SelectExpr: tree.Select,
        }
}</span>

type InsertExpr struct {
        Ignore  bool
        Table   string
        Columns []SqlToken      // 可以是空
        Link    *Link           // 可以是空
        Values  [][]SqlToken // 可以是空
}

type ColumnValue struct {
        Column *Var
        Value  SqlToken
}

type UpdateExpr struct {
        Ignore bool
        Table  SqlToken
        Values []*ColumnValue
        Where  *Func
        Order  []SqlToken
        Limit  *Limit
}

type DeleteExpr struct {
        Ignore bool
        Table  string
        Where  *Func
        Order  []SqlToken
        Limit  *Limit
}

type Tree struct {
        SelectStatementsQueue *queue.Queue // 存 SQL 语句的语法树队列
        UpdateStatement       *UpdateExpr
        InsertStatement       *InsertExpr
        DeleteStatement       *DeleteExpr
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package sql_parser

import (
        "github.com/Aiyane/golinq/gen"
        "github.com/sirupsen/logrus"
        "strconv"
        "strings"

        "github.com/antlr/antlr4/runtime/Go/antlr"
        "github.com/golang-collections/collections/queue"
)

// 新建对象
func NewVisitor() *visitor <span class="cov8" title="1">{
        return &amp;visitor{
                SelectStatementsQueue: queue.New(),
                _id:                   0,
        }
}</span>

type visitor struct {
        *parser.BaseMySqlParserVisitor
        SelectStatementsQueue *queue.Queue // 存 SQL 语句的语法树队列
        UpdateStatement       *UpdateExpr
        InsertStatement       *InsertExpr
        DeleteStatement       *DeleteExpr
        _id                   int // 每一个语句的 id
}

// 获取 select 语句 id
func (self *visitor) getId() int <span class="cov8" title="1">{
        self._id++
        return self._id
}</span>

func (self *visitor) GetTree() *Tree <span class="cov8" title="1">{
        return &amp;Tree{
                SelectStatementsQueue: self.SelectStatementsQueue,
                UpdateStatement:       self.UpdateStatement,
                InsertStatement:       self.InsertStatement,
                DeleteStatement:       self.DeleteStatement,
        }
}</span>

func (self *visitor) Visit(root *parser.DmlStatementContext) <span class="cov8" title="1">{
        selectCtx := root.QuerySpecification()
        if selectCtx != nil </span><span class="cov8" title="1">{
                self.doVisitQuerySpecification(selectCtx.(*parser.QuerySpecificationContext))
                return
        }</span>
        <span class="cov8" title="1">insertCtx := root.InsertStatement()
        if insertCtx != nil </span><span class="cov8" title="1">{
                self.doVisitInsertStatement(insertCtx.(*parser.InsertStatementContext))
                return
        }</span>
        <span class="cov8" title="1">updateCtx := root.UpdateStatement()
        if updateCtx != nil </span><span class="cov8" title="1">{
                self.doVisitUpdateStatement(updateCtx.(*parser.UpdateStatementContext))
                return
        }</span>
        <span class="cov8" title="1">deleteCtx := root.DeleteStatement()
        if deleteCtx != nil </span><span class="cov8" title="1">{
                self.doVisitDeleteStatement(deleteCtx.(*parser.DeleteStatementContext))
        }</span>
}

func (self *visitor) doVisitInsertStatement(ctx *parser.InsertStatementContext) <span class="cov8" title="1">{
        /*
                INSERT
                IGNORE? INTO? ID
                  ('(' columns=uidList ')')? insertStatementValue
        */
        ignore := false
        if ctx.IGNORE() != nil </span><span class="cov0" title="0">{
                ignore = true
        }</span>
        <span class="cov8" title="1">table := ctx.ID().GetText()
        var uidList []SqlToken
        if columns := ctx.UidList(); columns != nil </span><span class="cov8" title="1">{
                uidList = self.doVisitUidList(columns.(*parser.UidListContext))
        }</span>
        <span class="cov8" title="1">insertStatementValue := self.doVisitInsertStatementValue(ctx.InsertStatementValue().(*parser.InsertStatementValueContext))
        var values [][]SqlToken
        var link *Link
        switch v := insertStatementValue.(type) </span>{
        case [][]SqlToken:<span class="cov8" title="1">
                values = v</span>
        case *Link:<span class="cov8" title="1">
                link = v</span>
        default:<span class="cov0" title="0">
                logrus.Errorf("[doVisitInsertStatement] insertStatementValue no such type [%v]", insertStatementValue)
                return</span>
        }
        <span class="cov8" title="1">self.InsertStatement = &amp;InsertExpr{
                Ignore:  ignore,
                Table:   doVisitID(table),
                Columns: uidList,
                Link:    link,
                Values:  values,
        }</span>
}

func (self *visitor) doVisitInsertStatementValue(ctx *parser.InsertStatementValueContext) interface{} <span class="cov8" title="1">{
        /*
           selectStatement
            | insertFormat=(VALUES | VALUE)
              '(' expressionsWithDefaults ')'
                (',' '(' expressionsWithDefaults ')')*
        */
        if selectStatement := ctx.SelectStatement(); selectStatement != nil </span><span class="cov8" title="1">{
                return self.visitSelectStatement(selectStatement)
        }</span>
        <span class="cov8" title="1">var ret [][]SqlToken
        for _, expressionsWithDefaults := range ctx.AllExpressionsWithDefaults() </span><span class="cov8" title="1">{
                ret = append(ret, self.doVisitExpressionsWithDefaults(expressionsWithDefaults.(*parser.ExpressionsWithDefaultsContext)))
        }</span>
        <span class="cov8" title="1">return ret</span>
}

func (self *visitor) doVisitUpdatedElement(ctx *parser.UpdatedElementContext) *ColumnValue <span class="cov8" title="1">{
        /*
                fullColumnName '=' expressionOrDefault
        */
        fullColumnName := self.doVisitFullColumnName(ctx.FullColumnName().(*parser.FullColumnNameContext))
        expressionOrDefault := self.doVisitExpressionOrDefault(ctx.ExpressionOrDefault().(*parser.ExpressionOrDefaultContext))
        return &amp;ColumnValue{
                Column: fullColumnName,
                Value:  expressionOrDefault,
        }
}</span>

func (self *visitor) doVisitExpressionsWithDefaults(ctx *parser.ExpressionsWithDefaultsContext) []SqlToken <span class="cov8" title="1">{
        /*
                expressionOrDefault (',' expressionOrDefault)*
        */
        var ret []SqlToken
        for _, expressionOrDefault := range ctx.AllExpressionOrDefault() </span><span class="cov8" title="1">{
                ret = append(ret, self.doVisitExpressionOrDefault(expressionOrDefault.(*parser.ExpressionOrDefaultContext)))
        }</span>
        <span class="cov8" title="1">return ret</span>
}

func (self *visitor) doVisitExpressionOrDefault(ctx *parser.ExpressionOrDefaultContext) SqlToken <span class="cov8" title="1">{
        /*
                expression | DEFAULT
        */
        if expression := ctx.Expression(); expression != nil </span><span class="cov8" title="1">{
                return self.visitExpression(expression).(SqlToken)
        }</span>
        <span class="cov0" title="0">return Default</span>
}

func (self *visitor) doVisitDeleteStatement(ctx *parser.DeleteStatementContext) <span class="cov8" title="1">{
        /*
                DELETE IGNORE?
                FROM ID
                  (WHERE expression)?
                  orderByClause? limitClause?
        */
        ignore := false
        if ctx.IGNORE() != nil </span><span class="cov0" title="0">{
                ignore = true
        }</span>
        <span class="cov8" title="1">table := ctx.ID().GetText()
        var where *Func
        if expression := ctx.Expression(); expression != nil </span><span class="cov8" title="1">{
                _where := self.visitExpression(expression)
                where = dealWhere(_where)
        }</span>
        <span class="cov8" title="1">var order []SqlToken
        if orderByClause := ctx.OrderByClause(); orderByClause != nil </span><span class="cov8" title="1">{
                order = self.doVisitOrderByClause(orderByClause.(*parser.OrderByClauseContext))
        }</span>
        <span class="cov8" title="1">var limit *Limit
        if limitClause := ctx.LimitClause(); limitClause != nil </span><span class="cov8" title="1">{
                limit = self.doVisitLimitClause(limitClause.(*parser.LimitClauseContext))
        }</span>
        <span class="cov8" title="1">self.DeleteStatement = &amp;DeleteExpr{
                Ignore: ignore,
                Table:  doVisitID(table),
                Where:  where,
                Order:  order,
                Limit:  limit,
        }</span>
}

func (self *visitor) doVisitUpdateStatement(ctx *parser.UpdateStatementContext) <span class="cov8" title="1">{
        /*
                UPDATE IGNORE? ID (AS? ID)?
                  SET updatedElement (',' updatedElement)*
                  (WHERE expression)? orderByClause? limitClause?
        */
        ignore := false
        if ctx.IGNORE() != nil </span><span class="cov0" title="0">{
                ignore = true
        }</span>
        <span class="cov8" title="1">_table := &amp;Var{
                Value: &amp;Const{
                        Value: doVisitID(ctx.ID(0).GetText()),
                },
                Next: nil,
        }
        var table SqlToken
        if as := ctx.AS(); as != nil </span><span class="cov0" title="0">{
                table = &amp;As{
                        NewName: &amp;Const{
                                Value: doVisitID(ctx.ID(1).GetText()),
                        },
                        Value: _table,
                }
        }</span> else<span class="cov8" title="1"> {
                table = _table
        }</span>
        <span class="cov8" title="1">values := make([]*ColumnValue, 0, 50)
        for _, updatedElement := range ctx.AllUpdatedElement() </span><span class="cov8" title="1">{
                values = append(values, self.doVisitUpdatedElement(updatedElement.(*parser.UpdatedElementContext)))
        }</span>
        <span class="cov8" title="1">var where *Func
        if expression := ctx.Expression(); expression != nil </span><span class="cov8" title="1">{
                _where := self.visitExpression(expression)
                where = dealWhere(_where)
        }</span>
        <span class="cov8" title="1">var order []SqlToken
        if orderByClause := ctx.OrderByClause(); orderByClause != nil </span><span class="cov8" title="1">{
                order = self.doVisitOrderByClause(orderByClause.(*parser.OrderByClauseContext))
        }</span>
        <span class="cov8" title="1">var limit *Limit
        if limitClause := ctx.LimitClause(); limitClause != nil </span><span class="cov8" title="1">{
                limit = self.doVisitLimitClause(limitClause.(*parser.LimitClauseContext))
        }</span>
        <span class="cov8" title="1">self.UpdateStatement = &amp;UpdateExpr{
                Ignore: ignore,
                Table:  table,
                Values: values,
                Where:  where,
                Order:  order,
                Limit:  limit,
        }</span>
}

func (self *visitor) doVisitQueryExpression(ctx *parser.QueryExpressionContext) *Link <span class="cov0" title="0">{
        /*
                LR_BRACKET querySpecification RR_BRACKET | LR_BRACKET queryExpression RR_BRACKET
        */
        querySpecification := ctx.QuerySpecification()
        if querySpecification == nil </span><span class="cov0" title="0">{
                queryExpression := ctx.QueryExpression()
                if queryExpression != nil </span><span class="cov0" title="0">{
                        return self.doVisitQueryExpression(queryExpression.(*parser.QueryExpressionContext))
                }</span>
        }
        <span class="cov0" title="0">return self.doVisitQuerySpecification(querySpecification.(*parser.QuerySpecificationContext))</span>
}

func (self *visitor) doVisitQuerySpecification(ctx *parser.QuerySpecificationContext) *Link <span class="cov8" title="1">{
        /* 每个 select 子句都需要入队
        SELECT DISTINCT? selectElements
        fromClause? orderByClause? limitClause?
        */
        var distinct SqlToken
        distinct = &amp;Const{Value: false}
        if d := ctx.DISTINCT(); d != nil </span><span class="cov0" title="0">{
                distinct = &amp;Const{Value: true}
        }</span>

        <span class="cov8" title="1">selectElements := self.doVisitSelectElements(ctx.SelectElements().(*parser.SelectElementsContext))

        var fromClause *From
        if f := ctx.FromClause(); f != nil </span><span class="cov8" title="1">{
                fromClause = self.doVisitFromClause(f.(*parser.FromClauseContext))
        }</span> else<span class="cov0" title="0"> {
                fromClause = nil
        }</span>

        <span class="cov8" title="1">var orderByClause []SqlToken
        if o := ctx.OrderByClause(); o != nil </span><span class="cov8" title="1">{
                orderByClause = self.doVisitOrderByClause(o.(*parser.OrderByClauseContext))
        }</span> else<span class="cov8" title="1"> {
                orderByClause = nil
        }</span>

        <span class="cov8" title="1">var limitClause *Limit
        if l := ctx.LimitClause(); l != nil </span><span class="cov8" title="1">{
                limitClause = self.doVisitLimitClause(l.(*parser.LimitClauseContext))
        }</span> else<span class="cov8" title="1"> {
                limitClause = nil
        }</span>

        <span class="cov8" title="1">var selectClause []SqlToken
        selectClause = append(selectClause, distinct)
        selectClause = append(selectClause, selectElements...)

        SqlToken := &amp;State{
                From:   fromClause,
                Order:  orderByClause,
                Limit:  limitClause,
                Select: selectClause,
        }

        tree := &amp;SelectStatement{
                Id:   self.getId(),
                Tree: SqlToken,
        }

        // 入队
        self.SelectStatementsQueue.Enqueue(tree)
        // 返回的是链接
        return &amp;Link{tree.Id}</span>
}

func (self *visitor) doVisitSelectColumnElement(ctx *parser.SelectColumnElementContext) SqlToken <span class="cov8" title="1">{
        /*
                fullColumnName (AS? ID)?
        */
        name := self.doVisitFullColumnName(ctx.FullColumnName().(*parser.FullColumnNameContext))

        alis := ctx.ID()
        if alis == nil </span><span class="cov8" title="1">{
                return name
        }</span>
        <span class="cov8" title="1">alisStr := alis.GetText()
        return &amp;As{
                NewName: &amp;Const{Value: doVisitID(alisStr)},
                Value:   name,
        }</span>
}

func doVisitID(value string) string <span class="cov8" title="1">{
        if value[0] == '`' </span><span class="cov8" title="1">{
                return value[1 : len(value)-1]
        }</span>
        <span class="cov8" title="1">return value</span>
}

func (self *visitor) doVisitSelectFunctionElement(ctx *parser.SelectFunctionElementContext) SqlToken <span class="cov8" title="1">{
        /*
                functionCall (AS? ID)?
        */
        name := self.visitFunctionCall(ctx.FunctionCall())

        alis := ctx.ID()
        if alis == nil </span><span class="cov0" title="0">{
                return name
        }</span>

        <span class="cov8" title="1">alisStr := alis.GetText()
        return &amp;As{
                NewName: &amp;Const{Value: doVisitID(alisStr)},
                Value:   name,
        }</span>
}

func (self *visitor) doVisitSelectExpressionElement(ctx *parser.SelectExpressionElementContext) SqlToken <span class="cov8" title="1">{
        /*
                expression (AS? ID)?
        */
        name := self.visitExpression(ctx.Expression()).(SqlToken)

        alis := ctx.ID()
        if alis == nil </span><span class="cov0" title="0">{
                return name
        }</span>

        <span class="cov8" title="1">alisStr := alis.GetText()
        return &amp;As{
                NewName: &amp;Const{Value: doVisitID(alisStr)},
                Value:   name,
        }</span>
}

func (self *visitor) doVisitSelectElements(ctx *parser.SelectElementsContext) []SqlToken <span class="cov8" title="1">{
        /*
                (star='*' | selectElement ) (',' selectElement)*
        */
        var args []SqlToken
        if s := ctx.STAR(); s != nil </span><span class="cov8" title="1">{
                args = append(args, &amp;Const{true})
        }</span> else<span class="cov8" title="1"> {
                args = append(args, &amp;Const{false})
        }</span>
        <span class="cov8" title="1">selectElements := ctx.AllSelectElement()
        for _, selectElement := range selectElements </span><span class="cov8" title="1">{
                args = append(args, self.visitSelectElement(selectElement))
        }</span>
        <span class="cov8" title="1">return args</span>
}

func dealWhere(_whereExpr interface{}) *Func <span class="cov8" title="1">{
        var whereExpr *Func
        switch realWhereExpr := _whereExpr.(type) </span>{
        case *Func:<span class="cov8" title="1">
                whereExpr = realWhereExpr</span>
        case []SqlToken:<span class="cov8" title="1">
                whereExpr = realWhereExpr[0].(*Func)</span>
        default:<span class="cov0" title="0">
                logrus.Errorf("[doVisitFromClause] no such type [%T]", whereExpr)
                return nil</span>
        }
        <span class="cov8" title="1">return whereExpr</span>
}

func (self *visitor) doVisitFromClause(ctx *parser.FromClauseContext) *From <span class="cov8" title="1">{
        /*
                FROM tableSources
                (WHERE whereExpr=expression)?
                (
                  GROUP BY
                  groupByItem (',' groupByItem)*
                  (HAVING havingExpr=expression)?
                )?
        */
        var groupExpr []*Var
        var havingExpr *Func
        var whereExpr *Func
        tableSources := self.doVisitTableSources(ctx.TableSources().(*parser.TableSourcesContext))
        if g := ctx.GROUP(); g != nil </span><span class="cov8" title="1">{
                var items []*Var
                _items := ctx.AllGroupByItem()
                for _, item := range _items </span><span class="cov8" title="1">{
                        items = append(items, self.doVisitGroupByItem(item.(*parser.GroupByItemContext)).(*Var))
                }</span>
                <span class="cov8" title="1">groupExpr = items</span>
        } else<span class="cov8" title="1"> {
                groupExpr = nil
        }</span>
        <span class="cov8" title="1">if w := ctx.WHERE(); w != nil </span><span class="cov8" title="1">{
                _whereExpr := self.visitExpression(ctx.Expression(0))
                whereExpr = dealWhere(_whereExpr)
                if h := ctx.HAVING(); h != nil </span><span class="cov8" title="1">{
                        havingExpr = self.visitExpression(ctx.Expression(1)).(*Func)
                }</span> else<span class="cov8" title="1"> {
                        havingExpr = nil
                }</span>
        } else<span class="cov8" title="1"> {
                whereExpr = nil
                if h := ctx.HAVING(); h != nil </span><span class="cov8" title="1">{
                        havingExpr = self.visitExpression(ctx.Expression(0)).(*Func)
                }</span> else<span class="cov8" title="1"> {
                        havingExpr = nil
                }</span>
        }
        <span class="cov8" title="1">return &amp;From{
                Tables: tableSources,
                Where:  whereExpr,
                Group:  groupExpr,
                Having: havingExpr,
        }</span>

}

func (self *visitor) doVisitGroupByItem(ctx *parser.GroupByItemContext) interface{} <span class="cov8" title="1">{
        /*
                expression order=(ASC | DESC)?
        */
        if d := ctx.DESC(); d != nil </span><span class="cov0" title="0">{
                return &amp;Desc{Value: self.visitExpression(ctx.Expression()).(*Var)}
        }</span> else<span class="cov8" title="1"> {
                return self.visitExpression(ctx.Expression())
        }</span>
}

func (self *visitor) doVisitTableSourceBase(ctx *parser.TableSourceBaseContext) *Tables <span class="cov8" title="1">{
        /*
                tableSourceItem joinPart*
        */
        var args []SqlToken
        args = append(args, self.visitTableSourceItem(ctx.TableSourceItem()))
        joinParts := ctx.AllJoinPart()
        for _, joinPart := range joinParts </span><span class="cov8" title="1">{
                args = append(args, self.visitJoinPart(joinPart))
        }</span>
        <span class="cov8" title="1">return &amp;Tables{Values: args}</span>
}

func (self *visitor) doVisitFunctionArgs(ctx *parser.FunctionArgsContext) []interface{} <span class="cov8" title="1">{
        /*
                (allFunctionArg)
                (',' (allFunctionArg) )*
        */
        var args []interface{}
        allFunctionArgs := ctx.AllAllFunctionArg()
        for _, allFunctionArg := range allFunctionArgs </span><span class="cov8" title="1">{
                args = append(args, self.doVisitAllFunctionArg(allFunctionArg.(*parser.AllFunctionArgContext)))
        }</span>
        <span class="cov8" title="1">return args</span>
}

func (self *visitor) doVisitAllFunctionArg(ctx *parser.AllFunctionArgContext) interface{} <span class="cov8" title="1">{
        /*
                '*' | ALL | constant | fullColumnName | functionCall | expression
        */
        if ctx.STAR() != nil </span><span class="cov8" title="1">{
                return &amp;Const{Value: "*"}
        }</span>
        <span class="cov8" title="1">if ctx.ALL() != nil </span><span class="cov0" title="0">{
                return &amp;Const{Value: "*"}
        }</span>
        <span class="cov8" title="1">if c := ctx.Constant(); c != nil </span><span class="cov8" title="1">{
                return self.doVisitConstant(c.(*parser.ConstantContext))
        }</span>
        <span class="cov8" title="1">if f := ctx.FullColumnName(); f != nil </span><span class="cov8" title="1">{
                return self.doVisitFullColumnName(f.(*parser.FullColumnNameContext))
        }</span>
        <span class="cov8" title="1">if fc := ctx.FunctionCall(); fc != nil </span><span class="cov8" title="1">{
                return self.visitFunctionCall(fc)
        }</span>
        <span class="cov0" title="0">return self.visitExpression(ctx.Expression())</span>
}

func (self *visitor) doVisitTableSourceNested(ctx *parser.TableSourceNestedContext) *Tables <span class="cov0" title="0">{
        /*
                '(' tableSourceItem joinPart* ')'
        */
        var args []SqlToken
        args = append(args, self.visitTableSourceItem(ctx.TableSourceItem()))
        joinParts := ctx.AllJoinPart()
        for _, joinPart := range joinParts </span><span class="cov0" title="0">{
                args = append(args, self.visitJoinPart(joinPart))
        }</span>
        <span class="cov0" title="0">return &amp;Tables{Values: args}</span>
}

func (self *visitor) doVisitInnerJoin(ctx *parser.InnerJoinContext) *Inner <span class="cov8" title="1">{
        /*
                (INNER | CROSS)? JOIN tableSourceItem (ON expression)?
        */
        if ctx.ON() != nil </span><span class="cov8" title="1">{
                return &amp;Inner{
                        Table:     self.visitTableSourceItem(ctx.TableSourceItem()).(*Var),
                        Condition: self.visitExpression(ctx.Expression()).(*Func),
                }
        }</span>
        <span class="cov8" title="1">return &amp;Inner{
                Table:     self.visitTableSourceItem(ctx.TableSourceItem()).(*Var),
                Condition: nil,
        }</span>
}

func (self *visitor) doVisitOuterJoin(ctx *parser.OuterJoinContext) *Outer <span class="cov0" title="0">{
        /*
                (LEFT | RIGHT) OUTER? JOIN tableSourceItem
                (
                  ON expression
                  | USING '(' uidList ')'
                )
        */
        expression := ctx.Expression()
        var tag OuterTag
        var table SqlToken
        var condition *Func
        var using []SqlToken
        if l := ctx.LEFT(); l != nil </span><span class="cov0" title="0">{
                if expression != nil </span><span class="cov0" title="0">{
                        tag = LeftOn
                        table = self.visitTableSourceItem(ctx.TableSourceItem())
                        condition = self.visitExpression(expression).(*Func)
                }</span> else<span class="cov0" title="0"> {
                        tag = LeftUsing
                        table = self.visitTableSourceItem(ctx.TableSourceItem())
                        using = self.doVisitUidList(ctx.UidList().(*parser.UidListContext))
                }</span>
        } else<span class="cov0" title="0"> {
                if expression != nil </span><span class="cov0" title="0">{
                        tag = RightOn
                        table = self.visitTableSourceItem(ctx.TableSourceItem())
                        condition = self.visitExpression(expression).(*Func)
                }</span> else<span class="cov0" title="0"> {
                        tag = RightUsing
                        table = self.visitTableSourceItem(ctx.TableSourceItem())
                        using = self.doVisitUidList(ctx.UidList().(*parser.UidListContext))
                }</span>
        }
        <span class="cov0" title="0">return &amp;Outer{
                Tag:       tag,
                Table:     table,
                Condition: condition,
                Using:     using,
        }</span>
}

func (self *visitor) doVisitUidList(ctx *parser.UidListContext) []SqlToken <span class="cov8" title="1">{
        /*
                ID (',' ID)*
        */
        var args []SqlToken
        ids := ctx.AllID()
        for _, id := range ids </span><span class="cov8" title="1">{
                args = append(args, &amp;Const{doVisitID(id.GetText())})
        }</span>
        <span class="cov8" title="1">return args</span>
}

func (self *visitor) doVisitAtomTableItem(ctx *parser.AtomTableItemContext) SqlToken <span class="cov8" title="1">{
        /*
                fullColumnName (AS? alias=ID)?
        */
        name := self.doVisitFullColumnName(ctx.FullColumnName().(*parser.FullColumnNameContext))
        if alis := ctx.ID(); alis != nil </span><span class="cov8" title="1">{
                return &amp;As{
                        NewName: &amp;Const{Value: doVisitID(alis.GetText())},
                        Value:   name,
                }
        }</span> else<span class="cov8" title="1"> {
                return name
        }</span>
}

func (self *visitor) doVisitSubqueryTableItem(ctx *parser.SubqueryTableItemContext) *As <span class="cov0" title="0">{
        /*
                selectStatement
                | '(' parenthesisSubquery=selectStatement ')'
                )
                AS? alias=ID
        */
        return &amp;As{
                NewName: &amp;Const{Value: doVisitID(ctx.ID().GetText())},
                Value:   self.visitSelectStatement(ctx.SelectStatement()),
        }
}</span>

func (self *visitor) doVisitTableSourcesItem(ctx *parser.TableSourcesItemContext) *Tables <span class="cov0" title="0">{
        /*
                '(' tableSources ')'
        */
        return self.doVisitTableSources(ctx.TableSources().(*parser.TableSourcesContext))
}</span>

func (self *visitor) doVisitTableSources(ctx *parser.TableSourcesContext) *Tables <span class="cov8" title="1">{
        /*
                tableSource (',' tableSource)*
        */
        firstSource := self.visitTableSource(ctx.TableSource(0))
        tables := ctx.AllTableSource()
        for _, table := range tables[1:] </span><span class="cov8" title="1">{
                firstSource.Values = append(firstSource.Values,
                        self.visitTableSource(table).Values...)
        }</span>
        <span class="cov8" title="1">return firstSource</span>
}

func (self *visitor) doVisitOrderByClause(ctx *parser.OrderByClauseContext) []SqlToken <span class="cov8" title="1">{
        /*
                ORDER BY orderByExpression (',' orderByExpression)*
        */
        var args []SqlToken
        expressions := ctx.AllOrderByExpression()
        for _, expression := range expressions </span><span class="cov8" title="1">{
                args = append(args, self.doVisitOrderByExpression(expression.(*parser.OrderByExpressionContext)).(SqlToken))
        }</span>
        <span class="cov8" title="1">return args</span>
}

func (self *visitor) doVisitOrderByExpression(ctx *parser.OrderByExpressionContext) interface{} <span class="cov8" title="1">{
        /*
                expression order=(ASC | DESC)?
        */
        if d := ctx.DESC(); d != nil </span><span class="cov8" title="1">{
                return &amp;Desc{Value: self.visitExpression(ctx.Expression()).(*Var)}
        }</span> else<span class="cov8" title="1"> {
                return self.visitExpression(ctx.Expression())
        }</span>
}

func (self *visitor) doVisitLimitClause(ctx *parser.LimitClauseContext) *Limit <span class="cov8" title="1">{
        /*
                LIMIT
                (
                  (offset=DECIMAL_LITERAL ',')? limit=DECIMAL_LITERAL
                  | limit=DECIMAL_LITERAL OFFSET offset=DECIMAL_LITERAL
                )
        */
        var offset *Const
        var limit *Const
        if o := ctx.OFFSET(); o != nil </span><span class="cov0" title="0">{
                offsetNum, _ := strconv.Atoi(ctx.DECIMAL_LITERAL(1).GetText())
                limitNum, _ := strconv.Atoi(ctx.DECIMAL_LITERAL(0).GetText())
                offset = &amp;Const{Value: offsetNum}
                limit = &amp;Const{Value: limitNum}
        }</span> else<span class="cov8" title="1"> if c := ctx.COMMA(); c != nil </span><span class="cov8" title="1">{
                offsetNum, _ := strconv.Atoi(ctx.DECIMAL_LITERAL(0).GetText())
                limitNum, _ := strconv.Atoi(ctx.DECIMAL_LITERAL(1).GetText())
                offset = &amp;Const{Value: offsetNum}
                limit = &amp;Const{Value: limitNum}
        }</span> else<span class="cov8" title="1"> {
                offset = &amp;Const{Value: 0}
                limitNum, _ := strconv.Atoi(ctx.DECIMAL_LITERAL(0).GetText())
                limit = &amp;Const{Value: limitNum}
        }</span>
        <span class="cov8" title="1">return &amp;Limit{
                Limit:  limit,
                Offset: offset,
        }</span>
}

func (self *visitor) doVisitNotExpression(ctx *parser.NotExpressionContext) *Func <span class="cov0" title="0">{
        /*
                notOperator=(NOT | '!') expression
        */
        return &amp;Func{
                Name: "not",
                Args: []interface{}{self.visitExpression(ctx.Expression())},
        }
}</span>

func (self *visitor) doVisitLogicalExpression(ctx *parser.LogicalExpressionContext) *Func <span class="cov8" title="1">{
        /*
                expression logicalOperator expression
        */
        left := self.visitExpression(ctx.Expression(0)).(SqlToken)
        right := self.visitExpression(ctx.Expression(1)).(SqlToken)
        var args []interface{}
        args = append(args, left)
        args = append(args, right)
        return &amp;Func{
                Name: self.doVisitLogicalOperator(ctx.LogicalOperator().(*parser.LogicalOperatorContext)),
                Args: args,
        }
}</span>

func (self *visitor) doVisitIsExpression(ctx *parser.IsExpressionContext) *Func <span class="cov0" title="0">{
        /*
                predicate IS NOT? testValue=(TRUE | FALSE | UNKNOWN)
        */
        left := self.visitPredicate(ctx.Predicate()).(SqlToken)
        val := ctx.GetTestValue().GetText()
        var right SqlToken
        var name string
        if n := ctx.NOT(); n != nil </span><span class="cov0" title="0">{
                name = "is_not"
                if val == "TRUE" </span><span class="cov0" title="0">{
                        right = &amp;Const{Value: true}
                }</span> else<span class="cov0" title="0"> if val == "FALSE" </span><span class="cov0" title="0">{
                        right = &amp;Const{Value: false}
                }</span> else<span class="cov0" title="0"> {
                        right = &amp;Const{Value: nil}
                }</span>
        } else<span class="cov0" title="0"> {
                name = "is"
                //args = append(args, left)
                if val == "TRUE" </span><span class="cov0" title="0">{
                        right = &amp;Const{Value: true}
                }</span> else<span class="cov0" title="0"> if val == "FALSE" </span><span class="cov0" title="0">{
                        right = &amp;Const{Value: false}
                }</span> else<span class="cov0" title="0"> {
                        right = &amp;Const{Value: nil}
                }</span>
        }
        <span class="cov0" title="0">return &amp;Func{
                Name: name,
                Args: []interface{}{left, right},
        }</span>
}

func (self *visitor) doVisitInPredicate(ctx *parser.InPredicateContext) *Func <span class="cov8" title="1">{
        /*
                predicate NOT? IN '(' (selectStatement | expressions) ')':
        */
        left := self.visitPredicate(ctx.Predicate()).(SqlToken)
        var name string
        var right interface{}
        selectStatement := ctx.SelectStatement()
        if n := ctx.NOT(); n != nil </span><span class="cov8" title="1">{
                name = "not_in"
                if selectStatement != nil </span><span class="cov0" title="0">{
                        right = self.visitSelectStatement(selectStatement)
                }</span> else<span class="cov8" title="1"> {
                        right = self.doVisitExpressions(ctx.Expressions().(*parser.ExpressionsContext))
                }</span>
        } else<span class="cov8" title="1"> {
                name = "in"
                if selectStatement != nil </span><span class="cov8" title="1">{
                        right = self.visitSelectStatement(selectStatement)
                }</span> else<span class="cov8" title="1"> {
                        right = self.doVisitExpressions(ctx.Expressions().(*parser.ExpressionsContext))
                }</span>
        }
        <span class="cov8" title="1">return &amp;Func{
                Name: name,
                Args: []interface{}{left, right},
        }</span>
}

func (self *visitor) doVisitExpressions(ctx *parser.ExpressionsContext) []SqlToken <span class="cov8" title="1">{
        /*
                expression (',' expression)*
        */
        var args []SqlToken
        for _, expression := range ctx.AllExpression() </span><span class="cov8" title="1">{
                args = append(args, self.visitExpression(expression).(SqlToken))
        }</span>
        <span class="cov8" title="1">return args</span>
}

func (self *visitor) doVisitIsNullPredicate(ctx *parser.IsNullPredicateContext) *Func <span class="cov0" title="0">{
        /*
                predicate IS nullNotnull
        */
        left := self.visitPredicate(ctx.Predicate()).(SqlToken)
        right := self.doVisitNullNotnull(ctx.NullNotnull().(*parser.NullNotnullContext))
        name := "is"
        return &amp;Func{
                Name: name,
                Args: []interface{}{left, right},
        }
}</span>

func (self *visitor) doVisitNullNotnull(ctx *parser.NullNotnullContext) SqlToken <span class="cov0" title="0">{
        /*
                NOT? (NULL_LITERAL | NULL_SPEC_LITERAL)
        */
        if n := ctx.NULL_LITERAL(); n != nil </span><span class="cov0" title="0">{
                if _not := ctx.NOT(); _not != nil </span><span class="cov0" title="0">{
                        return &amp;Func{
                                Name: "not",
                                Args: []interface{}{&amp;Const{Value: nil}},
                        }
                }</span> else<span class="cov0" title="0"> {
                        return &amp;Const{Value: nil}
                }</span>
        } else<span class="cov0" title="0"> {
                if _not := ctx.NOT(); _not != nil </span><span class="cov0" title="0">{
                        return &amp;Func{
                                Name: "not",
                                Args: []interface{}{&amp;Const{Value: "\n"}},
                        }
                }</span> else<span class="cov0" title="0"> {
                        return &amp;Const{Value: "\n"}
                }</span>
        }
}

func (self *visitor) doVisitBinaryComparasionPredicate(ctx *parser.BinaryComparasionPredicateContext) *Func <span class="cov8" title="1">{
        /*
                left=predicate comparisonOperator right=predicate
        */
        left := self.visitPredicate(ctx.Predicate(0)).(SqlToken)
        op := self.doVisitComparisonOperator(ctx.ComparisonOperator().(*parser.ComparisonOperatorContext))
        right := self.visitPredicate(ctx.Predicate(1)).(SqlToken)
        return &amp;Func{
                Name: op,
                Args: []interface{}{left, right},
        }
}</span>

func (self *visitor) doVisitComparisonOperator(ctx *parser.ComparisonOperatorContext) string <span class="cov8" title="1">{
        /*
                '=' | '&gt;' | '&lt;' | '&lt;' '=' | '&gt;' '='
                | '&lt;' '&gt;' | '!' '=' | '&lt;' '=' '&gt;'
        */
        equalSymbol := ctx.EQUAL_SYMBOL()
        greaterSymbol := ctx.GREATER_SYMBOL()
        lessSymbol := ctx.LESS_SYMBOL()
        exclamationSymbol := ctx.EXCLAMATION_SYMBOL()
        if equalSymbol != nil </span><span class="cov8" title="1">{
                if lessSymbol == nil </span><span class="cov8" title="1">{
                        if exclamationSymbol == nil </span><span class="cov8" title="1">{
                                if greaterSymbol == nil </span><span class="cov8" title="1">{
                                        return "="
                                }</span> else<span class="cov8" title="1"> {
                                        return "&gt;="
                                }</span>
                        } else<span class="cov8" title="1"> {
                                return "!="
                        }</span>
                } else<span class="cov0" title="0"> {
                        if greaterSymbol == nil </span><span class="cov0" title="0">{
                                return "&lt;=&gt;"
                        }</span> else<span class="cov0" title="0"> {
                                return "&lt;="
                        }</span>
                }
        } else<span class="cov8" title="1"> if greaterSymbol != nil </span><span class="cov8" title="1">{
                if lessSymbol != nil </span><span class="cov0" title="0">{
                        return "&lt;&gt;"
                }</span> else<span class="cov8" title="1"> {
                        return "&gt;"
                }</span>
        } else<span class="cov8" title="1"> {
                return "&lt;"
        }</span>
}

func (self *visitor) doVisitSubqueryComparasionPredicate(ctx *parser.SubqueryComparasionPredicateContext) *Func <span class="cov0" title="0">{
        /*
                predicate comparisonOperator quantifier=(ALL | ANY | SOME) '(' selectStatement ')'
        */
        left := self.visitPredicate(ctx.Predicate()).(SqlToken)
        op := self.doVisitComparisonOperator(ctx.ComparisonOperator().(*parser.ComparisonOperatorContext))
        selectStatement := self.visitSelectStatement(ctx.SelectStatement())
        return &amp;Func{
                Name: ctx.GetQuantifier().GetText() + op,
                Args: []interface{}{left, selectStatement},
        }
}</span>

func (self *visitor) doVisitBetweenPredicate(ctx *parser.BetweenPredicateContext) *Func <span class="cov0" title="0">{
        /*
                predicate NOT? BETWEEN predicate AND predicate
        */
        left := self.visitPredicate(ctx.Predicate(0)).(SqlToken)
        start := self.visitPredicate(ctx.Predicate(1)).(SqlToken)
        end := self.visitPredicate(ctx.Predicate(2)).(SqlToken)
        var name string
        if n := ctx.NOT(); n != nil </span><span class="cov0" title="0">{
                name = "not_between"
        }</span> else<span class="cov0" title="0"> {
                name = "between"
        }</span>
        <span class="cov0" title="0">return &amp;Func{
                Name: name,
                Args: []interface{}{left, start, end},
        }</span>
}

func (self *visitor) doVisitLikePredicate(ctx *parser.LikePredicateContext) *Func <span class="cov0" title="0">{
        /*
                predicate NOT? LIKE predicate
        */
        left := self.visitPredicate(ctx.Predicate(0)).(SqlToken)
        right := self.visitPredicate(ctx.Predicate(1)).(SqlToken)
        var name string
        if n := ctx.NOT(); n != nil </span><span class="cov0" title="0">{
                name = "not_like"
        }</span> else<span class="cov0" title="0"> {
                name = "like"
        }</span>
        <span class="cov0" title="0">return &amp;Func{
                Name: name,
                Args: []interface{}{left, right},
        }</span>
}

func (self *visitor) doVisitRegexpPredicate(ctx *parser.RegexpPredicateContext) *Func <span class="cov0" title="0">{
        /*
                predicate NOT? regex=(REGEXP | RLIKE) predicate
        */
        left := self.visitPredicate(ctx.Predicate(0)).(SqlToken)
        right := self.visitPredicate(ctx.Predicate(1)).(SqlToken)
        var name string
        if n := ctx.NOT(); n != nil </span><span class="cov0" title="0">{
                name = "not_regexp"
        }</span> else<span class="cov0" title="0"> {
                name = "regexp"
        }</span>
        <span class="cov0" title="0">return &amp;Func{
                Name: name,
                Args: []interface{}{left, right},
        }</span>
}

func (self *visitor) doVisitConstant(ctx *parser.ConstantContext) SqlToken <span class="cov8" title="1">{
        /*
                STRING_LITERAL | DECIMAL_LITERAL
                | '-' DECIMAL_LITERAL
                | booleanLiteral
                | REAL_LITERAL
                | NOT? nullLiteral=(NULL_LITERAL | NULL_SPEC_LITERAL)
        */
        str := ctx.STRING_LITERAL()
        if str != nil </span><span class="cov8" title="1">{
                s := str.GetText()
                return &amp;Const{Value: s[1 : len(s)-1]}
        }</span>
        <span class="cov8" title="1">decimal := ctx.DECIMAL_LITERAL()
        minus := ctx.MINUS()
        if decimal != nil </span><span class="cov8" title="1">{
                num, _ := strconv.Atoi(decimal.GetText())
                var value int
                if minus != nil </span><span class="cov0" title="0">{
                        value = -1 * num
                }</span> else<span class="cov8" title="1"> {
                        value = num
                }</span>
                <span class="cov8" title="1">return &amp;Const{Value: value}</span>
        }
        <span class="cov0" title="0">boolean := ctx.BooleanLiteral()
        if boolean != nil </span><span class="cov0" title="0">{
                return self.doVisitBooleanLiteral(boolean.(*parser.BooleanLiteralContext))
        }</span>
        <span class="cov0" title="0">realNum := ctx.REAL_LITERAL()
        if realNum != nil </span><span class="cov0" title="0">{
                var value float64
                value, _ = strconv.ParseFloat(realNum.GetText(), 64)
                return &amp;Const{Value: value}
        }</span>
        <span class="cov0" title="0">if ctx.NOT() != nil </span><span class="cov0" title="0">{
                if ctx.NULL_LITERAL() != nil </span><span class="cov0" title="0">{
                        return &amp;Func{
                                Name: "not",
                                Args: []interface{}{&amp;Const{Value: nil}},
                        }
                }</span> else<span class="cov0" title="0"> {
                        return &amp;Const{Value: "\n"}
                }</span>
        }
        <span class="cov0" title="0">if ctx.NULL_LITERAL() != nil </span><span class="cov0" title="0">{
                return &amp;Const{Value: nil}
        }</span> else<span class="cov0" title="0"> {
                return &amp;Const{Value: "\n"}
        }</span>
}

func (self *visitor) doVisitBooleanLiteral(ctx *parser.BooleanLiteralContext) *Const <span class="cov0" title="0">{
        if ctx.TRUE() != nil </span><span class="cov0" title="0">{
                return &amp;Const{Value: true}
        }</span> else<span class="cov0" title="0"> {
                return &amp;Const{Value: false}
        }</span>
}

func (self *visitor) doVisitFullColumnName(ctx *parser.FullColumnNameContext) *Var <span class="cov8" title="1">{
        /*
                ID DOT_ID*
        */
        name := &amp;Const{Value: ctx.ID().GetText()}
        columnName := &amp;Var{Value: name}
        var curColumnName *Var
        curColumnName = columnName
        for _, next := range ctx.AllDOT_ID() </span><span class="cov8" title="1">{
                nextColumnName := &amp;Var{Value: &amp;Const{Value: next.GetText()[1:]}}
                curColumnName.Next = nextColumnName
                curColumnName = nextColumnName
        }</span>
        <span class="cov8" title="1">return columnName</span>
}

func (self *visitor) doVisitCaseFunctionCall(ctx *parser.CaseFunctionCallContext) *Case <span class="cov8" title="1">{
        /*
                CASE caseFuncAlternative+
                (ELSE elseArg=functionArg)? END
        */
        var args []*CaseItem
        for _, funcAlternative := range ctx.AllCaseFuncAlternative() </span><span class="cov8" title="1">{
                args = append(args, self.doVisitCaseFuncAlternative(
                        funcAlternative.(*parser.CaseFuncAlternativeContext)))
        }</span>
        <span class="cov8" title="1">if ctx.ELSE() != nil </span><span class="cov8" title="1">{
                args = append(args, &amp;CaseItem{
                        Condition: nil,
                        Value:     self.doVisitFunctionArg(ctx.FunctionArg().(*parser.FunctionArgContext)).(SqlToken),
                })
        }</span>

        <span class="cov8" title="1">return &amp;Case{Values: args}</span>
}

func (self *visitor) doVisitCaseVarFunctionCall(ctx *parser.CaseVarFunctionCallContext) *Case <span class="cov8" title="1">{
        /*
                CASE fullColumnName caseFuncAlternative+
                   (ELSE elseArg=functionArg)? END
        */
        var args []*CaseItem
        expr := self.doVisitFullColumnName(ctx.FullColumnName().(*parser.FullColumnNameContext))
        for _, funcAlternative := range ctx.AllCaseFuncAlternative() </span><span class="cov8" title="1">{
                caseItem := self.doVisitCaseFuncAlternative(
                        funcAlternative.(*parser.CaseFuncAlternativeContext))
                caseItem.Condition = &amp;Func{
                        Name: "=",
                        Args: []interface{}{caseItem.Condition, expr},
                }
                args = append(args, caseItem)
        }</span>
        <span class="cov8" title="1">if ctx.ELSE() != nil </span><span class="cov0" title="0">{
                args = append(args, &amp;CaseItem{
                        Condition: nil,
                        Value:     self.doVisitFunctionArg(ctx.FunctionArg().(*parser.FunctionArgContext)).(SqlToken),
                })
        }</span>

        <span class="cov8" title="1">return &amp;Case{Values: args}</span>
}

func (self *visitor) doVisitFunctionArg(ctx *parser.FunctionArgContext) interface{} <span class="cov8" title="1">{
        /*
                constant | fullColumnName | functionCall | expression
        */
        if c := ctx.Constant(); c != nil </span><span class="cov8" title="1">{
                return self.doVisitConstant(c.(*parser.ConstantContext))
        }</span>
        <span class="cov8" title="1">if f := ctx.FullColumnName(); f != nil </span><span class="cov8" title="1">{
                return self.doVisitFullColumnName(f.(*parser.FullColumnNameContext))
        }</span>
        <span class="cov8" title="1">if fc := ctx.FunctionCall(); fc != nil </span><span class="cov0" title="0">{
                return self.visitFunctionCall(fc)
        }</span>
        <span class="cov8" title="1">return self.visitExpression(ctx.Expression())</span>
}

func (self *visitor) doVisitCaseFuncAlternative(ctx *parser.CaseFuncAlternativeContext) *CaseItem <span class="cov8" title="1">{
        /*
                WHEN condition=functionArg
                THEN consequent=functionArg
        */
        return &amp;CaseItem{
                Condition: self.doVisitFunctionArg(ctx.FunctionArg(0).(*parser.FunctionArgContext)).(SqlToken),
                Value:     self.doVisitFunctionArg(ctx.FunctionArg(1).(*parser.FunctionArgContext)).(SqlToken),
        }
}</span>

func (self *visitor) doVisitScalarFunctionCall(ctx *parser.ScalarFunctionCallContext) *Func <span class="cov8" title="1">{
        /*
                ID '(' functionArgs? ')'
        */
        funcName := ctx.ID().GetText()
        _funcArgs := ctx.FunctionArgs()
        name := strings.ToLower(funcName)
        if _funcArgs != nil </span><span class="cov8" title="1">{
                funcArgs := self.doVisitFunctionArgs(_funcArgs.(*parser.FunctionArgsContext))
                return &amp;Func{Name: name, Args: funcArgs}
        }</span>
        <span class="cov0" title="0">return &amp;Func{Name: name, Args: make([]interface{}, 0)}</span>
}

func (self *visitor) doVisitUnaryExpressionAtom(ctx *parser.UnaryExpressionAtomContext) *Func <span class="cov0" title="0">{
        /*
                unaryOperator expressionAtom
        */
        expressionAtom := self.visitExpressionAtom(ctx.ExpressionAtom()).(SqlToken)
        op := self.doVisitUnaryOperator(ctx.UnaryOperator().(*parser.UnaryOperatorContext))
        return &amp;Func{Name: op, Args: []interface{}{expressionAtom}}
}</span>

func (self *visitor) doVisitUnaryOperator(ctx *parser.UnaryOperatorContext) string <span class="cov0" title="0">{
        if ctx.NOT() != nil </span><span class="cov0" title="0">{
                return "signal_not"
        }</span> else<span class="cov0" title="0"> {
                return "signal_" + self.VisitChildren(ctx).(antlr.ParseTree).GetText()
        }</span>
}

func (self *visitor) doVisitNestedExpressionAtom(ctx *parser.NestedExpressionAtomContext) []SqlToken <span class="cov8" title="1">{
        /*
                '(' expression (',' expression)* ')'
        */
        var args []SqlToken
        items := ctx.AllExpression()
        for _, item := range items </span><span class="cov8" title="1">{
                args = append(args, self.visitExpression(item).(SqlToken))
        }</span>
        <span class="cov8" title="1">return args</span>
}

func (self *visitor) doVisitExistsExpressionAtom(ctx *parser.ExistsExpressionAtomContext) *Func <span class="cov0" title="0">{
        /*
                EXISTS '(' selectStatement ')'
        */
        selectStatement := self.visitSelectStatement(ctx.SelectStatement())
        return &amp;Func{Name: "exits", Args: []interface{}{selectStatement}}
}</span>

func (self *visitor) doVisitMathExpressionAtom(ctx *parser.MathExpressionAtomContext) *Func <span class="cov8" title="1">{
        /*
                left=expressionAtom mathOperator right=expressionAtom
        */
        left := self.visitExpressionAtom(ctx.ExpressionAtom(0)).(SqlToken)
        right := self.visitExpressionAtom(ctx.ExpressionAtom(1)).(SqlToken)
        op := self.doVisitMathOperator(ctx.MathOperator().(*parser.MathOperatorContext))
        return &amp;Func{Name: op, Args: []interface{}{left, right}}
}</span>

func (self *visitor) doVisitMathOperator(ctx *parser.MathOperatorContext) string <span class="cov8" title="1">{
        /*
                '+' | '-' | '--'
        */
        return ctx.GetChildren()[0].(antlr.ParseTree).GetText()
}</span>

func (self *visitor) doVisitPriorityMathExpressionAtom(ctx *parser.PriorityMathExpressionAtomContext) *Func <span class="cov8" title="1">{
        /*
                left=expressionAtom op=('*'|'/'|'%'| DIV | MOD) right=expressionAtom
        */
        left := self.visitExpressionAtom(ctx.ExpressionAtom(0)).(SqlToken)
        right := self.visitExpressionAtom(ctx.ExpressionAtom(1)).(SqlToken)
        return &amp;Func{Name: ctx.GetOp().GetText(), Args: []interface{}{left, right}}
}</span>

func (self *visitor) doVisitLogicalOperator(ctx *parser.LogicalOperatorContext) string <span class="cov8" title="1">{
        /*
                AND | OR
        */
        if ctx.AND() != nil </span><span class="cov8" title="1">{
                return "and"
        }</span> else<span class="cov8" title="1"> {
                return "or"
        }</span>
}

func (self *visitor) visitSpecificFunctionCall(node antlr.Tree) SqlToken <span class="cov8" title="1">{
        switch ctx := node.(type) </span>{
        case *parser.CaseFunctionCallContext:<span class="cov8" title="1">
                return self.doVisitCaseFunctionCall(ctx)</span>
        case *parser.CaseVarFunctionCallContext:<span class="cov8" title="1">
                return self.doVisitCaseVarFunctionCall(ctx)</span>
        default:<span class="cov0" title="0">
                logrus.Errorf("[visitSpecificFunctionCall] no such type [%T]", ctx)
                return nil</span>
        }
}

func (self *visitor) visitFunctionCall(node antlr.Tree) SqlToken <span class="cov8" title="1">{
        switch ctx := node.(type) </span>{
        case *parser.ScalarFunctionCallContext:<span class="cov8" title="1">
                return self.doVisitScalarFunctionCall(ctx)</span>
        case *parser.SpecificFunctionCallContext:<span class="cov8" title="1">
                return self.visitSpecificFunctionCall(ctx.SpecificFunction())</span>
        default:<span class="cov0" title="0">
                logrus.Errorf("[visitFunctionCall] no such type [%T]", ctx)
                return nil</span>
        }
}

func (self *visitor) visitExpression(node antlr.Tree) interface{} <span class="cov8" title="1">{
        switch ctx := node.(type) </span>{
        case *parser.NotExpressionContext:<span class="cov0" title="0">
                return self.doVisitNotExpression(ctx)</span>
        case *parser.LogicalExpressionContext:<span class="cov8" title="1">
                return self.doVisitLogicalExpression(ctx)</span>
        case *parser.IsExpressionContext:<span class="cov0" title="0">
                return self.doVisitIsExpression(ctx)</span>
        case *parser.PredicateExpressionContext:<span class="cov8" title="1">
                return self.visitPredicate(ctx.Predicate())</span>
        default:<span class="cov0" title="0">
                logrus.Errorf("[visitExpression] no such type [%T]", ctx)
                return nil</span>
        }
}

func (self *visitor) visitPredicate(node antlr.Tree) interface{} <span class="cov8" title="1">{
        switch ctx := node.(type) </span>{
        case *parser.InPredicateContext:<span class="cov8" title="1">
                return self.doVisitInPredicate(ctx)</span>
        case *parser.IsNullPredicateContext:<span class="cov0" title="0">
                return self.doVisitIsNullPredicate(ctx)</span>
        case *parser.BinaryComparasionPredicateContext:<span class="cov8" title="1">
                return self.doVisitBinaryComparasionPredicate(ctx)</span>
        case *parser.SubqueryComparasionPredicateContext:<span class="cov0" title="0">
                return self.doVisitSubqueryComparasionPredicate(ctx)</span>
        case *parser.BetweenPredicateContext:<span class="cov0" title="0">
                return self.doVisitBetweenPredicate(ctx)</span>
        case *parser.LikePredicateContext:<span class="cov0" title="0">
                return self.doVisitLikePredicate(ctx)</span>
        case *parser.RegexpPredicateContext:<span class="cov0" title="0">
                return self.doVisitRegexpPredicate(ctx)</span>
        case *parser.ExpressionAtomPredicateContext:<span class="cov8" title="1">
                return self.visitExpressionAtom(ctx.ExpressionAtom())</span>
        default:<span class="cov0" title="0">
                logrus.Errorf("[visitPredicate] no such type [%T]", ctx)
                return nil</span>
        }
}

func (self *visitor) visitExpressionAtom(node antlr.Tree) interface{} <span class="cov8" title="1">{
        switch ctx := node.(type) </span>{
        case *parser.ConstantExpressionAtomContext:<span class="cov8" title="1">
                return self.doVisitConstant(ctx.Constant().(*parser.ConstantContext))</span>
        case *parser.FullColumnNameExpressionAtomContext:<span class="cov8" title="1">
                return self.doVisitFullColumnName(ctx.FullColumnName().(*parser.FullColumnNameContext))</span>
        case *parser.FunctionCallExpressionAtomContext:<span class="cov8" title="1">
                return self.visitFunctionCall(ctx.FunctionCall())</span>
        case *parser.UnaryExpressionAtomContext:<span class="cov0" title="0">
                return self.doVisitUnaryExpressionAtom(ctx)</span>
        case *parser.NestedExpressionAtomContext:<span class="cov8" title="1">
                return self.doVisitNestedExpressionAtom(ctx)</span>
        case *parser.ExistsExpressionAtomContext:<span class="cov0" title="0">
                return self.doVisitExistsExpressionAtom(ctx)</span>
        case *parser.SubqueryExpressionAtomContext:<span class="cov0" title="0">
                return self.visitSelectStatement(ctx.SelectStatement())</span>
        case *parser.PriorityMathExpressionAtomContext:<span class="cov8" title="1">
                return self.doVisitPriorityMathExpressionAtom(ctx)</span>
        case *parser.MathExpressionAtomContext:<span class="cov8" title="1">
                return self.doVisitMathExpressionAtom(ctx)</span>
        default:<span class="cov0" title="0">
                logrus.Errorf("[visitExpressionAtom] no such type [%T]", ctx)
                return nil</span>
        }
}

func (self *visitor) visitSelectElement(node antlr.Tree) SqlToken <span class="cov8" title="1">{
        switch ctx := node.(type) </span>{
        case *parser.SelectColumnElementContext:<span class="cov8" title="1">
                return self.doVisitSelectColumnElement(ctx)</span>
        case *parser.SelectFunctionElementContext:<span class="cov8" title="1">
                return self.doVisitSelectFunctionElement(ctx)</span>
        case *parser.SelectExpressionElementContext:<span class="cov8" title="1">
                return self.doVisitSelectExpressionElement(ctx)</span>
        default:<span class="cov0" title="0">
                logrus.Errorf("[visitSelectElement] no such type [%T]", ctx)
                return nil</span>
        }
}

func (self *visitor) visitTableSourceItem(node antlr.Tree) SqlToken <span class="cov8" title="1">{
        switch ctx := node.(type) </span>{
        case *parser.AtomTableItemContext:<span class="cov8" title="1">
                return self.doVisitAtomTableItem(ctx)</span>
        case *parser.SubqueryTableItemContext:<span class="cov0" title="0">
                return self.doVisitSubqueryTableItem(ctx)</span>
        case *parser.TableSourcesItemContext:<span class="cov0" title="0">
                return self.doVisitTableSourcesItem(ctx)</span>
        default:<span class="cov0" title="0">
                logrus.Errorf("[visitTableSourceItem] no such type [%T]", ctx)
                return nil</span>
        }
}

func (self *visitor) visitJoinPart(node antlr.Tree) SqlToken <span class="cov8" title="1">{
        switch ctx := node.(type) </span>{
        case *parser.InnerJoinContext:<span class="cov8" title="1">
                return self.doVisitInnerJoin(ctx)</span>
        case *parser.OuterJoinContext:<span class="cov0" title="0">
                return self.doVisitOuterJoin(ctx)</span>
        default:<span class="cov0" title="0">
                logrus.Errorf("[visitJoinPart] no such type [%T]", ctx)
                return nil</span>
        }
}

func (self *visitor) visitTableSource(node antlr.Tree) *Tables <span class="cov8" title="1">{
        switch ctx := node.(type) </span>{
        case *parser.TableSourceBaseContext:<span class="cov8" title="1">
                return self.doVisitTableSourceBase(ctx)</span>
        case *parser.TableSourceNestedContext:<span class="cov0" title="0">
                return self.doVisitTableSourceNested(ctx)</span>
        default:<span class="cov0" title="0">
                logrus.Errorf("[visitTableSource] no such type [%T]", ctx)
                return nil</span>
        }
}

func (self *visitor) visitSelectStatement(node antlr.Tree) *Link <span class="cov8" title="1">{
        switch ctx := node.(type) </span>{
        case *parser.SimpleSelectContext:<span class="cov8" title="1">
                return self.doVisitQuerySpecification(ctx.QuerySpecification().(*parser.QuerySpecificationContext))</span>
        case *parser.ParenthesisSelectContext:<span class="cov0" title="0">
                return self.doVisitQueryExpression(ctx.QueryExpression().(*parser.QueryExpressionContext))</span>
        default:<span class="cov0" title="0">
                logrus.Errorf("[visitSelectStatement] no such type [%T]", ctx)
                return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package golinq

import (
        "context"
        "database/sql/driver"
        "errors"
        "fmt"
        "math/rand"
        "strings"
)

// FakeStmt  is implementation of Stmt sql interfcae
type FakeStmt struct {
        connection   *FakeConn
        q            string    // SQL 语句
        command      string    // SELECT, INSERT, UPDATE, DELETE
        next         *FakeStmt // used for returning multiple results.
        closed       bool      // If connection closed already
        colName      []string  // Names of columns in response
        colType      []string  // Not used for now
        placeholders int       // Amount of passed args
}

// ColumnConverter returns a ValueConverter for the provided
// column index.
func (s *FakeStmt) ColumnConverter(idx int) driver.ValueConverter <span class="cov8" title="1">{
        return driver.DefaultParameterConverter
}</span>

// Close closes the connection
func (s *FakeStmt) Close() error <span class="cov8" title="1">{
        // No connection added
        if s.connection == nil </span><span class="cov0" title="0">{
                panic("nil conn in FakeStmt.Close")</span>
        }
        <span class="cov8" title="1">if s.connection.db == nil </span><span class="cov0" title="0">{
                panic("in FakeStmt.Close, conn's db is nil (already closed)")</span>
        }
        <span class="cov8" title="1">if !s.closed </span><span class="cov8" title="1">{
                s.closed = true
        }</span>
        <span class="cov8" title="1">if s.next != nil </span><span class="cov0" title="0">{
                s.next.Close()
        }</span>
        <span class="cov8" title="1">return nil</span>
}

var errClosed = errors.New("fake_db_driver: statement has been closed")

// Exec executes a query that doesn't return rows, such
// as an INSERT or UPDATE.
//
// Deprecated: Drivers should implement StmtExecContext instead (or additionally).
func (s *FakeStmt) Exec(args []driver.Value) (driver.Result, error) <span class="cov0" title="0">{
        panic("Using ExecContext")</span>
}

// ExecContext executes a query that doesn't return rows, such
// as an INSERT or UPDATE.
func (s *FakeStmt) ExecContext(ctx context.Context, args []driver.NamedValue) (driver.Result, error) <span class="cov8" title="1">{
        if s.closed </span><span class="cov0" title="0">{
                return nil, errClosed
        }</span>

        <span class="cov8" title="1">if len(args) &gt; 0 </span><span class="cov8" title="1">{
                // Replace all "?" to "%v" and replace them with the values after
                for i := 0; i &lt; len(args); i++ </span><span class="cov8" title="1">{
                        s.q = strings.Replace(s.q, "?", "%v", 1)
                        s.q = fmt.Sprintf(s.q, args[i].Value)
                }</span>
        }
        <span class="cov8" title="1">s.q = strings.Replace(s.q, "\"", "", -1)
        res := SqlRun(s.q, DB2DataBase[s.connection.db.name], "").(int)
        fResp := &amp;FakeResponse{
                Response:     make([]map[string]interface{}, 0),
                Exceptions:   &amp;Exceptions{},
                RowsAffected: int64(res),
                LastInsertID: int64(res),
        }

        // To emulate any exception during query which returns rows
        if fResp.Exceptions != nil &amp;&amp; fResp.Exceptions.HookExecBadConnection != nil &amp;&amp; fResp.Exceptions.HookExecBadConnection() </span><span class="cov0" title="0">{
                return nil, driver.ErrBadConn
        }</span>

        <span class="cov8" title="1">if fResp.Error != nil </span><span class="cov0" title="0">{
                return nil, fResp.Error
        }</span>

        <span class="cov8" title="1">if fResp.Callback != nil </span><span class="cov0" title="0">{
                fResp.Callback(s.q, args)
        }</span>

        <span class="cov8" title="1">switch s.command </span>{
        case "INSERT":<span class="cov8" title="1">
                id := fResp.LastInsertID
                if id == 0 </span><span class="cov0" title="0">{
                        id = rand.Int63()
                }</span>
                <span class="cov8" title="1">res := NewFakeResult(id, 1)
                return res, nil</span>
        case "UPDATE":<span class="cov8" title="1">
                return driver.RowsAffected(fResp.RowsAffected), nil</span>
        case "DELETE":<span class="cov8" title="1">
                return driver.RowsAffected(fResp.RowsAffected), nil</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("unimplemented statement Exec command type of %q", s.command)</span>
}

// 废弃了
func (s *FakeStmt) Query(args []driver.Value) (driver.Rows, error) <span class="cov0" title="0">{
        panic("Use QueryContext")</span>
}

// QueryContext executes a query that may return rows, such as a
// SELECT.
func (s *FakeStmt) QueryContext(ctx context.Context, args []driver.NamedValue) (driver.Rows, error) <span class="cov8" title="1">{

        if s.closed </span><span class="cov0" title="0">{
                return nil, errClosed
        }</span>

        <span class="cov8" title="1">if len(args) &gt; 0 </span><span class="cov8" title="1">{
                // Replace all "?" to "%v" and replace them with the values after
                for i := 0; i &lt; len(args); i++ </span><span class="cov8" title="1">{
                        s.q = strings.Replace(s.q, "?", "%v", 1)
                        s.q = fmt.Sprintf(s.q, args[i].Value)
                }</span>
        }

        <span class="cov8" title="1">s.q = strings.Replace(s.q, "\"", "", -1)

        records := SqlRun(s.q, DB2DataBase[s.connection.db.name], "")
        var resp []map[string]interface{}
        if records == nil </span><span class="cov0" title="0">{
                resp = make([]map[string]interface{}, 0, 0)
        }</span> else<span class="cov8" title="1"> {
                resp = make([]map[string]interface{}, 0, len(records.([]interface{})))
                for _, record := range records.([]interface{}) </span><span class="cov8" title="1">{
                        resp = append(resp, record.(map[string]interface{}))
                }</span>
        }
        <span class="cov8" title="1">fResp := &amp;FakeResponse{
                Response:   resp,
                Exceptions: &amp;Exceptions{},
        }
        //fResp := Catcher.FindResponse(s.q, args)

        // 看有没有钩子让你失败
        if fResp.Exceptions != nil &amp;&amp; fResp.Exceptions.HookQueryBadConnection != nil &amp;&amp; fResp.Exceptions.HookQueryBadConnection() </span><span class="cov0" title="0">{
                return nil, driver.ErrBadConn
        }</span>

        <span class="cov8" title="1">if fResp.Error != nil </span><span class="cov0" title="0">{
                return nil, fResp.Error
        }</span>

        <span class="cov8" title="1">resultRows := make([][]*row, 0, 1)
        columnNames := make([]string, 0, 1)
        columnTypes := make([][]string, 0, 1)
        rows := []*row{}

        // Check if we have such query in the map
        colIndexes := make(map[string]int)

        // 把列名以及列名的位置保存起来
        if len(fResp.Response) &gt; 0 </span><span class="cov8" title="1">{
                for colName := range fResp.Response[0] </span><span class="cov8" title="1">{
                        colIndexes[colName] = len(columnNames)
                        columnNames = append(columnNames, colName)
                }</span>
        }

        // Extracting values from result according columns
        <span class="cov8" title="1">for _, record := range fResp.Response </span><span class="cov8" title="1">{
                oneRow := &amp;row{cols: make([]interface{}, len(columnNames))}
                for _, col := range columnNames </span><span class="cov8" title="1">{
                        oneRow.cols[colIndexes[col]] = record[col]
                }</span>
                <span class="cov8" title="1">rows = append(rows, oneRow)</span>
        }
        <span class="cov8" title="1">resultRows = append(resultRows, rows)

        cursor := &amp;RowsCursor{
                posRow:  -1,
                rows:    resultRows,
                cols:    columnNames,
                colType: columnTypes, // TODO: implement support of that
                errPos:  -1,
                closed:  false,
        }

        if fResp.Callback != nil </span><span class="cov0" title="0">{
                fResp.Callback(s.q, args)
        }</span>

        <span class="cov8" title="1">return cursor, nil</span>
}

// NumInput returns the number of placeholder parameters.
func (s *FakeStmt) NumInput() int <span class="cov8" title="1">{
        return s.placeholders
}</span>

// FakeTx implements Tx interface
type FakeTx struct {
        c *FakeConn
}

// HookBadCommit is a hook to simulate broken connections
var HookBadCommit func() bool

// Commit commits the transaction
func (tx *FakeTx) Commit() error <span class="cov8" title="1">{
        tx.c.currTx = nil
        if HookBadCommit != nil &amp;&amp; HookBadCommit() </span><span class="cov0" title="0">{
                return driver.ErrBadConn
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// HookBadRollback is a hook to simulate broken connections
var HookBadRollback func() bool

// Rollback rollbacks the transaction
func (tx *FakeTx) Rollback() error <span class="cov0" title="0">{
        tx.c.currTx = nil
        if HookBadRollback != nil &amp;&amp; HookBadRollback() </span><span class="cov0" title="0">{
                return driver.ErrBadConn
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package test

import (
        "strings"
)

func isEqual(res1 []interface{}, res2 []interface{}) bool <span class="cov8" title="1">{
        if len(res1) != len(res2) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">for index, dict := range res1 </span><span class="cov8" title="1">{
                if len(dict.(map[string]interface{})) != len(res2[index].(map[string]interface{})) </span><span class="cov0" title="0">{
                        return false
                }</span> else<span class="cov8" title="1"> {
                        for key, value := range dict.(map[string]interface{}) </span><span class="cov8" title="1">{
                                switch expr := value.(type) </span>{
                                case []interface{}:<span class="cov8" title="1">
                                        if lstEqual(expr, res2[index].(map[string]interface{})[key].([]interface{})) == false </span><span class="cov0" title="0">{
                                                return false
                                        }</span>
                                case []string:<span class="cov8" title="1">
                                        if lstStringEqual(expr, res2[index].(map[string]interface{})[key].([]string)) == false </span><span class="cov0" title="0">{
                                                return false
                                        }</span>
                                case map[string]interface{}:<span class="cov8" title="1">
                                        if dictEqual(expr, res2[index].(map[string]interface{})[key].(map[string]interface{})) == false </span><span class="cov0" title="0">{
                                                return false
                                        }</span>
                                default:<span class="cov8" title="1">
                                        if value != res2[index].(map[string]interface{})[key] </span><span class="cov0" title="0">{
                                                return false
                                        }</span>
                                }

                        }
                }
        }
        <span class="cov8" title="1">return true</span>
}

func dictEqual(items1 map[string]interface{}, items2 map[string]interface{}) bool <span class="cov8" title="1">{
        for key, value := range items1 </span><span class="cov8" title="1">{
                switch expr := value.(type) </span>{
                case []interface{}:<span class="cov0" title="0">
                        if lstEqual(expr, items2[key].([]interface{})) == false </span><span class="cov0" title="0">{
                                return false
                        }</span>
                case map[string]interface{}:<span class="cov0" title="0">
                        if dictEqual(expr, items2[key].(map[string]interface{})) == false </span><span class="cov0" title="0">{
                                return false
                        }</span>
                default:<span class="cov8" title="1">
                        if value != items2[key] </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
        }
        <span class="cov8" title="1">return true</span>
}

func lstEqual(items1 []interface{}, items2 []interface{}) bool <span class="cov8" title="1">{
        for i, v1 := range items1 </span><span class="cov8" title="1">{
                switch expr := v1.(type) </span>{
                case []interface{}:<span class="cov0" title="0">
                        if lstEqual(expr, items2[i].([]interface{})) == false </span><span class="cov0" title="0">{
                                return false
                        }</span>
                case map[string]interface{}:<span class="cov0" title="0">
                        if dictEqual(expr, items2[i].(map[string]interface{})) == false </span><span class="cov0" title="0">{
                                return false
                        }</span>
                default:<span class="cov8" title="1">
                        if v1 != items2[i] </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
        }
        <span class="cov8" title="1">return true</span>
}

func lstStringEqual(items1 []string, items2 []string) bool <span class="cov8" title="1">{
        for i, v1 := range items1 </span><span class="cov8" title="1">{
                if v1 != items2[i] </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func quickSort(arr *[]interface{}, start, end int, keys []string) <span class="cov8" title="1">{
        if start &lt; end </span><span class="cov8" title="1">{
                i, j := start, end
                key := (*arr)[(start+end)/2]
                for i &lt;= j </span><span class="cov8" title="1">{
                        for compareRecord((*arr)[i].(map[string]interface{}), key.(map[string]interface{}), keys) &lt; 0 </span><span class="cov8" title="1">{
                                i++
                        }</span>
                        <span class="cov8" title="1">for compareRecord((*arr)[j].(map[string]interface{}), key.(map[string]interface{}), keys) &gt; 0 </span><span class="cov8" title="1">{
                                j--
                        }</span>
                        <span class="cov8" title="1">if i &lt;= j </span><span class="cov8" title="1">{
                                (*arr)[i], (*arr)[j] = (*arr)[j], (*arr)[i]
                                i++
                                j--
                        }</span>
                }

                <span class="cov8" title="1">if start &lt; j </span><span class="cov8" title="1">{
                        quickSort(arr, start, j, keys)
                }</span>
                <span class="cov8" title="1">if end &gt; i </span><span class="cov8" title="1">{
                        quickSort(arr, i, end, keys)
                }</span>
        }
}

func compare(item interface{}, item2 interface{}) int <span class="cov8" title="1">{
        switch item1 := item.(type) </span>{
        case string:<span class="cov8" title="1">
                return strings.Compare(item1, item2.(string))</span>
        case int:<span class="cov8" title="1">
                if item1 &gt; item2.(int) </span><span class="cov8" title="1">{
                        return 1
                }</span> else<span class="cov8" title="1"> if item1 &lt; item2.(int) </span><span class="cov8" title="1">{
                        return -1
                }</span>
                <span class="cov8" title="1">return 0</span>
        case float64:<span class="cov8" title="1">
                if item1 &gt; item2.(float64) </span><span class="cov8" title="1">{
                        return 1
                }</span> else<span class="cov8" title="1"> if item1 &lt; item2.(float64) </span><span class="cov8" title="1">{
                        return -1
                }</span>
                <span class="cov8" title="1">return 0</span>
        default:<span class="cov0" title="0">
                panic("类型错误")</span>
        }
}

func compareRecord(record map[string]interface{}, record2 map[string]interface{}, keys []string) int <span class="cov8" title="1">{
        for _, key := range keys </span><span class="cov8" title="1">{
                res := compare(record[key], record2[key])
                if res &gt; 0 </span><span class="cov8" title="1">{
                        return 1
                }</span> else<span class="cov8" title="1"> if res &lt; 0 </span><span class="cov8" title="1">{
                        return -1
                }</span>
        }
        <span class="cov8" title="1">return 0</span>
}

func sorted(res *[]interface{}, keys []string) <span class="cov8" title="1">{
        end := len(*res) - 1
        quickSort(res, 0, end, keys)
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package golinq

import (
        "fmt"
        "github.com/jinzhu/gorm"
        "github.com/pkg/errors"
        "go/ast"
        "reflect"
        "strings"
        "sync"
)

type Company struct {
        Id   int    `gorm:"primary_key" json:"id"`
        Name string `json:"name"`
}

func (Company) TableName() string <span class="cov8" title="1">{
        return "company"
}</span>

type Mobile struct {
        Id        int    `gorm:"primary_key" json:"id"`
        Name      string `json:"name"`
        CompanyId int    `json:"company_id"`
}

func (Mobile) TableName() string <span class="cov8" title="1">{
        return "mobile"
}</span>

type MobilePrice struct {
        Id       int     `gorm:"primary_key" json:"id"`
        MobileId int     `json:"mobile_id"`
        Type     int     `json:"type"`
        Price    float32 `json:"price"`
}

func (MobilePrice) TableName() string <span class="cov8" title="1">{
        return "mobile_price"
}</span>

func MessageDBError(message string) error <span class="cov0" title="0">{
        if message == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;DBError{message: message}</span>
}

type DBError struct {
        error
        message string
}

func MessageDBErrorf(message string, args ...interface{}) error <span class="cov0" title="0">{
        if message == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;DBError{message: fmt.Sprintf(message, args...)}</span>
}

func reflectValue(values interface{}) (reflect.Value, error) <span class="cov8" title="1">{
        if values == nil </span><span class="cov0" title="0">{
                return reflect.Value{}, errors.WithStack(MessageDBError("values is nil"))
        }</span>
        <span class="cov8" title="1">refValues := reflect.ValueOf(values)
        if refValues.IsNil() </span><span class="cov0" title="0">{
                return reflect.Value{}, errors.WithStack(MessageDBError("values is nil"))
        }</span>
        //判断是否为切片类型
        <span class="cov8" title="1">if refValues.Kind() != reflect.Slice </span><span class="cov0" title="0">{
                return reflect.Value{}, errors.WithStack(MessageDBErrorf("values type `%v`, not `Slice`", refValues.Kind()))
        }</span>
        <span class="cov8" title="1">if refValues.Len() == 0 </span><span class="cov0" title="0">{
                return reflect.Value{}, errors.WithStack(MessageDBError("values is empty"))
        }</span>
        <span class="cov8" title="1">return refValues, nil</span>
}

func (r *Company) BatchCreate(db *gorm.DB, values interface{}) (err error) <span class="cov8" title="1">{
        refValues, err := reflectValue(values)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">db = db.Table(r.TableName())
        //获取回调函数
        beginTransaction := db.Callback().Create().Get("gorm:begin_transaction")
        beforeCreate := db.Callback().Create().Get("gorm:before_create")
        updateTimeStamp := db.Callback().Create().Get("gorm:update_time_stamp")
        afterCreate := db.Callback().Create().Get("gorm:after_create")
        commitOrRollbackTransaction := db.Callback().Create().Get("gorm:commit_or_rollback_transaction")

        scope := db.NewScope(refValues.Index(0).Interface())
        beginTransaction(scope)
        beforeCreate(scope)
        updateTimeStamp(scope)

        columns := make([]string, 0)
        placeholders := make([]string, 0)
        var blankColumnsWithDefaultValue []string
        for _, field := range scope.Fields() </span><span class="cov8" title="1">{
                if field.IsNormal </span><span class="cov8" title="1">{
                        if field.IsBlank &amp;&amp; field.HasDefaultValue </span><span class="cov0" title="0">{
                                blankColumnsWithDefaultValue = append(blankColumnsWithDefaultValue, scope.Quote(field.DBName))
                                scope.InstanceSet("gorm:blank_columns_with_default_value", blankColumnsWithDefaultValue)
                        }</span> else<span class="cov8" title="1"> if !field.IsPrimaryKey || !field.IsBlank </span><span class="cov8" title="1">{
                                columns = append(columns, scope.Quote(field.DBName))
                                if field.Name == "Status" </span><span class="cov0" title="0">{
                                        placeholders = append(placeholders, scope.AddToVars(1))
                                }</span> else<span class="cov8" title="1"> {
                                        placeholders = append(placeholders, scope.AddToVars(field.Field.Interface()))
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">placeholdersList := make([]string, refValues.Len())
        placeholdersStr := fmt.Sprintf("(%s)", strings.Join(placeholders, ","))
        placeholdersList[0] = placeholdersStr

        for i := 1; i &lt; refValues.Len(); i++ </span><span class="cov8" title="1">{
                elemScope := db.NewScope(refValues.Index(i).Interface())
                beforeCreate(elemScope)
                updateTimeStamp(elemScope)
                for _, field := range elemScope.Fields() </span><span class="cov8" title="1">{
                        if field.IsNormal </span><span class="cov8" title="1">{
                                if field.Name == "Status" </span><span class="cov0" title="0">{
                                        scope.AddToVars(1)
                                }</span> else<span class="cov8" title="1"> if !field.IsPrimaryKey || !field.IsBlank </span><span class="cov8" title="1">{
                                        scope.AddToVars(field.Field.Interface())
                                }</span>
                        }
                }
                <span class="cov8" title="1">placeholdersList[i] = placeholdersStr</span>
        }

        <span class="cov8" title="1">sql := fmt.Sprintf("INSERT INTO %s (%s) VALUES %s",
                scope.QuotedTableName(),
                strings.Join(columns, ","),
                strings.Join(placeholdersList, ","),
        )
        err = scope.Raw(sql).Exec().DB().Error
        if err != nil </span><span class="cov0" title="0">{
                return errors.WithStack(err)
        }</span>
        <span class="cov8" title="1">afterCreate(scope)
        commitOrRollbackTransaction(scope)
        err = errors.WithStack(scope.DB().Error)
        return err</span>
}

// 字段数组传参为属性名，非表字段名
func (r *Company) BatchUpdate(db *gorm.DB, propertyNames []string, values interface{}) (err error) <span class="cov8" title="1">{
        refValues, err := reflectValue(values)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">indirectValue := reflect.Indirect(refValues)
        if indirectValue.Kind() != reflect.Slice </span><span class="cov0" title="0">{
                return errors.WithStack(MessageDBError("values is not `slice` type"))
        }</span>
        <span class="cov8" title="1">v := indirectValue.Index(0).Elem()
        fieldName2Index := depFieldName2Index(v, 2)
        ids := make([]interface{}, 0)
        for i := 0; i &lt; indirectValue.Len(); i++ </span><span class="cov8" title="1">{ //批量更新field
                ids = append(ids, reflect.Indirect(indirectValue.Index(i)).FieldByIndex(fieldName2Index["Id"]).Interface())
        }</span>
        <span class="cov8" title="1">sql := "UPDATE " + r.TableName() + " SET "
        args := make([]interface{}, 0)
        for j, fieldName := range propertyNames </span><span class="cov8" title="1">{
                field := gorm.ToDBName(fieldName)
                var set, when string
                set += field + " = CASE id"
                for i := 0; i &lt; indirectValue.Len(); i++ </span><span class="cov8" title="1">{
                        v := reflect.Indirect(indirectValue.Index(i))
                        when += " WHEN ? THEN ?"
                        args = append(args, ids[i], v.FieldByIndex(fieldName2Index[fieldName]).Interface())
                }</span>
                <span class="cov8" title="1">sql += set + when + " END"
                if j &lt; len(propertyNames)-1 </span><span class="cov0" title="0">{
                        sql += ","
                }</span>
        }
        <span class="cov8" title="1">sql += " WHERE id in (?);"
        args = append(args, ids)
        err = db.Exec(sql, args...).Error
        return errors.WithStack(err)</span>
}

func depFieldName2Index(value reflect.Value, depth int) map[string][]int <span class="cov8" title="1">{
        k := modelStructKey{t: value.Type(), d: depth}
        if v, ok := modelStructs.Load(k); ok </span><span class="cov0" title="0">{
                return v.(map[string][]int)
        }</span>
        <span class="cov8" title="1">name2Index := make(map[string][]int)
        fieldName2Index(value, name2Index, []int{}, depth)
        modelStructs.Store(k, name2Index)
        return name2Index</span>
}

type modelStructKey struct {
        t reflect.Type
        d int
}

var modelStructs = sync.Map{}

func fieldName2Index(value reflect.Value, name2Index map[string][]int, pre []int, depth int) <span class="cov8" title="1">{
        value = reflect.Indirect(value)
        kind := value.Kind()
        if kind != reflect.Struct || depth == 0 </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">v := reflect.Indirect(value)
        filedCount := v.NumField()
        for i := 0; i &lt; filedCount; i++ </span><span class="cov8" title="1">{
                field := v.Type().Field(i)
                if !ast.IsExported(field.Name) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">fieldName := field.Name
                f := gorm.ToDBName(fieldName)
                name2Index[f] = append(pre, i)
                name2Index[fieldName] = append(pre, i)
                fieldName2Index(value.Field(i), name2Index, name2Index[fieldName], depth-1)</span>
        }
}

</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
